<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content=" What to reply to a non-programmer who thinks that testing is unnecessary or secondary At some point during his or her career, a programmer might come across the following argument, presented by some colleague, partner, or decision maker:\nSince we can always test our software by hand, we do not need to implement Automated Software Testing.\nApparently, I reached that point in my career, so now I need to debate this argument. I decided to be a good internet citizen and publish my thoughts. So, in this post I am going to be deconstructing that argument, and demolishing it from every angle that it can be examined. I will be doing so using language that is easy to process by people from outside of our discipline.\n">
<title>The case for software testing</title>

<link rel='canonical' href='//localhost:1313/p/the-case-for-software-testing/'>

<link rel="stylesheet" href="/scss/style.min.21ef8ebc918342b23127db7e1cef326889b262bc982b25546ec94e1a9c73073b.css"><meta property='og:title' content="The case for software testing">
<meta property='og:description' content=" What to reply to a non-programmer who thinks that testing is unnecessary or secondary At some point during his or her career, a programmer might come across the following argument, presented by some colleague, partner, or decision maker:\nSince we can always test our software by hand, we do not need to implement Automated Software Testing.\nApparently, I reached that point in my career, so now I need to debate this argument. I decided to be a good internet citizen and publish my thoughts. So, in this post I am going to be deconstructing that argument, and demolishing it from every angle that it can be examined. I will be doing so using language that is easy to process by people from outside of our discipline.\n">
<meta property='og:url' content='//localhost:1313/p/the-case-for-software-testing/'>
<meta property='og:site_name' content='Michael&#39;s Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='testing' /><meta property='article:tag' content='software-engineering' /><meta property='article:tag' content='papers' /><meta property='article:published_time' content='2019-12-01T20:48:53&#43;00:00'/><meta property='article:modified_time' content='2025-10-13T22:24:24&#43;02:00'/>
<meta name="twitter:title" content="The case for software testing">
<meta name="twitter:description" content=" What to reply to a non-programmer who thinks that testing is unnecessary or secondary At some point during his or her career, a programmer might come across the following argument, presented by some colleague, partner, or decision maker:\nSince we can always test our software by hand, we do not need to implement Automated Software Testing.\nApparently, I reached that point in my career, so now I need to debate this argument. I decided to be a good internet citizen and publish my thoughts. So, in this post I am going to be deconstructing that argument, and demolishing it from every angle that it can be examined. I will be doing so using language that is easy to process by people from outside of our discipline.\n">
    <link rel="shortcut icon" href="/favicon.ico" />

      <script async src="https://www.googletagmanager.com/gtag/js?id=TODO"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'TODO');
        }
      </script>
    </head>
    <body class="
    article-page
     article-page">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
	
		
			<ol class="menu" id="main-menu">
				<li class="menu-bottom-section">
					<ol class="menu">
						
							<li id="dark-mode-toggle">
								<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



								<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



								<span>Dark Mode</span>
							</li>
						
					</ol>
				</li>
			</ol>
			

		<a href="/"><img src="/logo.svg" width="210" loading="lazy" alt="Logo"></a>

		
		
			
				<figure class="site-avatar">
					 <a href="/">
						
							<img src="https://gravatar.com/avatar/8d1c5b5578843f958430afe30e0cbb2fb5092b1712d1933ea37d7bf5cb4305ed?size=400" width="300" height="300" class="site-logo" loading="lazy" alt="Avatar">
						
					</a>
					
				</figure>
			
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="//localhost:1313/">Michael&#39;s Blog</a></h1>
            <h2 class="site-description">&#34;If it&#39;s worth doing, it&#39;s worth doing right.&#34;</h2>
        </div>
    </header><ul class="menu-social">
            
                <li>
                    <a 
                        href='/contact-via-e-mail/'
                        
                        title="e-Mail"
                        rel="me"
                    >
                        
                        
                            <!--
category: Communication
tags: [inbox, gmail, email, envelope, message]
version: "1.0"
unicode: "eae5"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M3 7a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v10a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-10z" />
  <path d="M3 7l9 6l9 -6" />
</svg>

                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='/contact-via-whatsapp/'
                        
                        title="WhatsApp"
                        rel="me"
                    >
                        
                        
                            <!--
tags: [logo, app, application, communication, text, messages, communicator, photos, images, videos, giphy]
category: Brand
version: "1.13"
unicode: "ec74"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M3 21l1.65 -3.8a9 9 0 1 1 3.4 2.9l-5.05 .9" />
  <path d="M9 10a.5 .5 0 0 0 1 0v-1a.5 .5 0 0 0 -1 0v1a5 5 0 0 0 5 5h1a.5 .5 0 0 0 0 -1h-1a.5 .5 0 0 0 0 1" />
</svg>

                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://github.com/mikenakis'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <!--
tags: [logo, website, hosting, project, programming, software, development]
category: Brand
version: "1.18"
unicode: "ec1c"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>

                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://www.linkedin.com/in/mikenakis'
                        target="_blank"
                        title="LinkedIn"
                        rel="me"
                    >
                        
                        
                            <!--
tags: [logo, website, corporation, work, business, internet]
category: Brand
version: "1.15"
unicode: "ec8c"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M8 11v5" />
  <path d="M8 8v.01" />
  <path d="M12 16v-5" />
  <path d="M16 16v-3a2 2 0 1 0 -4 0" />
  <path d="M3 7a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v10a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4z" />
</svg>

                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://stackoverflow.com/users/773113/mike-nakis'
                        target="_blank"
                        title="Stack Overflow"
                        rel="me"
                    >
                        
                        
                            <!--
tags: [social, media, programming, website]
category: Brand
version: "1.43"
unicode: "ef58"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M4 17v1a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-1" />
  <path d="M8 16h8" />
  <path d="M8.322 12.582l7.956 .836" />
  <path d="M8.787 9.168l7.826 1.664" />
  <path d="M10.096 5.764l7.608 2.472" />
</svg>

                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com/mikenakis'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <!--
tags: [logo, app, application, community, social, communication, website, user, post, images, photos, comment, feedback]
category: Brand
version: "1.18"
unicode: "ec27"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c0 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>

                        
                    </a>
                </li>
            
        </ul><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
            </ol>
        </li>
    </ol>
</aside>


    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">Table of contents</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#what-to-reply-to-a-non-programmer-who-thinks-that-testing-is-unnecessary-or-secondary">What to reply to a non-programmer who thinks that testing is unnecessary or secondary</a></li>
    <li><a href="#myth-1-software-testing-represents-a-big-investment">Myth #1: Software testing represents a <em>big</em> investment.</a></li>
    <li><a href="#myth-2-software-testing-represents-an-investment">Myth #2: Software testing represents an investment.</a></li>
    <li><a href="#myth-3-software-testing-is-just-sloppiness-management">Myth #3: Software testing is just sloppiness management.</a>
      <ol>
        <li><a href="#maturity">Maturity</a></li>
        <li><a href="#complexity">Complexity</a></li>
      </ol>
    </li>
    <li><a href="#myth-4-testing-has-no-visible-benefit-to-the-customers">Myth #4: Testing has no visible benefit to the customers</a></li>
    <li><a href="#myth-5-manual-testing-can-ensure-that-the-software-works">Myth #5: Manual testing can ensure that the software works.</a></li>
    <li><a href="#myth-6-manual-testing-takes-less-time-than-writing-tests">Myth #6: Manual testing takes less time than writing tests.</a></li>
    <li><a href="#myth-7-you-can-keep-developing-new-functionality-and-fixing-existing-issues-without-software-testing-in-place">Myth #7: You can keep developing new functionality and fixing existing issues without software testing in place.</a></li>
    <li><a href="#myth-8-software-testing-has-no-business-value">Myth #8: Software testing has no business value</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/the-case-for-software-testing/">The case for software testing</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2019-12-01 Sun 20:48:53 UTC</time>
            </div>
        

        
            <div>
                <!--
tags: [material, measure, time, timer, clock, sand]
version: "1.66"
category: System
unicode: "f146"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M6 20v-2a6 6 0 1 1 12 0v2a1 1 0 0 1 -1 1h-10a1 1 0 0 1 -1 -1z" />
  <path d="M6 4v2a6 6 0 1 0 12 0v-2a1 1 0 0 0 -1 -1h-10a1 1 0 0 0 -1 1z" />
</svg>

                <time class="article-time--reading">
                    26 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p><img src="/p/the-case-for-software-testing/media/test-pattern.webp"
	width="960"
	height="600"
	srcset="/p/the-case-for-software-testing/media/test-pattern_hu_381d45a688135199.webp 480w, /p/the-case-for-software-testing/media/test-pattern_hu_d0ce67d078ac478f.webp 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="160"
		data-flex-basis="384px"
	
>
</p>
<h3 id="what-to-reply-to-a-non-programmer-who-thinks-that-testing-is-unnecessary-or-secondary">What to reply to a non-programmer who thinks that testing is unnecessary or secondary
</h3><p>At some point during his or her career, a programmer might come across the following argument, presented by some colleague, partner, or decision maker:</p>
<blockquote>
<p>Since we can always test our software by hand, we do not need to implement Automated Software Testing.</p></blockquote>
<p>Apparently, I reached that point in my career, so now I need to debate this argument. I decided to be a good internet citizen and publish my thoughts. So, in this post I am going to be deconstructing that argument, and demolishing it from every angle that it can be examined. I will be doing so using language that is easy to process by people from outside of our discipline.</p>
<p>(Useful pre-reading: <a 
   href="/p/about-these-papers/"
   >About these papers</a>)</p>
<p>In the particular company where that argument was brought forth, there exist mitigating factors which are specific to the product, the customers, and the type of relationship we have with them, all of which make the argument not as unreasonable as it may sound when taken out of context. Even in light of these factors, the argument still deserves to be blown out of the water, but I will not be bothering the reader with the specific situation of this company, so as to ensure that the discussion is applicable to software development in general.</p>
<p>In its more complete form, the argument may go like this:</p>
<blockquote>
<p>Automated Software Testing represents a big investment for the company, where all the programmers in the house are spending copious amounts of time doing nothing but writing software tests, but these tests do not yield any visible benefit to the customers. Instead, the programmers should ensure that the software works by spending only a fraction of that time doing manual testing, and then we can take all the time that we save this way and invest it in developing new functionality and fixing existing issues.</p></blockquote>
<p>To put it more concisely, someone might say something along these lines:</p>
<blockquote>
<p>I do not see the business value in Automated Software Testing.</p></blockquote>
<p>This statement is a bunch of myths rolled up into an admirably terse statement. It is so disarmingly simple, that for a moment you might be at loss of how to respond. Where to begin, really. We need to look at the myths one by one. Here it goes:</p>
<h3 id="myth-1-software-testing-represents-a-big-investment">Myth #1: Software testing represents a <em>big</em> investment.
</h3><p>No it doesn&rsquo;t. Or maybe it does, but its ROI is so high that you absolutely don&rsquo;t want to miss it.</p>
<p>If you do not have software testing in place, then it is an established fact in our industry that you will end up spending an inordinate amount of time researching unexpected application behavior, troubleshooting code to explain the observed behavior, discovering bugs, fixing them, and often repeating this process a few times on each incident because the fix for one bug often creates another bug, or causes pre-existing bugs to manifest, often with the embarrassment of an intervening round-trip to the customer, because the &ldquo;fixed&rdquo; software was released before the newly introduced bugs were discovered.</p>
<p>Really, it works the same way as education. To quote a famous bumper sticker:</p>
<blockquote>
<p>You think education is expensive? Try ignorance!</p></blockquote>
<p>Furthermore, your choice of Manual Software Testing vs. Automated Software Testing has a significant impact on the development effort required after the testing, to fix the issues that the testing discovers.  It is a well established fact in the industry that the sooner a bug is discovered, the less it costs to fix it.</p>
<ul>
<li>The earliest time possible for fixing a mistake is when making it. That&rsquo;s why we use strongly typed programming languages, together with Integrated Development Environments that continuously compile our code as we are typing it: this way, any syntax error or type violation is immediately flagged by the IDE with a red underline, so we can see it and fix it before proceeding to type the next line of code. The cost of fixing that bug is near zero. (And one of the main reasons why virtually all scripting languages are absolutely horrible is that in those languages, even a typo can go undetected and become a bug.)</li>
<li>If you can&rsquo;t catch a bug at the moment you are introducing it, the next best time to catch it is when running automated tests, which is what you are supposed to do before committing your changes to the source code repository. If that doesn&rsquo;t happen, then the bug will be committed, and this already represents a considerable cost that you will have to pay later for fixing it.</li>
<li>The next best time to catch the bug is by running automated tests as part of the Continuous Build System. This will at least tell you that the most recent commit contained a bug.  If there is no Continuous Build with Automated Software Testing in place, then you suffer another steep increase in the price that you will have to pay for eventually fixing the bug.</li>
<li>By the time a human being gets around to manually testing the software and discovering the bug, many more commits may have been made to the source code repository. This means that by the time the bug is discovered, we will not necessarily know which commits contributed to it, nor which programmers made the relevant commits, and even if we do, they will at that moment be working on something else, which they will have to temporarily drop, and make an often painful mental context switch back to the task that they were working on earlier. Naturally, the more days pass between committing a bug and starting to fix it, the worse it gets.</li>
<li>At the extreme, consider trying to fix a bug months after it was introduced, when nobody knows anything about the changes that caused it, and the programmer who made those changes is not even with the company anymore. Someone has to become intimately familiar with that module in order to troubleshoot the problem, consider dozens of different commits that may have contributed to the bug, find it, and fix it. The cost of fixing that bug may amount to more than a programmer&rsquo;s monthly salary.</li>
</ul>
<p>This is why the entire software industry today literally swears in the name of testing: it helps to catch bugs as early as possible, and to keep the development workflow uninterrupted, so it ends up saving huge amounts of money.</p>
<h3 id="myth-2-software-testing-represents-an-investment">Myth #2: Software testing represents an investment.
</h3><p>No, it does not even. Software testing is regarded by our industry as an integral part of software development, so it is meaningless to examine it as an investment separate from the already-recognized-as-necessary investment of developing the software in the first place.</p>
<p>Beware of the invalid line of reasoning which says that in order to implement a certain piece of functionality all we need is 10 lines of production code which cost 100 bucks, whereas an additional 10 lines, that would only be testing the first 10 lines, and would cost an extra 100 bucks, are optional.</p>
<p>Instead, the valid reasoning is that in order to implement said functionality we will need 20 lines of code, which will cost 200 bucks. It just so happens that 10 of these lines will reside in a subfolder of the source code tree called &ldquo;production&rdquo;, while the other 10 lines will reside in a subfolder of the same tree called &ldquo;testing&rdquo;; however, the precise location of each group of lines is a trivial technicality, bearing no relation whatsoever to any notion of &ldquo;usefulness&rdquo; of one group of lines versus the other. The fact is that all 20 of those lines of code are essential in order to accomplish the desired result.</p>
<p>That&rsquo;s because production code without corresponding testing code cannot be said with any certainty to be implementing any functionality at all. The only thing that can be said about testless code is that it has so far been successful at creating the impression to human observers that its behavior sufficiently resembles some desired functionality. Furthermore, it can only be said to be successful to the extent that it has been observed thus far, meaning that a new observation tomorrow might very well find that it is doing something different.</p>
<p>That&rsquo;s a far cry from saying that &ldquo;this software does in fact implement that functionality&rdquo;.</p>
<h3 id="myth-3-software-testing-is-just-sloppiness-management">Myth #3: Software testing is just sloppiness management.
</h3><p>This is usually not voiced, but implied.  So, why can&rsquo;t programmers write correct software the first time around?  And why on earth can&rsquo;t software just stay correct once written?</p>
<p>There is a number of reasons for this, the most important ones have to do with the level of maturity of the software engineering discipline, and the complexity of the software that we are being asked to develop.</p>
<h4 id="maturity">Maturity
</h4><p>Software development is not a hard science like physics and math.  There exist some purely scientific concepts that you learn in the university, but they are rarely applicable to the every day reality of our work. When it comes to developing software, there is not as much help available to us as there is to other disciplines by means of universal laws, fundamental axioms, established common practices and rules, ubiquitous notations, books of formulas and procedures, ready made commercially available standardized components to build with, etc. It is difficult to even find parallels to draw for basic concepts of science and technology such as experimentation, measurement, and reproducibility. That&rsquo;s why software engineering is sometimes characterized as being more of an art than a science, and the fact that anyone can potentially become a programmer without necessarily having studied software engineering does not help to dispel this characterization.</p>
<p>Automated Software Testing is one of those developments in software engineering that make it more like a science than like an art. With testing we have finally managed to introduce the concepts of experimentation, measurement, and reproducibility in software engineering. Whether testability alone is enough to turn our discipline into a science is debatable, but without testing we can be certain that we are doing nothing but art.</p>
<h4 id="complexity">Complexity
</h4><p>The software systems that we develop today are immensely complex. A simple application which presents a user with just 4 successive yes/no choices has 16 different execution paths that must be tested. Increase the number of choices to 7, and the number of paths skyrockets to 128. Take a slightly longer but entirely realistic use case sequence of a real world application consisting of 20 steps, and the total number of paths exceeds one million. That&rsquo;s an awful lot of complexity, and so far we have only been considering yes/no choices. Now imagine each step consisting of not just a yes/no choice, but an entire screen full of clickable buttons and editable fields which are interacting with each other. This is not an extreme scenario, it is a rather commonplace situation, and its complexity is of truly astronomical proportions.</p>
<p>Interestingly enough, hardware engineers like to off-load complexity management to the software. Long gone are the times when machines consisted entirely of hardware, with levers and gears and belts and cams all carefully aligned to work in unison, so that turning a crank at one end would cause printed and folded newspapers to come out the other end. Nowadays, the components of the hardware tend to not interact with each other, because that would be too complex and too difficult to change; instead, every single sensor and every single actuator is connected to a central panel, from which software takes charge and orchestrates the whole thing.</p>
<p>However, software is not a magical place where complexity just vanishes; you cannot expect to provide software with complex inputs, expect complex outputs, and at the same time expect the insides of it to be nothing but purity and simplicity: a system cannot have less complexity than the complexity inherent in the function that it performs.</p>
<p>The value of moving the complexity from the hardware to the software is that the system is then easier to change, but when we say &ldquo;easier&rdquo; we do not mean &ldquo;simpler&rdquo;; all of the complexity is still there and must be dealt with. What we mean when we say &ldquo;easier to change&rdquo; is that in order to make a change <em><strong>we do not have to begin by sending new blueprints to the steel foundry</strong></em>. That&rsquo;s what that you gain by moving complexity from the hardware to the software: being able to change the system without messy, time-consuming, and costly interactions with the physical world.</p>
<p>So, even though we have eliminated those precisely crafted and carefully arranged levers and gears and belts and cams, their counterparts now exist in the software, you just do not see them, you have no way of seeing them unless you are a programmer, and just as the slightest modification to a physical machine of such complexity would be a strenuous ordeal, so is the slightest modification to a software system of similar complexity a strenuous ordeal.</p>
<p>Software can only handle complexity if done right. You cannot develop complex software without sophisticated automated software testing in place, and even if you develop it, you cannot make any assumptions whatsoever about its correctness. Furthermore, even if it appears to be working correctly, you cannot make the slightest change to it unless automated software testing is in place to determine that it is still working correctly after the change. That is because you simply cannot test thousands or millions of possible execution paths in any way other than in an automated way.</p>
<h3 id="myth-4-testing-has-no-visible-benefit-to-the-customers">Myth #4: Testing has no visible benefit to the customers
</h3><p>Yes it does. It is called reliable, consistent, correctly working software. It is also called software which is continuously improving instead of remaining stagnant due to fear of it breaking if sneezed at. It is also called receiving newly introduced features without losing old features that used to work but are now broken. And it is even called receiving an update as soon as it has been introduced instead of having to wait until some poor souls have clicked through the entire application over the course of several days to make sure everything still works as it used to.</p>
<h3 id="myth-5-manual-testing-can-ensure-that-the-software-works">Myth #5: Manual testing can ensure that the software works.
</h3><p>No it cannot. That&rsquo;s because the complexity of the software is usually far greater than what you could ever possibly hope to test by hand. An interactive application is not like a piece of fabric, which you can visually inspect and have a fair amount of certainty that it has no defects. You are going to need to interact with the software, in a mind-boggling number of different ways, to test for a mind-boggling number of possible failure modes.</p>
<p>When we do manual testing, in order to save time (and our sanity) we focus only on the subset of the functionality of the software which may have been affected by recent changes that have been made to the source code.  However, the choice of which subsets to test is necessarily based on our estimations and assumptions about what parts of the program may have been affected by our modifications, and also on guesses about the ways in which these parts could behave if adversely affected. Alas, these estimations, assumptions, and guesses are notoriously unreliable: it is usually the parts of the software that nobody expected to break that in fact break, and even the suspected parts sometimes break in ways quite different from what anyone had expected and planned to test for.</p>
<p>And this is by definition so, because all the failure modes that we can easily foresee, based on the modifications that we make, we usually examine ourselves before even calling the modifications complete and committing our code.</p>
<p>Furthermore, it is widely understood in our industry that persons involved in the development of software are generally unsuitable for testing it.  No developer ever uses the software with as much recklessness and capriciousness as a user will. It is as if the programmer&rsquo;s hand has a mind of its own, and avoids sending the mouse pointer in bad areas of the screen, whereas that is precisely where the user&rsquo;s hand is guaranteed to send it. It is as if the programmer&rsquo;s finger will never press that mouse button down as heavily as the user&rsquo;s finger will. Even dedicated testers start behaving like the programmers after a while on the job, because it is only human to employ acquired knowledge about the environment in navigating about the environment, and to re-use established known good paths. It is in our nature. You can ask people to do something which is against their nature, and they may earnestly agree, and they may even try their best, but the results are still guaranteed to suffer.</p>
<p>Then there is repetitive motion fatigue, both of the physical and the mental kind, that severely limit the scope that any kind of manual testing will ever have.</p>
<p>Finally, there is the issue of efficiency. When we do manual software testing, we are necessarily doing it in human time, which is excruciatingly slow compared to the speed at which a computer would carry out the same task. A human being testing permutations at the rate of one click per second could theoretically test one million permutations in no less than 2 working months, the computer may do it in a matter of minutes. And the computer will do this perfectly, while the most capable human being will do this quite sloppily in comparison. That&rsquo;s how inefficient manual software testing is.</p>
<h3 id="myth-6-manual-testing-takes-less-time-than-writing-tests">Myth #6: Manual testing takes less time than writing tests.
</h3><p>No it doesn&rsquo;t. If you want to say that you are actually doing some manual testing worth speaking of, and not a joke of it, then you will have to spend copious amounts of time doing nothing but that, and you will have to keep repeating it all over again every single time the software is modified.</p>
<p>In contrast, with software testing you are spending some time up-front building some test suites, which you will then be able to re-execute every time you need them, with comparatively small additional effort.  So, manual testing for a certain piece of software is an effort that you have to keep repeating, while writing automated test suites for that same piece of software is something that you do once and from that moment on it keeps paying dividends.</p>
<p>This is why it is a fallacy to say that we will just test the software manually and with the time that we will save we will implement more functionality: as soon as you add a tiny bit of new functionality, you have to repeat the testing all over again.  Testing the software manually is a never ending story.</p>
<p>The situation is a lot like renting vs. buying: with renting, at the end of each month you are at exactly the same situation as you were in the beginning of the month: the home still belongs in its entirety <strong>not</strong> to you, but to the landlord, and you must now pay a new rent in full, in order to stay for one more month. With buying, you pay a lot of money up front, and some maintenance costs and taxes will always be applicable, but the money that you pay goes into something tangible, it is turned into value in your hands in the form of a home that you now own.</p>
<p>Furthermore, the relative efficiency of manual testing is usually severely underestimated. In order to do proper manual testing, you have to come up with a meticulous test plan, explaining what the tester is supposed to do, and what the result of each action should be, so that the tester can tell whether the software is behaving according to the requirements or not.  However, no test plan will ever be as unambiguous as a piece of code that is actually performing the same test, and the more meticulous you try to be with the test plan, the less you gain, because there comes a point where the effort of writing the test plan starts being comparable to the effort of writing the corresponding automated test instead. So, you might as well write the test plan down in code to begin with.</p>
<p>Of course one round of writing automated software testing suites will always represent more effort than a few rounds of manually performing the same tests, so the desirability of one approach vs. the other may depend on where you imagine the break-even point to be. If you reckon that the break-even point is fairly soon, then you already see the benefit of implementing automated software testing as soon as possible. If you imagine it will be after the IPO, then you might think it is better to defer it, but actually, even in this case you might not want to go this way, more about that later.</p>
<p>Well, let me tell you: in the software industry the established understanding is that the break-even point is <strong>extremely</strong> soon.  Like <strong>write-the-tests-before-the-app</strong> soon.  (A practice known as Test-Driven Development.)</p>
<h3 id="myth-7-you-can-keep-developing-new-functionality-and-fixing-existing-issues-without-software-testing-in-place">Myth #7: You can keep developing new functionality and fixing existing issues without software testing in place.
</h3><p>In theory you could, but in practice you can&rsquo;t. That&rsquo;s because every time you touch the slightest part of the software, everything about the software is now potentially broken. Without automated software testing in place, you just don&rsquo;t know. This is especially true of software which has been written messily, which is in turn especially common in software which has been written without any Automated Software Testing in place from the beginning.  Paradoxically enough, automated software testing forces software designs to have some structure, this structure reduces failures, so then the software has lesser testing needs.</p>
<p>To help lessen change-induced software fragility, we even have a special procedure governing how we fix bugs: when a bug is discovered, we do not always just go ahead and fix it. Instead, what we often do is that we first write a test which checks for the bug according to the requirements, without making any assumptions as to what might be causing it. Of course, since the bug is in the software, the test will initially be observed to fail. Then, we fix the bug according to your theory as to what is causing it, and we should see that test succeeding. If it doesn?t, then we fixed the wrong bug, or more likely, we just broke something which used to be fine. Furthermore, all other tests better also keep succeeding, otherwise in fixing this bug we broke something else. As a bonus, the new test now becomes a permanent part of the suite of tests, so if this particular behavior is broken again in the future, this test will catch it.</p>
<p>If you go around &ldquo;fixing bugs&rdquo; without testing mechanisms such as this in place, you are not really fixing bugs, you are just shuffling bugs around. The same applies to features: if you go around &ldquo;adding features&rdquo; without the necessary testing mechanisms in place, then by definition you are not adding features, you are adding bugs.</p>
<h3 id="myth-8-software-testing-has-no-business-value">Myth #8: Software testing has no business value
</h3><p>Yes it does. The arguments that I have already listed should be making it clear that it does, but let me provide one more argument, which shows how Automated Software Testing directly equates to business value.</p>
<p>A potentially important factor for virtually any kind of business is investment. When an investor is interested in a software business, and if they have the slightest clue as to what it is that they are doing, they are likely to want to evaluate the source code before committing to the investment. Evaluation is done by sending a copy of the software project to an independent professional software evaluator. The evaluator examines the software and responds with investment advice.</p>
<p>The evaluator may begin by using the software as a regular user to ensure that it appears to do what it is purported to do, then they may examine the design to make sure it makes sense, then they may examine the source code to make sure things look normal, etc. After spending not too much time on these tasks, the evaluator is likely to proceed to the tests. Software testing is so prevalent in the software industry, that it is unanimously considered to be the single most important factor determining the quality of the software.</p>
<p>If there are no tests, this is very bad news for the investment advice.</p>
<p>If the tests do not pass, this is also very bad news.</p>
<p>If the tests succeed, then the next question is how thorough they are.</p>
<p>For that, the evaluator is likely to use a tool called &ldquo;Code Coverage Analyzer&rdquo;. This tool keeps track of the lines of code that are being executed as the program is running, or, more likely, as the program is being exercised by the tests. By running the tests while the code coverage analysis tool is active, the evaluator will thus obtain the code coverage metric of the software. This is just a single number, from 0 to 100, and it is the percentage of the total number of source code lines that have been exercised by the tests. The more thorough the tests are, the higher this number will be.</p>
<p>This is a very useful metric, because in a single number it captures an objective, highly important quality metric for the entirety of the software system. It also tends to highly correlate to the actual investment advice that the evaluator will end up giving. The exact numbers may vary depending on the product, the evaluator, the investor, the investment, and other circumstances, but a rough breakdown is as follows:</p>
<ul>
<li>below 50% means &ldquo;run in the opposite direction, this is as good as Ebola.&rdquo;</li>
<li>50-60% means &ldquo;poor&rdquo;,</li>
<li>60-70% means &ldquo;decent&rdquo;,</li>
<li>70-80% means &ldquo;good&rdquo;,</li>
<li>80-90% means &ldquo;excellent&rdquo;,</li>
<li>90-100% means &ldquo;exceptional&rdquo;.</li>
</ul>
<p>Of course, the graph of programming effort required vs. code coverage achieved is highly non-linear. It is relatively easy to pass the 45% mark; it becomes more and more difficult as you go past the 65% mark; it becomes exceedingly difficult once you cross the 85% mark.</p>
<p>In my experience and understanding, conscientious software houses in the general commercial software business are striving for the 75% mark. In places where they only achieve about 65% code coverage they consider it acceptable but at the same time they either know that they could be doing better, or they have low self-respect. High criticality software (that human life depends on, or a nation&rsquo;s reputation,) may have 100% coverage, but a tremendous effort is required to achieve this.  In any case, what matters is not so much what the developers think, but what the evaluator thinks; and evaluators tend to use the established practices of the industry as the standard by which they judge.  The established practices call for extensive software testing, so if you do not do that, then your evaluation is not going to look good.</p>
<p>So, is there business value in software testing? investment prospects alone say yes, regardless of the technical merits of it. Furthermore, software evaluation may likely be part of the necessary preparations for an IPO to take place, so even if you imagined the break-even point of automated testing vs. manual testing to be after the IPO, there is still ample reason to have them all in perfect working order well before the IPO.</p>
<p>The above is applicable for businesses that are exclusively into software development. I do not know to what degree parallelisms can be drawn with companies for which software is somewhat secondary, but I suspect it is to no small extent.</p>
<p><strong>Old comments</strong></p>
<ul>
<li>
<p>metamaker 2020-11-14 23:03:33 UTC</p>
<p>| &hellip; in a single number it captures an objective, highly important quality metric for the entirety of the software system.</p>
<p>I wished to find in an article more about spec tests (BDD, Gherkin). Code lines coverage is not always applicable, and even in the case of unit tests where it is applicable, branch+predicate coverage is as relevant as ever.</p>
<p>So, devs end up with a need to convert use cases to autotests. I had a great Product Owner (C++ dev in past), who was writing Gherkin scripts inside Jira tickets xD, and team needed to just connect actions to words - then voila! we have autotests for use cases that a user encounters.</p>
<p>The excuse - it is difficult to setup runner for specs. The solution - fire knaves, hire pros! :D</p>
<p>| Software testing has no business value</p>
<p>This is THE PLAGUE of modern software engineering - business decides how programmers should do their work. Moreover there is the BELIEF that writing bug-free code is easy. In the end of the day, software rot trumps all business decisions and team ends up with polluted unsupportable code. This is the one single reason why now I don&rsquo;t even consider job offers to random teams that have already 2-3 years old software - just too high risk to end up with already non-fixable $hitcode (was there, seen undocumented SQL scripts with 5000 LOC and zero documentation - never again).</p>
<p>I wish everyone to end up sooner or later in a team with good practices and low stress! Stay good!</p>
</li>
<li>
<p>metamaker 2020-11-14 23:03:27 UTC</p>
<p>Yo Mike! Big kudos for the great article!</p>
<p>(I am sure you know all that I want to mention in the next paragraphs, I just need to vent my thoughts and feelings after reading; hope it is thought-provoking, because thinking === GREATER GOOD)</p>
<p>| &hellip; so it ends up saving huge amounts of money.</p>
<p>This is the good reason, but not the BEST (which I will mention below). Be like my old team when one day PM told that single calling code equals single country (+1 CC?), and someone wrote a component relying on this &ldquo;well-known fact&rdquo;. After half year we randomly found why some phone numbers were messed up. Ironically, the harm that was done to our company - zero bucks, we haven&rsquo;t lost anything due to this bug. We were b2b company that signed up other companies on board and thus really cared about having more sales and signed contracts rather than a good product.</p>
<p>Tests are useless waste of time for company that is sales driven. Am I right? Or not so?</p>
<p>The BEST thing for writing tests is that it documents expectations on code level (not biz, but for us, devs). If you ever need to fix something done by some random dude who now moved to Arctica, test is a good guidance (ofc, if that person wrote a good test and not some mocked up from top to bottom monster).</p>
<p>A quick thought about code reviews. There is the BELIEF that reviews prevent bad code (poorly written tests including). In fact, I have never seen in my career teams where code reviews were helpful (but I was in a great team without no code reviews and permit to fix random places during the development - we trusted each other and cared about well being). If you have a good tech lead, but unsure about the rest of the team, for the God&rsquo;s sake, let tech lead be the only person who reviews code. By not doing so, if there is less than 51% of team are competent developers, you end up with political circus (been there, seen it, friends get LGTM for $hitcode, foes get comments like &ldquo;change space, change quote, move comment to next line&rdquo;; so&hellip; you end up making situational friends ;) - needless to say, what happens to code base).</p>
<p>| &hellip; every time you touch the slightest part of the software, everything about the software is now potentially broken.</p>
<p>Not mentioning that since you are not a solo developer, you end up with merge conflicts due to other people work (even logical, e.g. Country class starts using 2-letter codes instead of 3-letter and uses same old good String for input of constructor - well, hope that your buddy added invariant to the class constructor). Tests synchronize decision making process, they autofix logical bugs between you and buddy.</p>
</li>
</ul>
</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/testing/">Testing</a>
        
            <a href="/tags/software-engineering/">Software-Engineering</a>
        
            <a href="/tags/papers/">Papers</a>
        
    </section>


    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            Last updated on 2025-10-13 Mon 22:24:24 CEST
        </span>
    </section></footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">Related content</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/p/testana-a-better-way-of-running-tests/">
        
        

        <div class="article-details">
            <h2 class="article-title">Testana: A better way of running tests</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/artificial-code-coverage/">
        
        

        <div class="article-details">
            <h2 class="article-title">Artificial Code Coverage</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/audit-testing/">
        
        

        <div class="article-details">
            <h2 class="article-title">Audit Testing</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/if-you-are-using-mock-objects-you-are-doing-it-wrong/">
        
        

        <div class="article-details">
            <h2 class="article-title">If you are using mock objects you are doing it wrong</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/incremental-integration-testing/">
        
        

        <div class="article-details">
            <h2 class="article-title">Incremental Integration Testing</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 2001 - 2025 Michael Belivanakis (a.k.a. Mike Nakis)
    </section>
    
    <section class="powerby">
        Made using <b><a href="https://obsidian.md" target="_blank">Obsidian</a></b> and <b><a href="https://gohugo.io/" target="_blank">Hugo</a></b><br />
        Theme based on <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" data-version="%s">hugo-theme-stack</a></b> by <a href="https://jimmycai.com" target="_blank">Jimmy Cai</a><br />
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.f2c01864f0b68886d640021e561a9182ddc2c60846b5b64ea7a6069cbe8a17ed.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
