<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Michael's Blog</title><link>https://blog.michael.gr/tags/java/</link><description>Recent content in Java on Michael's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Michael Belivanakis (a.k.a. Mike Nakis)</copyright><lastBuildDate>Fri, 27 Feb 2026 13:41:25 +0100</lastBuildDate><atom:link href="https://blog.michael.gr/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Immutability Assessment</title><link>https://blog.michael.gr/post/2025-06-immutability-assessment/</link><pubDate>Mon, 02 Jun 2025 13:16:41 +0000</pubDate><guid>https://blog.michael.gr/post/2025-06-immutability-assessment/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2025-06-immutability-assessment/media/diamond.svg"
loading="lazy"
&gt;
&lt;/p&gt;
&lt;h2 id="abstract"&gt;Abstract
&lt;/h2&gt;&lt;p&gt;The need is identified for programmatically ascertaining, in languages like C# and Java, the immutability of certain objects used in situations where they are expected to be immutable. The technicalities of immutability assessment are discussed. A mechanism is described for achieving it.&lt;/p&gt;
&lt;p&gt;(Useful pre-reading: &lt;a
href="https://blog.michael.gr/post/2022-11-about-these-papers/"
&gt;About these papers&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id="the-problem"&gt;The Problem
&lt;/h2&gt;&lt;p&gt;Raise your hand if you have ever had to troubleshoot a bug that manifested itself in mysterious ways, defied rational explanation, tenaciously evaded detection, made you rage at the absurdity of the observed behavior, and after much weeping and wailing and gnashing of teeth, turned out to be due to one of the following reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Inadvertently mutating an object that is being used as a key in a hash map.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Inadvertently mutating an object that has been passed to another thread.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;in general:&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;One piece of code mutating an object that another piece of code groundlessly assumes that it remains unchanged.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These mishaps of course happen due to the fact that the objects involved should have been immutable, but they were not. If an object is immutable, nobody can mutate it, and therefore nobody has to &lt;em&gt;assume&lt;/em&gt; that it will not change.&lt;/p&gt;
&lt;p&gt;So, could hash maps somehow require that their keys be immutable? Could threads somehow require that objects shared among them be immutable?&lt;/p&gt;
&lt;p&gt;This leads us to the more general question of how to ascertain immutability, which is certainly not an easy task. Most programmers don't even consider it; few talk about it; even fewer attempt it. Programmers all over the world are accustomed to routinely using objects in situations where immutability is an absolute requirement, but without ever ascertaining it, essentially &lt;em&gt;praying&lt;/em&gt; that the objects be immutable.&lt;/p&gt;
&lt;h2 id="compiler-enforced-immutability"&gt;Compiler-Enforced Immutability
&lt;/h2&gt;&lt;p&gt;Inadvertent mutation is not a problem in purely functional programming languages, where there simply is no such thing as mutation. However, most programmers do not use such languages, because they are cumbersome to work with. Most programmers use languages like Java and C#, which are not purely functional, so they allow mutation, and so inadvertent mutation can sometimes happen.&lt;/p&gt;
&lt;p&gt;Java and C# do support a few constructs for defining invariable (final/readonly) class members, but they are woefully inadequate. Systematic compiler support for declaring and requiring immutability would greatly help to reduce the volume of mistakes being made, but nothing like that exists, and even if it did exist, it would not be a panacea, because there are situations where the compiler cannot help.&lt;/p&gt;
&lt;p&gt;Since compiler-enforced immutability is not available, we have to enforce it ourselves, which means that we have to programmatically detect immutability and ascertain it.&lt;/p&gt;
&lt;p&gt;Languages like Java and C# offer full reflection support, so we can examine every field of every type, (static analysis,) and we can even examine the values of fields of instances. (Dynamic analysis.) Furthermore, these languages compile into intermediate code, which is relatively easy to parse and reason about, meaning that we can even analyze executable code if we want to. (More static analysis.)&lt;/p&gt;
&lt;p&gt;So, the question is what to analyze, and how.&lt;/p&gt;
&lt;h3 id="superficial-vs-deep-immutability"&gt;Superficial vs. Deep Immutability
&lt;/h3&gt;&lt;p&gt;Many classes have the term &amp;quot;immutable&amp;quot; in their name, but they are only superficially immutable. Take a generic immutable collection or example: &lt;code&gt;ImmutableCollection&amp;lt;T&amp;gt;&lt;/code&gt;. Let us trust that it does in fact behave perfectly immutably, and therefore it does, arguably, deserve to be called immutable; let us now ask: would an instance of this class be safe to pass to another thread? The answer is that it depends on the actual type of the generic parameter: If &lt;code&gt;T&lt;/code&gt; is immutable, it is safe; but if &lt;code&gt;T&lt;/code&gt; is mutable, then it is absolutely not safe.&lt;/p&gt;
&lt;p&gt;So, in order to reap any benefits whatsoever from immutability, it must be deep immutability. Shallow immutability is irrelevant. Please keep this in mind, as it has severe implications in our quest to ascertain the immutability of anything.&lt;/p&gt;
&lt;h3 id="static-analysis"&gt;Static Analysis
&lt;/h3&gt;&lt;p&gt;The term &amp;quot;static analysis&amp;quot; refers to examining the code that makes a program, (as written, or as compiled,) but not the state of the program as it runs. Consequently, static analysis can examine the definitions of data structures, but not the actual contents of those data structures during runtime.&lt;/p&gt;
&lt;p&gt;A popular but na√Øve understanding of immutability is that it is an inherent characteristic of types, and that the instances of the types (i.e. the objects) simply follow suit. According to this understanding, all we need to do is to ascertain that a certain type is immutable via static analysis, and from that moment on we know that all of its instances are immutable.&lt;/p&gt;
&lt;p&gt;This understanding is not entirely false, but it is very limiting, because it means that only concrete and non-extensible (a.k.a. final, sealed) types can potentially be assessed as immutable: All interfaces must necessarily be considered as mutable, because we have no idea how they may be implemented, and all abstract or simply extensible types must also necessarily be considered as mutable, because we have no idea how they may be extended.&lt;/p&gt;
&lt;p&gt;This poses an insurmountable problem if we wanted to have, say, a queue for exchanging messages between threads, where the messages are organized in a class hierarchy: such a queue would not be able to ascertain the immutability of the messages it handles, because all it knows is the base-most 'Message' class, which is necessarily extensible, and therefore mutable, as far as static analysis can tell.&lt;/p&gt;
&lt;p&gt;Now, consider that many perfectly immutable classes tend to be passed around as interfaces, (e.g. &lt;code&gt;Comparer&lt;/code&gt;, &lt;code&gt;Hasher&lt;/code&gt;, &lt;code&gt;Predicate&lt;/code&gt;, all sorts of stateless converters, etc.) that these interfaces are often stored in fields, and that a field of mutable type makes the class containing that field also mutable. It quickly becomes evident that static analysis can only work in a universe where no abstraction is utilized; however, we do not live in such a universe: we make use of languages like Java and C# precisely because we want the benefits of &lt;em&gt;unlimited&lt;/em&gt; abstraction.&lt;/p&gt;
&lt;p&gt;One final nail in the coffin of static analysis is the issue of delayed immutability.&lt;/p&gt;
&lt;h3 id="delayed-immutability"&gt;Delayed Immutability
&lt;/h3&gt;&lt;p&gt;Some objects begin life as mutable, so that they can undergo some non-trivial initialization, and become immutable later, once initialization is complete. This behavior is necessary when creating cyclic graphs of immutable objects, or when creating an immutable object while deserializing it, in other words loading its contents from some storage. Alternative terms used by others for this kind of immutability are &lt;em&gt;Freezing&lt;/em&gt; and &lt;em&gt;Popsicle immutability&lt;/em&gt;, but I prefer the term &lt;em&gt;Delayed immutability&lt;/em&gt; because it is more straightforward and self-explanatory.&lt;/p&gt;
&lt;p&gt;There is no standard way of representing delayed immutability, so let me propose one real quick:&lt;/p&gt;
&lt;p&gt;Let there be a &lt;code&gt;SelfAssessing&lt;/code&gt; interface, which is to be implemented by any class that utilizes delayed immutability. This interface is to have just one method, &lt;code&gt;IsImmutable()&lt;/code&gt;, which is expected to return &lt;code&gt;false&lt;/code&gt; for as long as the object is mutable, and to start returning &lt;code&gt;true&lt;/code&gt; once the object becomes immutable.&lt;/p&gt;
&lt;p&gt;Note that static analysis is by nature limited to examining types, but delayed immutability requires invoking a method of an instance of a type. Thus, static analysis completely fails to assess delayed immutability. Furthermore, a delayed immutable may appear as a field in any type, meaning that static analysis fails to assess potentially any type.&lt;/p&gt;
&lt;p&gt;Since static analysis fails in the presence of abstraction and/or delayed immutability, it follows that we have to examine not just types, but also the instances of types in the running software system. This calls for &lt;em&gt;dynamic analysis&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="dynamic-analysis"&gt;Dynamic Analysis
&lt;/h3&gt;&lt;p&gt;The term &amp;quot;dynamic analysis&amp;quot; refers to examining various aspects of a software system as it runs. In some cases the aim is to examine the behavior of the software, in other cases (such as the case at hand) it is to examine the data structures it creates. Dynamic analysis may require (and in the case at hand it does in fact require) static analysis as a prerequisite.&lt;/p&gt;
&lt;p&gt;With dynamic analysis we can look past the advertised type of a field, which may be abstract, and obtain the instance stored in the field, (the value of the field,) in order to find out the actual, concrete type of that instance.&lt;/p&gt;
&lt;p&gt;Once we have the concrete type of an instance, we can assess whether it is immutable, and this may involve recursively assessing any instances referenced by that instance. If everything is immutable, then and only then can the containing instance assessed as immutable.&lt;/p&gt;
&lt;p&gt;To make all of this work, we begin with static analysis where we use reflection to examine a type with the goal of giving it one of &lt;em&gt;three&lt;/em&gt; possible assessments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mutable&lt;/li&gt;
&lt;li&gt;Immutable&lt;/li&gt;
&lt;li&gt;Inconclusive&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These type assessments are issued as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;mutable&lt;/strong&gt; type assessment is issued if the type has any fields that are variable, or has nothing but invariable fields, but one or more of them is of an advertised type that has received a mutable assessment.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;immutable&lt;/strong&gt; type assessment is issued if a type consists exclusively of fields that are both invariable and of an advertised type which has received an immutable assessment.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;inconclusive&lt;/strong&gt; type assessment is issued if the type is abstract or extensible, (non-final/non-sealed,) self-assessing, or contains only fields of advertised types that have received either immutable or inconclusive assessments.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that the above are &lt;em&gt;type&lt;/em&gt; assessments, issued on types, by static analysis alone.&lt;/p&gt;
&lt;p&gt;Every instance of a type that has received a mutable or immutable assessment is in turn mutable or immutable without the need to examine the contents of the instance; however, every instance of a type that has received an inconclusive assessment must be further examined to issue a final assessment for that instance only.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The value of each field must be obtained from the instance, and assessment must recursively be applied on that value.&lt;/li&gt;
&lt;li&gt;If the type is self-assessing, then the &lt;code&gt;IsImmutable()&lt;/code&gt; method must be invoked on the instance, to ask it whether it is immutable or not.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both type assessment and instance assessment can be expensive; however, note the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Once a type assessment has been issued, it will never change, so it can be cached, and never recomputed again.&lt;/li&gt;
&lt;li&gt;Instance assessments can be requested only from within assertions, meaning that they can incur zero runtime overhead on production.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note that for static analysis we employed nothing but reflection to examine the fields of a type, and for dynamic analysis we also employed nothing but reflection to examine the values of fields of instances, so no code analysis was necessary. However, for the sake of completeness, let us also take a brief look at code analysis.&lt;/p&gt;
&lt;h3 id="code-analysis"&gt;Code analysis
&lt;/h3&gt;&lt;p&gt;There is a school of thought according to which the answer to the immutability assessment question lies in analyzing the executable instructions that comprise a type to determine whether any fields are mutated by code outside of the constructor.&lt;/p&gt;
&lt;p&gt;The problem with code analysis is that it is a form of static analysis, so it suffers from the disadvantages of static analysis that were previously explained:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Suppose that code analysis determines that a type does not mutate any fields outside of its constructor; suppose, however, that the type contains a field of abstract type, which gets initialized from a constructor parameter; is this type mutable or immutable?&lt;/li&gt;
&lt;li&gt;Obviously, it depends on the concrete type of the instance that will be stored, at runtime, in that field, which is something that static analysis cannot determine.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, we are back at square one, where static analysis simply does not work in the face of abstraction. Therefore, code analysis is not the answer.&lt;/p&gt;
&lt;p&gt;Code analysis could potentially be useful, as a supplement to dynamic analysis, in the following ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In some cases, a type contains a field which is written by a method other than the constructor. For this to work, the field has to be variable. (Non-final/non-readonly.) Thus, with the use of reflection alone, this type will be assessed as mutable. However, it may be that the method which writes the field makes sure that the field is only written once during the lifetime of the instance, and that it gets written before it is ever read, so it will never appear to mutate as far as external observers can tell. Thus, the type is effectively immutable. It is in theory possible (though not easy) for code analysis to detect that the field is treated in this way, thus allowing the type to be assessed as immutable.&lt;/li&gt;
&lt;li&gt;Sometimes a type contains fields that are only written by the constructor, but the programmer who wrote that type forgot to declare them as invariable (final/readonly) and did not pay attention to the warnings / inspections / analysis messages. If we were to only use reflection, these fields would be considered variable, so the type would in turn be assessed as mutable. Code analysis can detect that the fields are not written outside of the constructor, allowing them to be assessed as invariable, and therefore the type to be assessed as immutable.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="preassessment"&gt;Preassessment
&lt;/h3&gt;&lt;p&gt;There exist types that would normally receive a mutable assessment, but we know for sure that they are practically immutable. A famous example of such a type, both in Java and in C#, is class &lt;code&gt;String&lt;/code&gt;. In such cases, we must be able to &lt;em&gt;preassess&lt;/em&gt; the type as immutable, which means to assign an immutable assessment to the type, without analyzing it.&lt;/p&gt;
&lt;p&gt;Note that preassessment constitutes a promise, and promises can be false. If a type which is actually mutable is mistakenly preassessed as immutable, bad things are bound to happen.&lt;/p&gt;
&lt;h2 id="generic-shallow-preassessment"&gt;Generic Shallow Preassessment
&lt;/h2&gt;&lt;p&gt;Some generic types are effectively immutable containers. In Java, which uses type erasure, these are essentially containers of elements of type &lt;code&gt;object&lt;/code&gt;, so they are by definition inconclusive; however, in C# the type of the generic type argument is known at runtime, so we do better than that. When a generic effectively immutable container type is constructed with an actual type parameter, the immutability of the resulting type depends on the immutability of that parameter:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the generic type parameter is a mutable type, then the constructed generic container type is mutable, so instances of that type do not need to be assessed.&lt;/li&gt;
&lt;li&gt;If the generic type parameter is an immutable type, then the constructed generic container type is immutable, so again, instances of that type do not need to be assessed.&lt;/li&gt;
&lt;li&gt;If the generic type parameter is inconclusive, then the constructed generic container type is inconclusive, which means that for every instance of that type, all elements in the container must be assessed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In order to be able to assess the elements of a container, the preassessment for the container must include an object known as a &lt;em&gt;deconstructor&lt;/em&gt;. Dynamic analysis will be invoking the deconstructor to enumerate the elements contained within each instance of the container, so that each element can be assessed. Deconstructors are generally trivial:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The deconstructor for collections simply yields all the elements of the collection.&lt;/li&gt;
&lt;li&gt;The deconstructor for maps/dictionaries simply yields all the mappings. (Map entries / key-value pairs.)&lt;/li&gt;
&lt;li&gt;The deconstructor for &lt;code&gt;Lazy&amp;lt;T&amp;gt;&lt;/code&gt; simply yields the one and only value contained within the lazy object.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Preassessment is mainly intended for types that have been defined by others, and thus we cannot modify their source code. For types that we write ourselves, we want a finer level of control: we want to be able to override the assessment of specific fields only, and allow all other fields to be assessed the normal way, to catch situations where we thought that some field was immutable, while in fact assessment of that field shows that it is not immutable. For that, we need &lt;em&gt;field overrides&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="field-overrides"&gt;Field Overrides
&lt;/h3&gt;&lt;p&gt;Sometimes a field is variable, but we want to promise that we will only vary it in an effectively immutable way. For such cases, there must be an annotation/attribute that we can attach to that field, to indicate that analysis should treat the field as invariable.&lt;/p&gt;
&lt;h3 id="array-field-overrides"&gt;Array Field Overrides
&lt;/h3&gt;&lt;p&gt;Arrays are by definition mutable in Java and C#, and by extension so is any type that contains an array field, even if the field itself is invariable. If we want to be able to create an immutable type that contains an array field, there must be an annotation/attribute that we can attach to that array field, to indicate that analysis should treat the array itself as invariable.&lt;/p&gt;
&lt;h3 id="elucidation"&gt;Elucidation
&lt;/h3&gt;&lt;p&gt;Once we have immutability assessment working as described in the preceding sections, a new challenge becomes apparent: sometimes, a data structure that was intended to be immutable will be assessed as mutable due to some tiny programmer mistake. If the data structure is large and complex, it might not be obvious where the mistake is. The programmer will receive a mutable assessment, but will not know why it was given and where to look to find the problem.&lt;/p&gt;
&lt;p&gt;For this reason, every mutable instance assessment must come with a sentence explaining to the programmer why the assessment was issued. Since every mutable instance assessment typically has one or more other assessments that are the reasons that led to it, these sentences will often form entire trees, each sentence being further explained by nested sentences.&lt;/p&gt;
&lt;p&gt;I call this feature elucidation.&lt;/p&gt;
&lt;h3 id="an-implementation"&gt;An Implementation
&lt;/h3&gt;&lt;p&gt;I have already created a library for Java that achieves all of the above; I call it Bathyscaphe. You can find out about it &lt;a
href="https://blog.michael.gr/post/2022-05-bathyscaphe/"
&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I have also ported this library to C#, and all of its (quite extensive) tests pass, so I have sufficient reason to believe that it is working correctly; however, I have yet to try it in any real projects, so I cannot confidently proclaim it to be of release grade at the moment. I am planning to release it as soon as I can.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="further-reading"&gt;Further reading
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Eric Lippert's must-read series of posts about immutability: &lt;a class="external"
href="https://ericlippert.com/2007/11/13/immutability-in-c-part-one-kinds-of-immutability/" target="_blank"
&gt;Immutability in C# Part One: Kinds of Immutability&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="appendix"&gt;Appendix
&lt;/h2&gt;&lt;p&gt;Immutability assessment is awesome, but the more the compiler can do for us, the better.&lt;/p&gt;
&lt;p&gt;Here are some examples of what compilers of (non-purely functional) programming languages could be doing for us in the direction of compiler-enforced immutability:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A language could support an 'immutable' class modifier, which would require the class to contain only immutable members. An immutable class may not extend a mutable class, and a mutable class may not extend an immutable class. (Although a mutable class may extend a class which has not been marked as immutable, even if that class happens to be immutable.)&lt;/li&gt;
&lt;li&gt;A language could support an 'immutable' modifier for function arguments and for fields, requiring that they may only be assigned from concrete types that are immutable, or from other fields or function arguments that are also immutable.&lt;/li&gt;
&lt;li&gt;A language could support an 'immutable' generic parameter constraint, which would mandate that only immutable types can be used as generic type arguments.&lt;/li&gt;
&lt;li&gt;A language could support a 'stable' field modifier, allowing a mutable field to appear in an immutable class, and acting as a promise that the field will only be mutated in a way which upholds effective immutability.&lt;/li&gt;
&lt;li&gt;A language could support a 'stable array' field modifier for array fields, allowing an array to appear in an immutable class, and acting as a promise that the contents of the array will either not be mutated, or they will only be mutated in a way which upholds effective immutability.&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Cover image from &lt;a class="external"
href="https://thenounproject.com/icon/diamond-4452869/" target="_blank"
&gt;Oleksandr Panasovskyi from The Noun Project&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Scratch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(Ignore)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As it turns out, the mutability of value types is largely irrelevant, as explained here:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="external"
href="http://mustoverride.com/tuples%5C_structs/" target="_blank"
&gt;Vladimir Sadov: &amp;quot;C# Tuples. Why mutable structs?&amp;quot;&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Testana: A better way of running tests</title><link>https://blog.michael.gr/post/2024-10-testana/</link><pubDate>Sat, 26 Oct 2024 10:58:59 +0000</pubDate><guid>https://blog.michael.gr/post/2024-10-testana/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2024-10-testana/media/testana-logo.svg"
loading="lazy"
&gt;
&lt;/p&gt;
&lt;h3 id="abstract"&gt;Abstract
&lt;/h3&gt;&lt;p&gt;A software testing tool is presented, which uses &lt;em&gt;&lt;strong&gt;dependency analysis&lt;/strong&gt;&lt;/em&gt; to greatly optimize the process of running tests.&lt;/p&gt;
&lt;p&gt;(Useful pre-reading: &lt;a
href="https://blog.michael.gr/post/2022-11-about-these-papers/"
&gt;About these papers&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id="what-is-testana"&gt;What is Testana?
&lt;/h3&gt;&lt;p&gt;Testana is a console application that you launch when you want to run your tests. So far, I have created two implementations of Testana:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A Java implementation, supporting JUnit 4 annotations in Maven-based projects.&lt;/li&gt;
&lt;li&gt;A C# implementation, supporting MSTest attributes in MSBuild solutions.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="what-does-testana-achieve-that-existing-tools-do-not"&gt;What does Testana achieve that existing tools do not?
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Testana &lt;em&gt;&lt;strong&gt;runs only the subset of test modules that actually need to run&lt;/strong&gt;&lt;/em&gt;, based on the last successful run time of each test module, and whether it, or any of its dependencies, have changed.&lt;/li&gt;
&lt;li&gt;Testana &lt;em&gt;&lt;strong&gt;always considers all test modules in your entire code base as candidates for running&lt;/strong&gt;&lt;/em&gt;, so you never have to manually select a subset of the tests to run in the interest of saving time.&lt;/li&gt;
&lt;li&gt;Testana &lt;em&gt;&lt;strong&gt;runs test modules by order of dependency&lt;/strong&gt;&lt;/em&gt;, meaning that tests of modules that have no dependencies run first, tests of modules that depend on those run next, and so on.&lt;/li&gt;
&lt;li&gt;Testana &lt;em&gt;&lt;strong&gt;runs test methods in Natural Method Order,&lt;/strong&gt;&lt;/em&gt; which is the order in which the methods appear in the source file. (This is the norm in C#, but not in Java, where extra measures are necessary to accomplish.)&lt;/li&gt;
&lt;li&gt;Testana &lt;em&gt;&lt;strong&gt;runs test methods in ascending order of inheritance&lt;/strong&gt;&lt;/em&gt;, meaning that test methods in the base-most test class run first, and test methods in derived test classes run afterwards.&lt;/li&gt;
&lt;li&gt;Testana &lt;em&gt;&lt;strong&gt;discovers and reports mistakes&lt;/strong&gt;&lt;/em&gt; in the formulation of test methods, instead of ignoring the mistakes, which is what most other test frameworks do. (Silent failure.)&lt;/li&gt;
&lt;li&gt;Testana &lt;em&gt;&lt;strong&gt;does not catch any exceptions when debugging&lt;/strong&gt;&lt;/em&gt;, thus allowing your debugger to stop on the source line that threw the exception. (Testana will catch and report exceptions when not debugging, as the case is when running on a continuous build server.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="how-does-testana-work"&gt;How does Testana work?
&lt;/h3&gt;&lt;p&gt;Testana begins by constructing the dependency graph of your software system. Since this process is expensive, Testana cashes the dependency graph in a file, and recalculates it only when the structure of the system changes. The cache is stored in a text file, which is located at the root of the source tree, and is meant to be excluded from source control.&lt;/p&gt;
&lt;p&gt;Then:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Testana locates the modules that depend on nothing else within the system, and runs the tests of those modules.&lt;/li&gt;
&lt;li&gt;Once these tests are done, Testana finds modules that depend only on modules that have already been tested, and runs their tests.&lt;/li&gt;
&lt;li&gt;Testana keeps repeating the previous step, until all tests have been run.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Testana keeps a diary where it records the last successful run time of each test module. This diary is also stored in a text file, which is also located
at the root of the source tree, and is also meant to be excluded from source control.&lt;/p&gt;
&lt;p&gt;Next time Testana runs, it considers the last successful run time of each test module, versus the last modification time of that module and its dependencies. Testana then refrains from running the test module if neither it, nor any of its dependencies, have changed.&lt;/p&gt;
&lt;h3 id="why-should-i-care-about-running-only-the-tests-that-need-to-run"&gt;Why should I care about running only the tests that need to run?
&lt;/h3&gt;&lt;p&gt;The usual situation with large code bases is that tests take an unreasonably long time to run, so developers tend to take shortcuts in running them. One approach some developers take is that they simply commit code without running any tests, leaving it up to the continuous build server to run the tests and notify them of any test failures. This has multiple disadvantages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It causes repeated interruptions in the workflow, due to the slow turnaround of the continuous build, which is often of the order of an hour, sometimes longer, and even in the fastest cases, always longer than a normal person's attention span. (This is so by definition; if it was not, then there would be no problem with quickly running all tests locally before committing.)&lt;/li&gt;
&lt;li&gt;The failed tests require additional commits to fix, and each commit requires a meaningful commit message, which increases the overall level of bureaucracy in the development process.&lt;/li&gt;
&lt;li&gt;The commit history becomes bloated with commits that were done in vain and should never be checked out because they contain bugs that are fixed in later commits.&lt;/li&gt;
&lt;li&gt;Untested commits that contain bugs are regularly being made to branches in the repository; these bugs stay there while the continuous build does its thing; eventually the tests fail, the developers take notice, and commit fixes. This whole process takes time, during which other unsuspecting developers might pull from those branches, thus receiving the bugs. Kind of like &lt;em&gt;Continuous Infection&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Testana solves the above problems by figuring out which tests need to run based on what has changed, and only running those tests. This cuts down the time it takes to run tests to a tiny fraction of what it is when blindly running all tests, which means that running the tests now becomes piece of cake and can usually be done real quick before committing, as it should.&lt;/p&gt;
&lt;p&gt;Also, running the tests real quick right after each pull from source control now becomes feasible, so a developer can avoid starting to work on source code on which the tests are failing. (How often have you found yourself in a situation where you pull from source control, change something, run the tests, the tests fail, and you are now wondering whether they fail due to the changes you just made, or due to changes you pulled from the repository?)&lt;/p&gt;
&lt;h3 id="why-should-i-care-about-considering-all-test-modules-in-my-entire-code-base-as-candidates-for-running"&gt;Why should I care about considering all test modules in my entire code base as candidates for running?
&lt;/h3&gt;&lt;p&gt;Another approach taken by some developers, in the interest of saving time, is manually choosing which tests to run, based on their knowledge of what may have been affected by the changes they just made.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One simple reason why this is problematic is that it requires cognitive effort to figure out which tests might need running, and manual work to launch them individually; it is not as easy as pressing a single button that stands for &amp;quot;run whatever tests need to run in response to the changes I just made.&amp;quot;&lt;/li&gt;
&lt;li&gt;A far bigger problem is that in manually selecting the tests to run, the developer is making assumptions about the dependencies of the code that they have modified. In complex systems, dependency graphs can be difficult to grasp, and as systems evolve, the dependencies keep changing. This often leads to situations where no single developer in the house has a complete grasp of the dependency graph of the entire system. Unfortunately, unknown or not-fully-understood dependencies are a major source of bugs, and yet by hand-selecting what to test based on our assumptions about the dependencies, it is precisely the not-fully-understood dependencies that are likely to not be tested. This is a recipe for disaster.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Testana solves the above problems by always considering all test modules as candidates for running. It does not hurt to do that, because the tests that do not actually need to run will not be run by Testana anyway.&lt;/p&gt;
&lt;h3 id="why-should-i-care-about-running-test-modules-in-order-of-dependency"&gt;Why should I care about running test modules in order of dependency?
&lt;/h3&gt;&lt;p&gt;Existing test frameworks do not do anything intelligent in the direction of automatically figuring out some order of test execution that has any purpose or merit. The order tends to be arbitrary, and not configurable. In the best case it is alphabetic, but this is still problematic, because our criteria for naming test modules usually have nothing to do with the order in which we would like to see them executing.&lt;/p&gt;
&lt;p&gt;For example, it is very common for a code base to contain a module called &amp;quot;Utilities&amp;quot;, which most other modules depend on; Since it is a highly dependent-upon module, it should be tested first, but since its name begins with a &amp;quot;U&amp;quot;, it tends to be tested last.&lt;/p&gt;
&lt;p&gt;Testana executes test modules in order of dependency. This means that modules with no dependencies are tested first, modules that depend upon them are tested next, and so on until everything has been tested. Thus, the first test failure is guaranteed to point at the most fundamental problem; there is no need to look further down in case some other test failure indicates a more fundamental problem. Subsequently, Testana stops executing tests after the first failure, so it saves even more time.&lt;/p&gt;
&lt;p&gt;For more information about this way of testing, see &lt;a
href="https://blog.michael.gr/post/2022-10-incremental-integration-testing/"
&gt;Incremental Integration Testing&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="why-should-i-care-about-running-test-methods-in-natural-order"&gt;Why should I care about running test methods in natural order?
&lt;/h3&gt;&lt;p&gt;Test frameworks in the C# world tend to run test methods in natural order, which is great, but in the Java world, the JUnit framework runs test methods in random order, which is at best useless, and arguably treacherous.&lt;/p&gt;
&lt;p&gt;One reason for wanting the test methods to run in the order in which they appear in the source file is because we usually test fundamental operations of our software before we test operations that depend upon them. (Note: it is the operations of the components under test that depend upon each other, not the tests themselves that depend upon each other!) So, if a fundamental operation fails, we want that to be the very first error that gets reported.&lt;/p&gt;
&lt;p&gt;Tests of operations that rely upon an operation whose test has failed might as well be skipped, because they can all be expected to fail. Reporting those failures before the failure of the more fundamental operation is an act of sabotage against the developer, because it is sending us looking for problems in places where there are no problems to be found, and it is making it more difficult for us to locate the real problem, which typically lies in the test that failed first &lt;em&gt;&lt;strong&gt;in the source file&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To give an example, suppose I am developing some kind of data store with insert and find functionality, and I am writing tests to make sure this functionality works. The find-item-in-store test necessarily involves insertion before finding, so I am likely to precede it with an insert-item-to-store test. In such a scenario, it is counter-productive to be told that my find-item-in-store test failed, sending me to troubleshoot the find function, and only later to be told that my insert-item-to-store test failed, which obviously means that it was in fact the insert function that needed troubleshooting; if insert-item-to-store fails, it is game over; no other operation on this store can possibly succeed, so there is no point in running any other tests on it, just as there is no point in beating a dead horse.&lt;/p&gt;
&lt;p&gt;Finally, another very simple, very straightforward, and very important reason for wanting the test methods to be executed in natural order is because seeing the test methods listed in any other order is &lt;em&gt;&lt;strong&gt;brainfuck&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A related rant can be found here: &lt;a
href="https://blog.michael.gr/post/2018-04-random-order-of-tests/"
&gt;On JUnit's random order of test method execution&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="why-should-i-care-for-running-test-methods-in-ascending-order-of-inheritance"&gt;Why should I care for running test methods in ascending order of inheritance?
&lt;/h3&gt;&lt;p&gt;This feature of Testana might be irrelevant to you if you never use inheritance in test classes, but I do, and I consider it very important. I also consider the typical behavior of existing test frameworks on this matter very annoying, because they tend to do the exact opposite of what is useful.&lt;/p&gt;
&lt;p&gt;Inheritance in test classes can help to achieve great code coverage while reducing the total amount of test code. Suppose you have a collection hierarchy to test: you have an ArrayList class and a HashSet class, and you also have their corresponding test classes: ArrayListTest and HashSetTest. Now, both ArrayList and HashSet inherit from Collection, which means that lots of tests are going to be identical between ArrayListTest and HashSetTest. One way to eliminate duplication is to have a CollectionTest abstract base class, which tests only Collection methods, and then have both ArrayListTest and HashSetTest inherit from CollectionTest and provide additional tests for functionality that is specific to ArrayList and HashSet respectively. Under this scenario, when ArrayListTest or HashSetTest runs, we want the methods of CollectionTest to be executed first, because they are testing the fundamental (more general) functionality.&lt;/p&gt;
&lt;p&gt;To make the example more specific, CollectionTest is likely to add an item to the collection and then check whether the collection contains the item. If this test fails, there is absolutely no point in proceeding with tests of ArrayListTest which will, for example, add multiple items to the collection and check to make sure that IndexOf() returns the right results.&lt;/p&gt;
&lt;p&gt;Again, existing test frameworks tend to handle this in a way which is exactly the opposite of what we would want: they execute the descendant (more specialized) methods first, and the ancestor (more general) methods last.&lt;/p&gt;
&lt;p&gt;Testana corrects this by executing ancestor methods first, descendant methods last.&lt;/p&gt;
&lt;h3 id="what-additional-error-checking-does-testana-perform"&gt;What additional error checking does Testana perform?
&lt;/h3&gt;&lt;p&gt;While running tests, Testana will warn the programmer if it discovers any method that has been declared as a test method but fails to meet the requirements for a test method.&lt;/p&gt;
&lt;p&gt;Usually, test frameworks require that a test method must be a public instance method, must accept no parameters, and must return nothing; however, when these frameworks encounter a method that is declared as a test and yet fails to meet those requirements, (for example, a test method declared static,) they fail to report the mistake.&lt;/p&gt;
&lt;p&gt;Testana does not fail to report such mistakes.&lt;/p&gt;
&lt;h3 id="can-testana-be-fooled-by-inversion-of-control"&gt;Can Testana be fooled by Inversion of Control?
&lt;/h3&gt;&lt;p&gt;No. In a scenario where class A receives and invokes interface I without having a dependency on class B which implements I, the test of A still has to instantiate both A and B in order to supply A with the I interface of B, so the test depends on both A and B, which means that Testana will run the test if there is a change in either A or B.&lt;/p&gt;
&lt;h3 id="can-testana-be-fooled-by-the-use-of-mocks"&gt;Can Testana be fooled by the use of mocks?
&lt;/h3&gt;&lt;p&gt;Yes, Testana can be fooled by mocks, because that is what mocks do: they make a mockery out of the software testing process. In a scenario where class A receives and invokes interface I without having a dependency on class B which implements I, and the test of A also refrains from depending on B by just mocking I, Testana will of course not run the test of A when there is a change in B. This, however, should not be a problem, because you should not be using mocks anyway; for more information, see &lt;a
href="https://blog.michael.gr/post/2023-01-14-mocking/"
&gt;If you are using mock objects you are doing it wrong&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="can-testana-be-fooled-by-the-use-of-fakes"&gt;Can Testana be fooled by the use of fakes?
&lt;/h3&gt;&lt;p&gt;No, as long as you do your testing properly. A test that utilizes a fake will be run by Testana only when there is a change in the fake, not when there is a change in the real thing; however, you should have a separate test which ensures that the behavior of the fake is identical to the behavior of the real thing in all aspects that matter. This test will be run by Testana when you modify either the fake, or the real thing, or both. Thus:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you make a breaking change to the real thing, then your tests will show you that you need to make the corresponding change to the fake; the change in the fake will in turn cause Testana to run the tests that utilize the fake.&lt;/li&gt;
&lt;li&gt;If you make a non-breaking change to the real thing, then the fake will remain unchanged, and this is what gives you the luxury of not having to re-run tests utilizing the fake when you make a change that only affects the real thing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For more information, see &lt;a
href="https://blog.michael.gr/post/2022-10-testing-with-fakes/"
&gt;Testing with Fakes instead of Mocks&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="what-about-undiscoverable-dependencies-due-to-weak-typing-the-use-of-rest-etc"&gt;What about undiscoverable dependencies due to weak typing, the use of REST, etc?
&lt;/h3&gt;&lt;p&gt;The following &amp;quot;hip&amp;quot; and &amp;quot;trendy&amp;quot; practices of the modern day are not supported by Testana, and there is no plan to ever support them:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Squandering dependencies via &lt;em&gt;&lt;strong&gt;weak typing&lt;/strong&gt;&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Obscuring dependencies via &lt;em&gt;&lt;strong&gt;duck-typing&lt;/strong&gt;&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Denaturing dependencies via &lt;em&gt;&lt;strong&gt;stringly-typing.&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Disavowing dependencies via &lt;em&gt;&lt;strong&gt;configuration files&lt;/strong&gt;&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Abnegating dependencies via &lt;em&gt;&lt;strong&gt;non-programmatic interfaces&lt;/strong&gt;&lt;/em&gt; such as REST.&lt;/li&gt;
&lt;li&gt;Fragmenting dependencies via &lt;em&gt;&lt;strong&gt;cross-language invocations&lt;/strong&gt;&lt;/em&gt; (following the &lt;em&gt;&lt;strong&gt;polyglot craze&lt;/strong&gt;&lt;/em&gt;.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Seriously, stop all this fuckery and use a single, &lt;em&gt;&lt;strong&gt;real&lt;/strong&gt;&lt;/em&gt; programming language, (that is, a programming language with &lt;em&gt;&lt;strong&gt;strong typing&lt;/strong&gt;&lt;/em&gt;,) encode your dependencies via the type system, and everything will be fine. For more information, see &lt;a
href="https://blog.michael.gr/post/2017-05-on-scripting-languages/"
&gt;On Scripting Languages&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="how-compatible-is-testana-with-what-i-already-have"&gt;How compatible is Testana with what I already have?
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;The Java implementation of Testana:
&lt;ul&gt;
&lt;li&gt;Works with maven projects (pom.xml files.)&lt;/li&gt;
&lt;li&gt;Supports JUnit 4.
&lt;ul&gt;
&lt;li&gt;Supports only the basic, minimum viable subset of JUnit 4 functionality, namely the @Test, @Before, @After, and @Ignore annotations, without any parameters.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The C# implementation of Testana:
&lt;ul&gt;
&lt;li&gt;Works with MSBuild projects (.sln and .csproj files)&lt;/li&gt;
&lt;li&gt;Supports MSTest.
&lt;ul&gt;
&lt;li&gt;Supports only the basic, minimum viable subset of MSTest functionality, namely the [TestClass], [TestMethod], [ClassInitialize], [ClassCleanup], and [Ignore] attributes, without any parameters.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Support for more languages, more project formats, more test frameworks, and more functionality may be added in the future.&lt;/p&gt;
&lt;h3 id="how-is-it-like-using-testana"&gt;How is it like using Testana?
&lt;/h3&gt;&lt;p&gt;You run Testana every time you want to run your tests. You launch it at the root of your source tree, without any command-line arguments, and its default behavior is to figure out everything by itself and do the right thing.&lt;/p&gt;
&lt;p&gt;Note that the first time you run Testana, there may be a noticeable delay while information is being collected; the information is cached, so this delay will not be there next time you run Testana.&lt;/p&gt;
&lt;p&gt;The first time you run Testana, it will run all tests.&lt;/p&gt;
&lt;p&gt;If you immediately re-run Testana, it will not run any tests, because nothing will have changed.&lt;/p&gt;
&lt;p&gt;If you touch one of your source files, build your project, and re-run Testana, it will only run tests that either directly or indirectly depend on the
changed file. If you run Testana with --help it will give you a rundown of the command-line arguments it supports.&lt;/p&gt;
&lt;h3 id="where-can-i-find-testana"&gt;Where can I find Testana?
&lt;/h3&gt;&lt;p&gt;The Java implementation of Testana is here:
&lt;a class="external"
href="https://github.com/mikenakis/Public/tree/master/testana" target="_blank"
&gt;https://github.com/mikenakis/Public/tree/master/testana&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The C# implementation of Testana is coming soon. (As soon as I turn it into an independent solution, because currently it is a project within a larger solution.)&lt;/p&gt;
&lt;h3 id="notes"&gt;Notes
&lt;/h3&gt;&lt;p&gt;In episode 167 of the Software Engineering Podcast (&lt;a class="external"
href="https://se-radio.net/2010/09/episode-167-the-history-of-junit-and-the-future-of-testing-with-kent-beck/" target="_blank"
&gt;SE Radio 167: The History of JUnit and the Future of Testing with Kent Beck&lt;/a&gt;) at about 40':00'' Kent Beck says that recently failed tests have the highest probability of failing again in the near future, so he suggests using this statistical fact at as a heuristic for picking which tests to run first. Testana optimizes the testing process deterministically, so there is no need to resort to heuristics.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Cover image: The Testana logo, &lt;em&gt;profile of a crash test dummy&lt;/em&gt; by michael.gr. Based on &lt;a class="external"
href="https://thenounproject.com/term/crash-test-dummy/401583/" target="_blank"
&gt;original work by Wes Breazell&lt;/a&gt; and &lt;a class="external"
href="https://thenounproject.com/term/woman/129498/" target="_blank"
&gt;Alexander Skowalsky&lt;/a&gt;. Used under &lt;a class="external"
href="https://creativecommons.org/licenses/by/3.0/us/" target="_blank"
&gt;CC BY License.&lt;/a&gt;&lt;/p&gt;</description></item><item><title>[SOLVED] Maven deploy fails with status 422 unprocessable entity</title><link>https://blog.michael.gr/post/2023-07-06-solved-maven-deploy-fails-with-status/</link><pubDate>Thu, 06 Jul 2023 09:21:20 +0000</pubDate><guid>https://blog.michael.gr/post/2023-07-06-solved-maven-deploy-fails-with-status/</guid><description>&lt;p&gt;It has been more than a year since I created this question on GitHub Community; a couple of days after that I found the solution by myself, so I answered my own question, and to this date comments keep being added by people who were helped by my post.&lt;/p&gt;
&lt;p&gt;When I look at it today, I notice that my answer has this particular style, this grumpy indignation which has become so characteristic of me, after a lifetime of battling with lame software, and even worse, with lame error messages.&lt;/p&gt;
&lt;p&gt;I thought I should share this on my blog for posterity.&lt;/p&gt;
&lt;p&gt;Here is the link:&lt;/p&gt;
&lt;p&gt;&lt;a class="external"
href="https://github.com/orgs/community/discussions/23474" target="_blank"
&gt;https://github.com/orgs/community/discussions/23474&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And here is the question:&lt;/p&gt;
&lt;p&gt;GitHub Community&lt;/p&gt;
&lt;p&gt;Maven deploy fails with status 422 unprocessable entity #23474&lt;/p&gt;
&lt;p&gt;Asked by Mikenakis on May 27, 2022&lt;/p&gt;
&lt;p&gt;I have this repository: &lt;a class="external"
href="https://github.com/mikenakis/Bathyscaphe" target="_blank"
&gt;GitHub - mikenakis/Bathyscaphe: Deep immutability and thread-safety assessment for Java objects&lt;/a&gt; in which both my CI-Workflow and my Release-Workflow work fine.&lt;/p&gt;
&lt;p&gt;Now I am trying to extract a sub-module from that repository into a new repository.&lt;/p&gt;
&lt;p&gt;So, I created this repository: &lt;a class="external"
href="https://github.com/mikenakis/BathyscapheClaims" target="_blank"
&gt;GitHub - mikenakis/BathyscapheClaims&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The CI-Workflow works, but when I try to launch the Relase-Workflow, I get the following error:&lt;/p&gt;
&lt;p&gt;Failed to execute goal org.apache.maven.plugins:maven-deploy-plugin:3.0.0-M2:deploy (default-deploy) on project bathyscaphe-claims: ArtifactDeployerException: Failed to deploy artifacts: Could not transfer artifact io.github.mikenakis:bathyscaphe-claims:jar:1.3 from/to github (&lt;a class="external"
href="https://maven.pkg.github.com/mikenakis/BathyscapheClaims%29" target="_blank"
&gt;https://maven.pkg.github.com/mikenakis/BathyscapheClaims)&lt;/a&gt;: transfer failed for &lt;a class="external"
href="https://maven.pkg.github.com/mikenakis/BathyscapheClaims/io/github/mikenakis/bathyscaphe-claims/1.3/bathyscaphe-claims-1.3.jar" target="_blank"
&gt;https://maven.pkg.github.com/mikenakis/BathyscapheClaims/io/github/mikenakis/bathyscaphe-claims/1.3/bathyscaphe-claims-1.3.jar&lt;/a&gt;, status: 422 Unprocessable Entity ‚Üí [Help 1]&lt;/p&gt;
&lt;p&gt;I have already seen the issues that appear to be similar; most of them have no answer, one of them (&lt;a class="external"
href="https://github.community/t/maven-deploy-fails-with-http-422-unprocessable-entity/119670" target="_blank"
&gt;Maven deploy fails with HTTP 422 Unprocessable Entity&lt;/a&gt;) has an extensive discussion, but it does not seem to apply in my case.&lt;/p&gt;
&lt;p&gt;Can someone please help me? It is probably something silly, but I only have one pair of eyes, while this obviously needs two! (-:=&lt;/p&gt;
&lt;p&gt;Cheers!&lt;/p&gt;
&lt;p&gt;And here is the answer:&lt;/p&gt;
&lt;p&gt;Answered by mikenakis on May 29, 2022&lt;/p&gt;
&lt;p&gt;I figured this one out too by myself.
(Hey community, you are not helping much!)&lt;/p&gt;
&lt;p&gt;What happened is that GitHub apparently has some monstrous bug which causes artifact deployment to fail if some other repository (only by the same owner, I hope!) has already deployed an artifact with the exact same name.&lt;/p&gt;
&lt;p&gt;In this case, one repository was called Bathyscaphe, the other was called BathyscapheClaims, but each repository was trying to deploy an artifact called bathyscaphe-claims.&lt;/p&gt;
&lt;p&gt;I changed the name of the artifact in the second repository from bathyscaphe-claims to bathyscaphe-claims2 and it worked.&lt;/p&gt;
&lt;p&gt;The situation was certainly made worse by this contemptible monstrosity that goes by the name of ‚Äúmaven‚Äù, which never gives any meaningful error message whatsoever when the slightest thing goes wrong. I mean, ‚Äúunprocessable entity‚Äù? Really? It must have been some very special kind of idiot who came up with this error message.&lt;/p&gt;</description></item><item><title>Intertwine</title><link>https://blog.michael.gr/post/2022-12-intertwine/</link><pubDate>Sun, 11 Dec 2022 16:18:00 +0000</pubDate><guid>https://blog.michael.gr/post/2022-12-intertwine/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2022-12-intertwine/media/intertwine-logo.svg"
loading="lazy"
&gt;
&lt;/p&gt;
&lt;h3 id="abstract"&gt;Abstract
&lt;/h3&gt;&lt;p&gt;A mechanism is described for automatically converting method invocations of any programmatic interface into a single-method &lt;em&gt;&lt;strong&gt;normal form&lt;/strong&gt;&lt;/em&gt; and converting back to invocations of the original interface, so that general-purpose operations can be performed on the normal form without explicit knowledge of the interface being invoked. Implementations are provided for C# and for Java.&lt;/p&gt;
&lt;p&gt;(Useful pre-reading: &lt;a
href="https://blog.michael.gr/post/2022-11-about-these-papers/"
&gt;About these papers&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id="the-problem"&gt;The Problem
&lt;/h3&gt;&lt;p&gt;When creating software systems of nontrivial complexity we often need to be able to apply certain operations on the invocations that are being made between certain components. Examples of such operations are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Logging:&lt;/strong&gt; Recording information about each invocation being made.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multicasting:&lt;/strong&gt; Delivering a single invocation to multiple recipients.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Remoting:&lt;/strong&gt; Placing invocations across machine boundaries.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Desynchronization:&lt;/strong&gt; Queuing invocations for later execution, possibly on a different thread.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Synchronization:&lt;/strong&gt; Obtaining and holding a lock for the duration of the invocation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transformation:&lt;/strong&gt; Converting between invocation formats, e.g. method calls to REST and back.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ordinarily, the components doing the invocations are application-specific, and the interfaces between them are also application-specific, but the operators that we want to interject between them are general-purpose, so they need to remain agnostic of the application-specific details of the invocations, in a way analogous to how a general-purpose sorting algorithm is agnostic of the application-specific format of the data it sorts.&lt;/p&gt;
&lt;p&gt;Therefore, we need some way of expressing application-specific invocations in a general-purpose form.&lt;/p&gt;
&lt;h3 id="prior-art"&gt;Prior Art
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Messages and message-passing:&lt;/strong&gt; The mechanism historically used for expressing invocations in a general-purpose form is message-passing. Unfortunately, its use is laborious, and it floods systems with debilitating amounts of incidental complexity. For details, see &lt;a
href="https://blog.michael.gr/post/2022-12-messages-and-message-passing/"
&gt;On messages and message-passing&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Parameterless lambdas:&lt;/strong&gt; Application-specific method calls can be wrapped inside parameterless lambdas, and since all parameterless lambdas look the same, they can be handled by general-purpose code which may for example add them to a queue, and later dequeue and invoke them.
Unfortunately:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The wrapping of each application-specific method call inside a parameterless lambda must happen at each call site, which is cumbersome and reveals details about the underlying invocation delivery mechanism.&lt;/li&gt;
&lt;li&gt;The evaluation of the parameters that are passed to the application-specific method happens at the moment that the lambda makes the call, not at the moment that the lambda is constructed, which can lead to insidious bugs even if the evaluations have no side-effects. (And &lt;em&gt;woe to you on earth and sea&lt;/em&gt; if they do have side-effects.)&lt;/li&gt;
&lt;li&gt;The parameterless lambda completely hides the values of the parameters that are being passed to the application-specific method, as well as the identity of the method being invoked. Thus, parameterless lambdas cannot be used in scenarios that require information about each call being made.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Dynamic Proxies:&lt;/strong&gt; Both in Java and in C# there exist mechanisms that can be used to convert application-specific invocations to a general-purpose form, but not the other way around. These are &lt;code&gt;java.lang.reflect.Proxy&lt;/code&gt; for Java, and various libraries like Castle's and LinFu for C#. The reverse operation can be achieved using reflection, but this involves a round-trip to native-land, which incurs a heavy performance penalty. Furthermore, these mechanisms suffer from additional issues, such as messing with exceptions, doing more work than necessary, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="the-solution"&gt;The Solution
&lt;/h3&gt;&lt;p&gt;In order to be able to perform general-purpose operations on application-specific invocations we need a mechanism for converting application-specific invocations into a general-purpose form and back, so that the operators can act upon the general-purpose form. What follows is a description of such a mechanism, which I call &lt;em&gt;&lt;strong&gt;Intertwine&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Intertwine introduces a general-purpose form for expressing invocations, which is called &lt;em&gt;&lt;strong&gt;the normal form of invocations&lt;/strong&gt;&lt;/em&gt;, and is represented by a single method of the following signature:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;MethodKey&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;In C#, &lt;code&gt;AnyCall&lt;/code&gt; would be a &lt;em&gt;delegate.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;In Java, &lt;code&gt;AnyCall&lt;/code&gt; would be a &lt;em&gt;single-method interface&lt;/em&gt;, otherwise known as a &lt;em&gt;functional interface&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This method signature represents the fact that every conceivable interface method call can be fully described in terms of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A return value, of the common denominator type &lt;code&gt;Object&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A unique key which identifies which method of the interface is being invoked.&lt;/li&gt;
&lt;li&gt;An array containing arguments, of the common denominator type &lt;code&gt;Object&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Please note that the method identifier is &lt;code&gt;MethodKey&lt;/code&gt; in the Java implementation, but &lt;code&gt;int selector&lt;/code&gt; in the C# implementation. This is because the Java implementation was made a considerable time after the C# implementation, and is therefore a bit more advanced.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;MethodKey&lt;/code&gt; used in the Java implementation allows the caller and the callee to unambiguously identify methods even in situations where binary compatibility between the caller and the callee is not guaranteed, and therefore an integer method index does not necessarily refer to the same method on both the caller and the callee.&lt;/p&gt;
&lt;p&gt;The Java implementation of intertwine provides efficient means of converting back and forth between a &lt;code&gt;MethodKey&lt;/code&gt; and any of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The reflection &amp;quot;Method&amp;quot; object of the method. (This is &lt;code&gt;java.lang.reflect.Method&lt;/code&gt; in Java, or &lt;code&gt;System.Reflection.MethodInfo&lt;/code&gt; in C#.)&lt;/li&gt;
&lt;li&gt;The string representation of the prototype of the method.&lt;/li&gt;
&lt;li&gt;The zero-based method index of the method.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The sample code that follows was written for C#, so it uses an &lt;code&gt;int selector&lt;/code&gt; instead of &lt;code&gt;MethodKey key&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For methods of &lt;code&gt;void&lt;/code&gt; return type the value returned by AnyCall is unspecified. (It will in all likelihood be &lt;code&gt;null&lt;/code&gt;, but nobody should rely on this.)&lt;/li&gt;
&lt;li&gt;Value types (primitives) are boxed and unboxed as necessary.&lt;/li&gt;
&lt;li&gt;Certain features such as the &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; parameters in C#, receive special handling.&lt;/li&gt;
&lt;li&gt;Other features such as properties, indexers, virtual events, etc. are nothing but syntactic sugar which is implemented using regular method calls under the hood, so they require no special handling.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, the problem can now be restated as follows:&lt;/p&gt;
&lt;p&gt;How to convert any interface method invocation to an invocation of an AnyCall method, and how to convert back from an invocation of an AnyCall method to an invocation of the original interface method.&lt;/p&gt;
&lt;p&gt;For this, Intertwine introduces two new concepts: &lt;em&gt;&lt;strong&gt;Entwiners&lt;/strong&gt;&lt;/em&gt; and &lt;em&gt;&lt;strong&gt;Untwiners&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An Entwiner of interface &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; is a class which exposes (implements) interface &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; and delegates to an instance of &lt;em&gt;AnyCall&lt;/em&gt;. It can also be thought of as a &lt;em&gt;normalizer&lt;/em&gt; or &lt;em&gt;generalizer&lt;/em&gt; or &lt;em&gt;multiplexer.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;An Untwiner of interface &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; is a class which exposes an &lt;em&gt;AnyCall&lt;/em&gt; method and delegates to an instance of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt;. It can also be thought of as a &lt;em&gt;denormalizer&lt;/em&gt; or &lt;em&gt;specializer&lt;/em&gt; or &lt;em&gt;demultiplexer.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;More specifically:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The entwiner of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; does the following:
&lt;ul&gt;
&lt;li&gt;Accepts an instance of &lt;code&gt;Anycall&lt;/code&gt; as a constructor parameter and stores it in a &lt;code&gt;final&lt;/code&gt;/&lt;code&gt;readonly&lt;/code&gt; field.&lt;/li&gt;
&lt;li&gt;Implements each method of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; as follows:
&lt;ul&gt;
&lt;li&gt;Packs the parameters that were passed to the method into an array of &lt;code&gt;Object&lt;/code&gt;, performing any boxing necessary.&lt;/li&gt;
&lt;li&gt;Invokes anyCall passing it a key that uniquely identifies the method, and the array of parameters.&lt;/li&gt;
&lt;li&gt;Returns, possibly after unboxing, whatever was returned by the invocation of anyCall.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The untwiner of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; performs the opposite and complementary operation of the entwiner, namely:
&lt;ul&gt;
&lt;li&gt;Accepts an instance of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; as a constructor parameter and stores it in a &lt;code&gt;final&lt;/code&gt;/&lt;code&gt;readonly&lt;/code&gt; field.&lt;/li&gt;
&lt;li&gt;Implements the &lt;code&gt;anycall&lt;/code&gt; method of the &lt;code&gt;Anycall&lt;/code&gt; interface as follows:&lt;/li&gt;
&lt;li&gt;It uses the supplied &lt;code&gt;MethodKey&lt;/code&gt; to determine which method of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; is being invoked, and for each method it does the
following:
&lt;ul&gt;
&lt;li&gt;Unpacks the parameters from the array of &lt;code&gt;Object&lt;/code&gt;, performing any unboxing necessary.&lt;/li&gt;
&lt;li&gt;Invokes the method of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt;, passing it the unpacked parameters.&lt;/li&gt;
&lt;li&gt;Returns, possibly after boxing, whatever was returned by the method, or &lt;code&gt;null&lt;/code&gt; if the method was of &lt;code&gt;void&lt;/code&gt; return type.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="a-hand-crafted-implementation"&gt;A hand-crafted implementation
&lt;/h3&gt;&lt;p&gt;Before we look at the automatic creation of entwiners and untwiners, let us take a look at an example of how we would implement an entwiner and untwiner for a certain interface if we were to do it by hand.&lt;/p&gt;
&lt;p&gt;Let us consider the following interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-3"&gt;&lt;a class="lnlinks" href="#hl-1-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-4"&gt;&lt;a class="lnlinks" href="#hl-1-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-5"&gt;&lt;a class="lnlinks" href="#hl-1-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;IFooable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Moo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Boo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;And let us consider the following class implementing that interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-2-1"&gt;&lt;a class="lnlinks" href="#hl-2-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-2"&gt;&lt;a class="lnlinks" href="#hl-2-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-3"&gt;&lt;a class="lnlinks" href="#hl-2-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-4"&gt;&lt;a class="lnlinks" href="#hl-2-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-5"&gt;&lt;a class="lnlinks" href="#hl-2-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;FooImplementation&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Moo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;Console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WriteLine&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;i: &amp;#34;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Boo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;Console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WriteLine&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;s: &amp;#34;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;, b: &amp;#34;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;And then let us consider the following method which invokes the interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-3-1"&gt;&lt;a class="lnlinks" href="#hl-3-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-2"&gt;&lt;a class="lnlinks" href="#hl-3-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-3"&gt;&lt;a class="lnlinks" href="#hl-3-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-4"&gt;&lt;a class="lnlinks" href="#hl-3-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-5"&gt;&lt;a class="lnlinks" href="#hl-3-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;InvokeFoo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;fooable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Moo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="m"&gt;42&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;fooable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Boo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;fubar!&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The InvokeFoo method can be directly hooked up to an instance of the implementing class in a completely conventional way as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-4-1"&gt;&lt;a class="lnlinks" href="#hl-4-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-4-2"&gt;&lt;a class="lnlinks" href="#hl-4-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-4-3"&gt;&lt;a class="lnlinks" href="#hl-4-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-4-4"&gt;&lt;a class="lnlinks" href="#hl-4-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-4-5"&gt;&lt;a class="lnlinks" href="#hl-4-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Run1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FooImplementation&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;InvokeFoo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Now, an entwiner for our IFooable interface could be hand-crafted as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-5-1"&gt;&lt;a class="lnlinks" href="#hl-5-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-5-2"&gt;&lt;a class="lnlinks" href="#hl-5-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-5-3"&gt;&lt;a class="lnlinks" href="#hl-5-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-5-4"&gt;&lt;a class="lnlinks" href="#hl-5-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-5-5"&gt;&lt;a class="lnlinks" href="#hl-5-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-5-6"&gt;&lt;a class="lnlinks" href="#hl-5-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-5-7"&gt;&lt;a class="lnlinks" href="#hl-5-7"&gt;7&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;EntwinerForFooable&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="k"&gt;readonly&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Constructor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="n"&gt;anycall&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;anycall&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Moo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt;&lt;span class="p"&gt;[]{&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Boo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt;&lt;span class="p"&gt;[]{&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Whereas an untwiner for IFooable could be hand-crafted as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-6-1"&gt;&lt;a class="lnlinks" href="#hl-6-1"&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-2"&gt;&lt;a class="lnlinks" href="#hl-6-2"&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-3"&gt;&lt;a class="lnlinks" href="#hl-6-3"&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-4"&gt;&lt;a class="lnlinks" href="#hl-6-4"&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-5"&gt;&lt;a class="lnlinks" href="#hl-6-5"&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-6"&gt;&lt;a class="lnlinks" href="#hl-6-6"&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-7"&gt;&lt;a class="lnlinks" href="#hl-6-7"&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-8"&gt;&lt;a class="lnlinks" href="#hl-6-8"&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-9"&gt;&lt;a class="lnlinks" href="#hl-6-9"&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-10"&gt;&lt;a class="lnlinks" href="#hl-6-10"&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-11"&gt;&lt;a class="lnlinks" href="#hl-6-11"&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-12"&gt;&lt;a class="lnlinks" href="#hl-6-12"&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-13"&gt;&lt;a class="lnlinks" href="#hl-6-13"&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-14"&gt;&lt;a class="lnlinks" href="#hl-6-14"&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-15"&gt;&lt;a class="lnlinks" href="#hl-6-15"&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UntwinerForFooable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="k"&gt;readonly&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Constructor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;Target&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;selector&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Moo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Boo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InvalidOperationException&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;With the above classes, we can now write the following piece of awesomeness:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-7-1"&gt;&lt;a class="lnlinks" href="#hl-7-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-7-2"&gt;&lt;a class="lnlinks" href="#hl-7-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-7-3"&gt;&lt;a class="lnlinks" href="#hl-7-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-7-4"&gt;&lt;a class="lnlinks" href="#hl-7-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-7-5"&gt;&lt;a class="lnlinks" href="#hl-7-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-7-6"&gt;&lt;a class="lnlinks" href="#hl-7-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-7-7"&gt;&lt;a class="lnlinks" href="#hl-7-7"&gt;7&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Run2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FooImplementation&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;untwiner&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;UntwinerForFooable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;entwiner&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;EntwinerForFooable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;untwiner&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;InvokeFoo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;entwiner&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Note that &lt;code&gt;Run2()&lt;/code&gt; has exactly the same end-result as &lt;code&gt;Run1()&lt;/code&gt;, but there is a big difference in what goes on under the hood: all outbound interface method calls from the &lt;code&gt;InvokeFoo&lt;/code&gt; function are now arriving at the entwiner, which converts them to &lt;code&gt;AnyCall&lt;/code&gt; invocations, which are then forwarded to the untwiner, which converts them back to &lt;code&gt;IFooable&lt;/code&gt; calls, which are then forwarded to our &lt;code&gt;FooImplementation&lt;/code&gt; object. This means that if we wanted to, we could interject a chain of objects between the entwiner and the untwiner, each one of these objects implementing an &lt;code&gt;AnyCall&lt;/code&gt; delegate and invoking another &lt;code&gt;AnyCall&lt;/code&gt; delegate, thus enabling us to perform any conceivable operation upon those invocations without having any built-in knowledge of the &lt;code&gt;IFooable&lt;/code&gt; interface.&lt;/p&gt;
&lt;p&gt;As the complexity of the interface increases, and as additional subtleties come into the picture, such as parameters passed with ref or out, coding entwiners and untwiners by hand can become very tedious and error-prone, so, obviously, we would like to have it automated.&lt;/p&gt;
&lt;h3 id="automating-it-with-reflection"&gt;Automating it with reflection
&lt;/h3&gt;&lt;p&gt;It is possible to write a general-purpose untwiner that does its job using reflection, but reflection is slow, so the result is going to suffer performance-wise. For the sake of completeness, here is a possible implementation for a general-purpose reflecting untwiner using reflection:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-8-1"&gt;&lt;a class="lnlinks" href="#hl-8-1"&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-2"&gt;&lt;a class="lnlinks" href="#hl-8-2"&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-3"&gt;&lt;a class="lnlinks" href="#hl-8-3"&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-4"&gt;&lt;a class="lnlinks" href="#hl-8-4"&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-5"&gt;&lt;a class="lnlinks" href="#hl-8-5"&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-6"&gt;&lt;a class="lnlinks" href="#hl-8-6"&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-7"&gt;&lt;a class="lnlinks" href="#hl-8-7"&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-8"&gt;&lt;a class="lnlinks" href="#hl-8-8"&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-9"&gt;&lt;a class="lnlinks" href="#hl-8-9"&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-10"&gt;&lt;a class="lnlinks" href="#hl-8-10"&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-11"&gt;&lt;a class="lnlinks" href="#hl-8-11"&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-12"&gt;&lt;a class="lnlinks" href="#hl-8-12"&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-13"&gt;&lt;a class="lnlinks" href="#hl-8-13"&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-14"&gt;&lt;a class="lnlinks" href="#hl-8-14"&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-15"&gt;&lt;a class="lnlinks" href="#hl-8-15"&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ReflectingUntwiner&lt;/span&gt; &lt;span class="c1"&gt;//WARNING: SLOW AS MOLASSES&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="k"&gt;readonly&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt; &lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="k"&gt;readonly&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Reflection&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MethodInfo&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;Methodinfos&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Constructor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="n"&gt;twinee&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Target&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Methodinfos&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;twinee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetMethods&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;BindingFlags&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Public&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;BindingFlags&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NonPublic&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="n"&gt;BindingFlags&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Instance&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Methodinfos&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;Invoke&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Note that untwiner creation could be optimized by caching the MethodInfos of frequently used types, but that's not the problem; the real bottleneck is the &lt;code&gt;MethodInfo.Invoke()&lt;/code&gt; call. If you put a breakpoint on the target and examine the stack, you will see that between the &lt;code&gt;AnyCall&lt;/code&gt; frame and the target frame there will be a managed-to-native transition and a native-to-managed transition, which is something to be avoided at all costs.&lt;/p&gt;
&lt;p&gt;Also note: it is impossible to write a reflecting entwiner.&lt;/p&gt;
&lt;h3 id="automating-it-with-intertwine"&gt;Automating it with Intertwine
&lt;/h3&gt;&lt;p&gt;The Intertwine library will automatically generate for us a pair of optimally-performing entwiner and untwiner classes for any interface. These classes are generated at runtime, so no extra build step is needed. To accomplish this, the C# implementation of Intertwine generates MSIL and creates assemblies from it; the Java Implementation generates bytecode and creates classes from it.&lt;/p&gt;
&lt;p&gt;The following method of the &lt;code&gt;Intertwine.Factory&lt;/code&gt; class creates an entwiner:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;NewEntwiner&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;(&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="n"&gt;anycall&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For &lt;code&gt;T&lt;/code&gt; we give the type of our interface, and for &lt;code&gt;anycall&lt;/code&gt; we give a delegate of ours that will be receiving calls. This method returns a reference to an implementation of our interface, provided by an Entwiner-derived class that has been dynamically generated specifically for our interface, and instantiated to work with the given &lt;code&gt;AnyCall&lt;/code&gt; instance. For every call received through a method of our interface, this special entwiner will be marshalling the arguments and forwarding the call to our &lt;code&gt;AnyCall&lt;/code&gt; delegate.&lt;/p&gt;
&lt;p&gt;The following method of the &lt;code&gt;Intertwine.Factory&lt;/code&gt; class creates an untwiner:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="n"&gt;NewUntwiner&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;(&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For target we give an implementation of our interface, and what we get is a reference to an &lt;code&gt;AnyCall&lt;/code&gt; delegate implemented by an Untwiner-derived class that was dynamically generated specifically for our interface, and instantiated to work with the given target instance. For every call received through the &lt;code&gt;AnyCall&lt;/code&gt; delegate, this special untwiner will be unmarshalling the arguments and forwarding the call to the appropriate method of our target interface.&lt;/p&gt;
&lt;p&gt;So, with the dynamically generated entwiners and untwiners we can now do the following epicness:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-11-1"&gt;&lt;a class="lnlinks" href="#hl-11-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-11-2"&gt;&lt;a class="lnlinks" href="#hl-11-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-11-3"&gt;&lt;a class="lnlinks" href="#hl-11-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-11-4"&gt;&lt;a class="lnlinks" href="#hl-11-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-11-5"&gt;&lt;a class="lnlinks" href="#hl-11-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-11-6"&gt;&lt;a class="lnlinks" href="#hl-11-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-11-7"&gt;&lt;a class="lnlinks" href="#hl-11-7"&gt;7&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Run3&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FooImplementation&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="n"&gt;untwiner&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Intertwine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Factory&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewUntwiner&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;IFooable&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;(&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;entwiner&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Intertwine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Factory&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewEntwiner&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;IFooable&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;(&lt;/span&gt; &lt;span class="n"&gt;untwiner&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;InvokeFoo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;entwiner&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The actual implementation of &lt;code&gt;Intertwine.Factory&lt;/code&gt; is pretty straightforward, so there is not much to talk about. As one might expect, the generated types are cached. A static factory method is generated with each generated type, for instantiating the type, so as to avoid having to call &lt;code&gt;Activator.CreateInstance()&lt;/code&gt;, because that method uses reflection. The static factory method is invoked using &lt;code&gt;Delegate.Invoke()&lt;/code&gt;, which does not use reflection. You will find the code-generating code choke-full of comments, explaining exactly what each emitted opcode does.&lt;/p&gt;
&lt;p&gt;Intertwine for C#:
&lt;a class="external"
href="https://github.com/mikenakis/IntertwineCSharp" target="_blank"
&gt;https://github.com/mikenakis/IntertwineCSharp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Intertwine for Java:
&lt;a class="external"
href="https://github.com/mikenakis/Public/tree/master/intertwine" target="_blank"
&gt;https://github.com/mikenakis/Public/tree/master/intertwine&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="appendix-an-example-interface-multicasts-events-in-c"&gt;Appendix: An example: Interface multicasts (events) in C#
&lt;/h3&gt;&lt;p&gt;If you are still with me you may be thinking that it is about time for a demonstration. What follows is not just an example, but actually a complete and useful application of intertwine which you may be able to start utilizing in your projects right away.&lt;/p&gt;
&lt;p&gt;The C# language has built-in support for multicasts (events) but only delegates can be used as event observers. There are many cases, however, where interfaces would be more suitable. Java does not even have built-in support for multicasts, so programmers generally have to write their own, using single-method (functional) interfaces. In either language, if you want to achieve multicasting on multi-method interfaces, you have to rewrite the multicasting code for every single method of every single interface.&lt;/p&gt;
&lt;p&gt;Consider the following interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-12-1"&gt;&lt;a class="lnlinks" href="#hl-12-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-12-2"&gt;&lt;a class="lnlinks" href="#hl-12-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-12-3"&gt;&lt;a class="lnlinks" href="#hl-12-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-12-4"&gt;&lt;a class="lnlinks" href="#hl-12-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-12-5"&gt;&lt;a class="lnlinks" href="#hl-12-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-12-6"&gt;&lt;a class="lnlinks" href="#hl-12-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;ITableNotification&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RowInserted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Fields&lt;/span&gt; &lt;span class="n"&gt;fields&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RowDeleted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RowUpdated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Fields&lt;/span&gt; &lt;span class="n"&gt;fields&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;And consider the following hypothetical (not actually possible) way of using it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-13-1"&gt;&lt;a class="lnlinks" href="#hl-13-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-13-2"&gt;&lt;a class="lnlinks" href="#hl-13-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-13-3"&gt;&lt;a class="lnlinks" href="#hl-13-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;event&lt;/span&gt; &lt;span class="n"&gt;ITableNotification&lt;/span&gt; &lt;span class="n"&gt;tableNotificationEvent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;tableNotificationEvent&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;my_observer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;tableNotificationEvent&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RowUpdated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fields&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The above does not work because events in C# work only with delegates, not with interfaces. However, with Intertwine, the next best thing is actually possible:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-14-1"&gt;&lt;a class="lnlinks" href="#hl-14-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-14-2"&gt;&lt;a class="lnlinks" href="#hl-14-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-14-3"&gt;&lt;a class="lnlinks" href="#hl-14-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;tableNotificationEventManager&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;InterfaceEventManager&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ITableNotifcation&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;tableNotificationEventManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Source&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RegisterObserver&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;my_observer&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;tableNotificationEventManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Trigger&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RowUpdated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fields&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;This approach is self-explanatory, and the amount of code you have to write in order to use it is optimal; you do not need to deal with anything more than what is necessary, and if you ever add a notification, it will be a new interface method, so all existing implementations of that interface will automatically be flagged by the compiler as incomplete. With the help of Intertwine, this event manager is implemented in just 150 lines of code, including extensive comments.&lt;/p&gt;
&lt;h3 id="end-notes"&gt;End-notes
&lt;/h3&gt;&lt;p&gt;Back in 2011 I posted a question on stackoverflow.com, titled &lt;a class="external"
href="https://stackoverflow.com/questions/6154205/multiplexing-interface-method-calls-into-a-single-delegate-and-demultiplexing" target="_blank"
&gt;Multiplexing interface method calls into a single delegate and demultiplexing&lt;/a&gt; asking if anyone knows of anything like Intertwine, but nobody did, so I built it myself.&lt;/p&gt;
&lt;p&gt;This post supersedes the original post from 2011: &lt;a
href="https://blog.michael.gr/post/2011-10-16-intertwine-normalizing-interface/"
&gt;Intertwine: Normalizing Interface Invocations&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Cover image: The Intertwine Logo, by michael.gr&lt;/p&gt;</description></item><item><title>Bathyscaphe</title><link>https://blog.michael.gr/post/2022-05-bathyscaphe/</link><pubDate>Tue, 19 Apr 2022 10:54:08 +0000</pubDate><guid>https://blog.michael.gr/post/2022-05-bathyscaphe/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2022-05-bathyscaphe/media/bathyscaphe-logo.svg"
loading="lazy" alt="Bathyscaphe logo"
&gt;
&lt;/p&gt;
&lt;h2 id="abstract"&gt;Abstract
&lt;/h2&gt;&lt;p&gt;This article introduces Bathyscaphe, an open-source java library that you can use to assert that your objects are immutable and/or thread-safe.&lt;/p&gt;
&lt;h2 id="the-problem"&gt;The problem
&lt;/h2&gt;&lt;p&gt;Programmers all over the world are embracing immutability more and more; however, mutation is still a thing, and in all likelihood will continue being a thing for as long as there will be programmers. In a world where both mutable and immutable objects exist side by side, there is often a need to ascertain that an object is of the immutable variety before proceeding to use it for certain purposes. For example, when an object is used as a key in a hash map, it better be immutable, or else the hash code of the key may change, causing the map to severely malfunction.&lt;/p&gt;
&lt;p&gt;Furthermore, even when an object is mutable, there is often the need to ascertain that it is at least thread-safe before sharing it between threads, otherwise there will be race conditions, with catastrophic results.&lt;/p&gt;
&lt;p&gt;Note that when any of the above goes wrong, it tends to be a bug which is very difficult to troubleshoot.&lt;/p&gt;
&lt;p&gt;Unfortunately, assessment of thread safety and immutability is not an easy task. Most don't even consider it, few talk about it, even fewer attempt it. Programmers all over the world are accustomed to routinely using objects in situations where thread-safety and/or immutability are absolute requirements, but without ever ascertaining them, essentially &lt;em&gt;praying&lt;/em&gt; that the objects be thread-safe and/or immutable.&lt;/p&gt;
&lt;p&gt;As far as I can tell, in the world of the JVM there exist no libraries that will ascertain thread-safety. As for immutability, there are some that purport to do so, but Judging by how marginal status these libraries have in the greater technology landscape, they are not being put into much use. This is not surprising, because they rely exclusively on static analysis, which does not really solve the problem, as I will show.&lt;/p&gt;
&lt;h2 id="introducing-bathyscaphe"&gt;Introducing Bathyscaphe
&lt;/h2&gt;&lt;p&gt;Bathyscaphe aims to give the Java world another chance at addressing the problem of thread-safety and immutability assessment instead of letting it linger on like a chronic ailment. Bathyscaphe is really easy to use, and produces correct and useful results. It is also very small:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The JAR file is only about 100 kilobytes.&lt;/li&gt;
&lt;li&gt;Setting aside the test module, which necessarily depends on JUnit, Bathyscaphe does not have any dependencies outside the Java Runtime Environment. Let me repeat this: Bathyscaphe. Has. No. Dependencies. It depends on nothing. When you include Bathyscaphe in a project, you are including its tiny JAR file and nothing else.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="why-existing-solutions-do-not-work"&gt;Why existing solutions do not work
&lt;/h2&gt;&lt;p&gt;Oftentimes we can tell whether an object is mutable or immutable just by looking at its class, and indeed there exist static analysis tools that examine classes and classify them as either mutable or immutable. The widespread understanding is that once a class has been classified, all instances of that class can receive the same classification. However, in many cases it is not enough to just look at the class to determine immutability; instead, it is necessary to examine each and every instance of the class at runtime. When static analysis tools assess such classes, they yield results that are erroneous, or in the best case useless.&lt;/p&gt;
&lt;p&gt;Examples where static analysis &lt;em&gt;&lt;strong&gt;does not&lt;/strong&gt;&lt;/em&gt; work and &lt;strong&gt;cannot&lt;/strong&gt; work:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Static analysis does not work when a class contains a field which is final, receives its value from a constructor parameter, and the type of the field is an interface or a non-final class. Static analysis can determine that the field itself will not mutate, but has no way of knowing whether the value referenced by the field can mutate.
&lt;ul&gt;
&lt;li&gt;In order to err on the safe side, static analysis tools tend to assess classes containing such fields as mutable, but this is arbitrary, and it constitutes a false negative when the field is in fact initialized with an immutable value.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Static analysis does not work when a class is an unmodifiable collection of elements, where the elements can be of any type. The most famous examples in this category are the JDK-internal classes &lt;code&gt;java.util.ListN&lt;/code&gt; and &lt;code&gt;java.util.List12&lt;/code&gt;, instances of which are returned by &lt;code&gt;java.util.List.of()&lt;/code&gt; and its overloads.
&lt;ul&gt;
&lt;li&gt;Some static analysis tools assess such classes as immutable, which can be a false positive, e.g. in the case of &lt;code&gt;List.of( new StringBuilder() )&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Some static analysis tools assess such classes as mutable, which can be a false negative, e.g. in the case of &lt;code&gt;List.of( 1 )&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Static analysis does not work when a class is &lt;em&gt;&lt;strong&gt;freezable&lt;/strong&gt;&lt;/em&gt;. By this we mean a class whose instances begin life as mutable, and are at some point instructed to transition from being mutable to being immutable. For an explanation as to why freezable classes are important, see related appendix.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From the above it follows that in many cases, examining a class is not enough; in these cases, we need to examine each and every instance of the class at runtime. Furthermore, we need to examine not only the instance at hand, but the entire object graph referenced by that instance. In other words, we must not just assess shallow (superficial) immutability, we must assess deep immutability. That's what Bathyscaphe does. And that's why it is called Bathyscaphe.&lt;/p&gt;
&lt;h2 id="how-bathyscaphe-works"&gt;How Bathyscaphe Works
&lt;/h2&gt;&lt;p&gt;In a nutshell, Bathyscaphe uses reflection to examine each field of a class, and recursively the type of each field. If all fields of a class can be conclusively assessed as immutable, then all instances of that class will be assessed as immutable. However, if the actual type of the runtime value of a certain field cannot be known by a static examination of the class, then for each instance of the class at runtime, Bathyscaphe will read the value of the field, obtain the actual type of the value, and recursively assess the type of that value.&lt;/p&gt;
&lt;p&gt;In most cases Bathyscaphe can determine by itself whether a field is immutable or not; however, in some cases, things are not what they seem to be. For example, lazily initialized fields look mutable, but they are effectively immutable. Bathyscaphe does not attempt to analyze bytecode and detect how a certain field is used; that kind of detective work belongs to the realm of static analysis tools. In such cases, it is necessary to guide Bathyscaphe by using annotations to mark fields that might look mutable but should be considered as immutable.&lt;/p&gt;
&lt;p&gt;These annotations are essentially claims made by the programmer: Bathyscaphe does not, and cannot, verify the truthfulness of these claims. In this sense, Bathyscaphe does not provide a 100% fool-proof solution, because the programmer may code these annotations wrongly. In the future some synergy between Bathyscaphe and static analysis tools might be achieved, so as to provide 100% fool-proof results, but the benefit of using Bathyscaphe &lt;em&gt;&lt;strong&gt;now&lt;/strong&gt;&lt;/em&gt; lies in the fact that given correct annotations, Bathyscaphe will yield correct and usable results in all cases, whereas static analysis &lt;em&gt;does not&lt;/em&gt; work in all cases and by its nature &lt;em&gt;cannot&lt;/em&gt; work in all cases.&lt;/p&gt;
&lt;h2 id="where-to-find-bathyscaphe"&gt;Where to find Bathyscaphe
&lt;/h2&gt;&lt;p&gt;Bathyscaphe is hosted on GitHub; see &lt;a class="external"
href="https://github.com/mikenakis/Bathyscaphe" target="_blank"
&gt;https://github.com/mikenakis/Bathyscaphe&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="appendix-goals-of-bathyscaphe"&gt;Appendix: Goals of Bathyscaphe
&lt;/h2&gt;&lt;p&gt;I decided to write my own immutability assessment facility with the following goals in mind:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I want to be able to write framework-level code such as the following:
&lt;ul&gt;
&lt;li&gt;A hash-map which asserts that any and all keys added to it are immutable.&lt;/li&gt;
&lt;li&gt;A message-passing framework which asserts that every single message that it is asked to deliver is either immutable or at the very least thread-safe.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;I want results that are always accurate, meaning that there must be no false positives or false negatives, no compromises, no &amp;quot;aiming to cover the majority of use cases&amp;quot;. All use cases should be covered, and they should be covered correctly.&lt;/li&gt;
&lt;li&gt;I want to assess the immutability of objects, not classes, because I have observed that from a certain class we can sometimes construct instances that are mutable, and sometimes construct instances that are immutable. For example, both of the following method calls yield instances of the exact same class, and yet one instance is mutable, while the other instance is immutable:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List.of( 1 )&lt;/code&gt; (immutable)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List.of( new StringBuilder() )&lt;/code&gt; (mutable)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;I want to assess the immutability of the entire graph of objects referenced by a certain object, not the immutability of that object alone. In other words, I want deep immutability assessment, as opposed to shallow or superficial immutability assessment.&lt;/li&gt;
&lt;li&gt;When assessment cannot be achieved in an entirely automatic fashion, (as the case is, for example, with classes that perform lazy initialization,) I want to be able to achieve it by either:
&lt;ul&gt;
&lt;li&gt;adding special annotations to certain fields, or&lt;/li&gt;
&lt;li&gt;adding a manual preassessment (assessment override) for that specific class.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;I want the immutability assessment facility to account for freezable classes. This necessitates the introduction of a special self-assessment interface, so that instances can be asked whether they are immutable or not.&lt;/li&gt;
&lt;li&gt;When an immutability assertion fails, meaning that an object which I had intended to be immutable has been found to actually be mutable, I want to receive extensive diagnostics in human-readable form, explaining precisely why this happened.&lt;/li&gt;
&lt;li&gt;I want the immutability assessment library which achieves all this to be attractive to programmers, by being:
&lt;ul&gt;
&lt;li&gt;very easy to integrate&lt;/li&gt;
&lt;li&gt;very easy to use&lt;/li&gt;
&lt;li&gt;very small&lt;/li&gt;
&lt;li&gt;having no dependencies.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="appendix-non-goals-of-bathyscaphe"&gt;Appendix: Non-goals of Bathyscaphe
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Predicting what code will do.
&lt;ul&gt;
&lt;li&gt;That is the job of static analysis tools. Bathyscaphe is meant to issue accurate and useful assessments assuming correctly annotated classes. The correctness of the annotations is a lesser, and largely different problem, which is suitable as the focus of static analysis tools.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dealing with untrustworthy classes.
&lt;ul&gt;
&lt;li&gt;Immutability can always be compromised via reflection, so trying to assess immutability in an environment which is not completely trustworthy is a hopeless endeavor.&lt;/li&gt;
&lt;li&gt;Therefore, assessment is to be done on a full-trust basis.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dealing with buggy classes.
&lt;ul&gt;
&lt;li&gt;If a class promises, either by means of annotations or the self-assessment interface, that it will behave immutably, but in fact it does not, the fault is with that class, not with the immutability assessment facility.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dealing with inaccessible classes.
&lt;ul&gt;
&lt;li&gt;Due to security restrictions, the inner workings of certain JDK classes are inaccessible.&lt;/li&gt;
&lt;li&gt;Since every single one of those classes can receive a manual preassessment, this is not an issue.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dealing with farce.
&lt;ul&gt;
&lt;li&gt;If we create a subclass of a mutable class and override each mutation method to always throw an exception, do we have a mutable or immutable class in our hands?&lt;/li&gt;
&lt;li&gt;Some say it is mutable;&lt;/li&gt;
&lt;li&gt;others say it is immutable;&lt;/li&gt;
&lt;li&gt;I say it is a farce, and not worth considering.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Performance.
&lt;ul&gt;
&lt;li&gt;Immutability assessment can be computationally expensive, but it is only meant to be performed through assertions, so its overhead is to be suffered only on development runs.&lt;/li&gt;
&lt;li&gt;On production runs, where assertions are supposed to be disabled, the performance penalty of using Bathyscaphe is to be zero.&lt;/li&gt;
&lt;li&gt;Therefore, performance is not an issue.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Non-assertive assessment.
&lt;ul&gt;
&lt;li&gt;Non-assertive assessment means yielding an assessment result object which can then be further examined, as opposed to assertive assessment which means either passing the immutability check or throwing an exception.&lt;/li&gt;
&lt;li&gt;Non-assertive assessment would require publicly exposing the entire assessment hierarchy of Bathyscaphe. One that is done, people would inevitably start writing code that makes use of it, and from that moment on it would be impossible for me to continue refactoring and evolving Bathyscaphe without breaking all that code.&lt;/li&gt;
&lt;li&gt;Therefore, non-assertive assessment is not a goal.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Static analysis.
&lt;ul&gt;
&lt;li&gt;While it is indeed possible in many cases to conclusively assess a class as mutable or immutable by just looking at the class, in many other cases (and certainly in all &lt;em&gt;interesting&lt;/em&gt; cases) examining the class is not enough, as the example of &lt;code&gt;List.of( 1 )&lt;/code&gt; vs. &lt;code&gt;List.of( new StringBuilder())&lt;/code&gt; demonstrates.&lt;/li&gt;
&lt;li&gt;Thus, the use of Bathyscaphe as a static analysis tool is not a goal.&lt;/li&gt;
&lt;li&gt;If you need a static immutability analysis tool for Java, please see &lt;code&gt;MutabilityDetector&lt;/code&gt; on GitHub: &lt;a class="external"
href="https://github.com/MutabilityDetector" target="_blank"
&gt;https://github.com/MutabilityDetector&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="appendix-a-note-on-reference-types"&gt;Appendix: A note on reference types
&lt;/h3&gt;&lt;p&gt;If you decide to incorporate Bathyscaphe in a project, the first thing you are likely to do is what I did: introduce your own HashMap class which asserts that every key added to it is immutable. In doing so you might discover some bugs in your code, but you will also notice something seemingly strange: Bathyscaphe is preventing you from using reference types as keys, which kind of makes sense because they are in fact mutable, but you have never had any issues with that before, so why is it becoming a problem now?&lt;/p&gt;
&lt;p&gt;What is happening is that your reference types refrain from overriding &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt;, so they inherit the reference-equals function and the identity hash-code function from &lt;code&gt;Object&lt;/code&gt;. A reference to an object remains the same regardless of mutations that the object undergoes during its lifetime, and the same holds true for its identity hash-code. This has been allowing you to use reference types as keys in in hash maps, despite the fact that they undergo mutations, but it has only been working by coincidence.&lt;/p&gt;
&lt;p&gt;Another word for &amp;quot;coincidence&amp;quot; is &amp;quot;accident&amp;quot;, and Bathyscaphe is meant to be used precisely in order to avoid accidents, so you cannot keep doing this anymore. From now on, you will have to be using &lt;code&gt;IdentityHashMap&lt;/code&gt; for reference types, and &lt;code&gt;HashMap&lt;/code&gt; for value types.&lt;/p&gt;
&lt;h3 id="appendix-a-note-on-so-called-immutable-collections"&gt;Appendix: A note on so-called immutable collections
&lt;/h3&gt;&lt;p&gt;When Java 9 introduced the new &lt;code&gt;java.util.List.of()&lt;/code&gt; method and its various overloads, the documentation referred to the objects returned by that method as immutable lists. Specifically, in the Java 9 API docs we read &amp;quot;Returns an &lt;em&gt;&lt;strong&gt;immutable&lt;/strong&gt;&lt;/em&gt; list containing one element.&amp;quot; Later, the Java people realized that this is inaccurate, so in JDK issue 8191517 they decided among other things to &amp;quot;Adjust terminology to prefer 'unmodifiable' over 'immutable'.&amp;quot; Thus, if we look at the documentation today, (for example, in the Java 18 API documentation,) it reads &amp;quot;Returns an &lt;em&gt;&lt;strong&gt;unmodifiable&lt;/strong&gt;&lt;/em&gt; list containing one element.&amp;quot;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 9 API docs: &lt;a class="external"
href="https://docs.oracle.com/javase/9/docs/api/java/util/List.html" target="_blank"
&gt;https://docs.oracle.com/javase/9/docs/api/java/util/List.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JDK issue 8191517: &lt;a class="external"
href="https://bugs.openjdk.java.net/browse/JDK-8191517" target="_blank"
&gt;https://bugs.openjdk.java.net/browse/JDK-8191517&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java 18 API docs: &lt;a class="external"
href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/List.html" target="_blank"
&gt;https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/List.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dropping the word &amp;quot;immutable&amp;quot; was the right thing to do, because there is no such thing as an immutable collection, at least when type erasure is involved. That's because a collection contains elements, the immutability of which it is in no position to vouch for.&lt;/p&gt;
&lt;p&gt;Unfortunately, the term &amp;quot;unmodifiable&amp;quot; is also problematic for describing these collections, because that term already had a meaning before &lt;code&gt;List.of()&lt;/code&gt; was introduced, and the meaning was &amp;quot;an unmodifiable-&lt;em&gt;&lt;strong&gt;to-you&lt;/strong&gt;&lt;/em&gt; view of &lt;strong&gt;my&lt;/strong&gt; collection, which is still &lt;em&gt;&lt;strong&gt;very mutable&lt;/strong&gt;&lt;/em&gt;, and any mutations I make &lt;em&gt;&lt;strong&gt;will be visible to you&lt;/strong&gt;&lt;/em&gt;.&amp;quot;&lt;/p&gt;
&lt;p&gt;Luckily, &lt;code&gt;List.of()&lt;/code&gt; does better than that: it returns a list that cannot be modified by anyone. So, I would rather call it &amp;quot;unchangeable&amp;quot; or &amp;quot;superficially immutable&amp;quot; to indicate that it falls short of achieving true immutability only in the sense that it cannot guarantee deep immutability.&lt;/p&gt;
&lt;h3 id="appendix-a-note-on-assessment-overrides"&gt;Appendix: A note on assessment overrides
&lt;/h3&gt;&lt;p&gt;An assessment override on an effectively immutable class (for example, on a class which contains a lazily initialized field) is a drastic measure which should be used as seldom as possible. That's because an assessment override is also a blanket measure: it will prevent the immutability assessment facility from ascertaining the immutability of not only the lazily initialized field, but also of all other fields in the class, and in so doing it may hide errors. Assessment overrides should only be used on classes whose source code we do not control, and therefore we cannot annotate on a field-per-field basis.&lt;/p&gt;
&lt;h3 id="appendix-freezable-classes"&gt;Appendix: Freezable classes
&lt;/h3&gt;&lt;p&gt;As a rule, immutable objects tend to be immutable-upon-construction, meaning that any and all objects that they reference must be supplied as constructor parameters. There is, however, an exception: there is a category of objects called &amp;quot;freezable&amp;quot; which begin their life as mutable, (so that they can undergo complex initialization,) and are at some later moment instructed to transition to being immutable, that is, to &amp;quot;freeze&amp;quot;.&lt;/p&gt;
&lt;p&gt;Freezing happens in-place, it is permanent from the moment it is applied, and it is trivial to implement: all it takes is to set a &lt;code&gt;frozen&lt;/code&gt; field to &lt;code&gt;true&lt;/code&gt;. (A few more things are nice to have, for example assertions ensuring that no mutation methods are invoked once frozen, and splitting the interface of the object in two separate interfaces for mutable and immutable functionality respectively, so that once the object has been frozen, we can forget our reference to the mutable interface and only retain the immutable one.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Freezing is useful for performance:
&lt;ul&gt;
&lt;li&gt;Creating a mutable object, initializing it, and then freezing it performs much better than creating a mutable object, initializing it, and then copying its contents into a freshly allocated immutable object.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Freezing can achieve things that are otherwise hard, or impossible:
&lt;ul&gt;
&lt;li&gt;The creation of immutable cyclic graphs requires objects to be mutable while the graph is being constructed, and to become immutable in-place once construction is complete. This problem cannot be solved using the builder pattern, because the builder is bound to run into the same problem: how to construct A with a reference to B when B must be constructed with a reference to A.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To accommodate freezable classes, Bathyscaphe introduces the &lt;code&gt;ImmutabilitySelfAssessable&lt;/code&gt; interface. If a class implements this interface, then Bathyscaphe will be invoking instances of this class to ask them whether they are immutable or not.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Cover image: the Bathyscaphe logo, a line drawing of &lt;em&gt;&lt;strong&gt;bathyscaphe Trieste&lt;/strong&gt;&lt;/em&gt; by michael.gr, based on art found at &lt;a class="external"
href="https://bertrandpiccard.com/3-generations/jacques-piccard" target="_blank"
&gt;bertrandpiccard.com&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Java with Maven: Giving CI/CD a try</title><link>https://blog.michael.gr/post/2021-02-java-with-maven-giving-cicd-try/</link><pubDate>Wed, 10 Feb 2021 10:34:45 +0000</pubDate><guid>https://blog.michael.gr/post/2021-02-java-with-maven-giving-cicd-try/</guid><description>&lt;p&gt;Please note that this is work in progress. I am still working on it and refining it, as my understanding of it improves.&lt;/p&gt;
&lt;p&gt;I have a set of &lt;a class="external"
href="https://github.com/mikenakis" target="_blank"
&gt;public repositories on GitHub&lt;/a&gt; showcasing my work on java with maven. These projects are interdependent, so when you check out one of them, in order to compile and run it you need the binaries of some of the others. You could manually check out all of them and put them in an IDE project, but that's too much work. Solving this problem requires having Continuous Integration &amp;amp; Continuous Deployment (CI/CD) in place, so I decided to try my luck in setting one up using free services only.&lt;/p&gt;
&lt;p&gt;The process involves three entities:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;A Source Repository.&lt;/strong&gt; (Where our source code is hosted.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I use &lt;strong&gt;GitHub&lt;/strong&gt; for this.&lt;/li&gt;
&lt;li&gt;Possible alternatives:
&lt;ul&gt;
&lt;li&gt;GitLab&lt;/li&gt;
&lt;li&gt;BitBucket&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;A CI/CD provider.&lt;/strong&gt; (Where the actual CI/CD takes place.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I decided to use &lt;strong&gt;CircleCI&lt;/strong&gt; for this, but in retrospect it was a bad idea, because it does not support GitLab.&lt;/li&gt;
&lt;li&gt;Possible alternatives:
&lt;ul&gt;
&lt;li&gt;GitLab - I want to use it as a source code repository, and I don't want to put all my eggs in one basket, so I don't want to use it for anything else.&lt;/li&gt;
&lt;li&gt;GitHub - I want to use it as a source code repository, and I don't want to put all my eggs in one basket, so I don't want to use it for anything else.&lt;/li&gt;
&lt;li&gt;BitBucket - it is by Atlassian. Need I say more.&lt;/li&gt;
&lt;li&gt;Appveyor - gives various errors like &amp;quot;There was an error while trying to complete the current operation. Please contact AppVeyor support.&amp;quot; -- Lots of open source projects are using it though, so it might be worth a second try.&lt;/li&gt;
&lt;li&gt;Travis CI - only works with github.&lt;/li&gt;
&lt;li&gt;JFrog - overwhelmingly fancy front page followed by a not particularly fancy user experience once you get past the front page. Once I have registered, there is no way for me to log back in.&lt;/li&gt;
&lt;li&gt;semaphoreci.com - only works with github.&lt;/li&gt;
&lt;li&gt;buddy.works - after you have given them your e-mail address, they tell you that it is free but they require a valid payment method.&lt;/li&gt;
&lt;li&gt;atlassian.com/software/bamboo - it is by Atlassian, need I say more.&lt;/li&gt;
&lt;li&gt;drone.io - not only it works with nothing other than github, they assume that I am using github, which is very annoying.&lt;/li&gt;
&lt;li&gt;octopus.com - registration fails with &amp;quot;Please use your work email address.&amp;quot;&lt;/li&gt;
&lt;li&gt;buildkite.com - might work; not particularly user friendly.&lt;/li&gt;
&lt;li&gt;codefresh.io - might work; they unnecessarily complicate things with mandatory docker images.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;An Artifact Repository.&lt;/strong&gt; (Where the binaries are stored.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I found a place called Repsy for this; Repsy is minimalistic, unrefined,
and they even have bad English on their web site, but it will do for now.&lt;/li&gt;
&lt;li&gt;Possible alternatives:
&lt;ul&gt;
&lt;li&gt;GitHub Packages&lt;/li&gt;
&lt;li&gt;GitLab Package Registry&lt;/li&gt;
&lt;li&gt;JFrog Artifactory&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We begin with a situation where we already have the Source Repository (GitHub) and we want to set-up the CI/CD Provider (CircleCI) and the Artifact Repository (Repsy).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="setting-up-the-artifact-repository"&gt;Setting up the Artifact Repository
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Go to &lt;a class="external"
href="https://repsy.io" target="_blank"
&gt;Repsy&lt;/a&gt; and create a free account. The username in this case will be &lt;code&gt;mikenakis&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Create a public maven repository in Repsy. The repository name in this case is &lt;code&gt;mikenakis-public&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="testing-the-artifact-repository"&gt;Testing the Artifact Repository
&lt;/h4&gt;&lt;p&gt;Next, we need to make certain changes to our local setup so as to be able to deploy artifacts from within our local Development Environment directly to Repsy, to make sure this works before we even try CI/CD.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the maven folder (which is under &lt;code&gt;~/.m2&lt;/code&gt; in Linux, &lt;code&gt;%USERPROFILE%\.m2&lt;/code&gt; in Windows) create a &lt;code&gt;settings.xml&lt;/code&gt; with the following content (or if one already exists, make sure it includes the following content)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;&amp;lt;settings&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;servers&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;server&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;repsy-mikenakis-public&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;username&amp;gt;&lt;/span&gt;mikenakis&lt;span class="nt"&gt;&amp;lt;/username&amp;gt;&lt;/span&gt; &lt;span class="c"&gt;&amp;lt;!-- Repsy username --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;password&amp;gt;&lt;/span&gt;\*\*\*\*\*\*\*\*&lt;span class="nt"&gt;&amp;lt;/password&amp;gt;&lt;/span&gt; &lt;span class="c"&gt;&amp;lt;!-- Repsy password --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;/server&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;/servers&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;&amp;lt;settings&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Note:
&lt;ul&gt;
&lt;li&gt;The username and password for deploying artifacts into Repsy repositories is the same as the username and password of the Repsy account.&lt;/li&gt;
&lt;li&gt;The password does not have to be included here as plaintext; it can be encrypted. For instructions on how to do that, see &lt;a class="external"
href="https://maven.apache.org/guides/mini/guide-encryption.html" target="_blank"
&gt;Apache/ Maven/ Password Encryption&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Add the following to each and every &lt;code&gt;pom.xml&lt;/code&gt; file that is going to take part in CI/CD:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;&amp;lt;repositories&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;repsy-mikenakis-public&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;https://repo.repsy.io/mvn/mikenakis/mikenakis-public&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;&amp;lt;/repositories&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;&amp;lt;distributionManagement&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;repsy-mikenakis-public&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;https://repo.repsy.io/mvn/mikenakis/mikenakis-public&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;&amp;lt;/distributionManagement&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;That's it, we should now be able to execute &lt;code&gt;mvn deploy&lt;/code&gt; in our local environment and deploy to Repsy.&lt;/p&gt;
&lt;p&gt;Note: in reality I had many problems getting &lt;code&gt;mvn deploy&lt;/code&gt; to work, because I have not really been using maven, I have only been using &lt;code&gt;pom.xml&lt;/code&gt; files to describe my projects and then letting IntelliJ IDEA handle everything else, and it turns out that IntelliJ IDEA is a lot smarter and a lot more forgiving than maven is. My &lt;code&gt;pom.xml&lt;/code&gt; files needed a lot of re-working to get them to actually work with maven. But that's a different story.&lt;/p&gt;
&lt;h4 id="setting-up-the-cicd-provider"&gt;Setting up the CI/CD Provider
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Go to &lt;a class="external"
href="https://circleci.com" target="_blank"
&gt;CircleCI&lt;/a&gt; and create a free account.&lt;/li&gt;
&lt;li&gt;Go to &amp;quot;Organization Settings&amp;quot; -&amp;gt; &amp;quot;Contexts&amp;quot; and create a new context; let's call it &lt;code&gt;my-context&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Add an environment variable to the context with name &lt;code&gt;REPSY_PASS&lt;/code&gt; and the value being the password of the Repsy repository.
&lt;ul&gt;
&lt;li&gt;This way, our scripts will later have access to our Repsy password without us having to include it in any publicly visible source code. CircleCI promises to take extra measures to make sure that environment variables specified via contexts are never exposed to prying eyes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Create a CircleCI project which will correspond to one of our source repositories. The source repository in this case will be &lt;code&gt;bytecode-dump&lt;/code&gt;, so the CircleCI project will also be named &lt;code&gt;bytecode-dump&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;As soon as we have created our project, CircleCI slaps us with their configuration editor, which they must think is very cool, and prevents us from going any further. We are not going to bother with it, because it is quite unhelpful, so:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Click the &amp;quot;Use Existing Config&amp;quot; button.
&lt;ul&gt;
&lt;li&gt;A dialog will pop up saying &amp;quot;Have you added a config.yml file?&amp;quot; and offering a couple of vague options that both seem to be dead ends. You might think you are stuck, but fear not and proceed to the next step.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Select the &amp;quot;Start building&amp;quot; option.
&lt;ul&gt;
&lt;li&gt;CircleCI will complain that there is no configuration, but that's okay, we will take care of it later. At least we can now access the project settings.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Go to &amp;quot;Project Settings&amp;quot; -&amp;gt; &amp;quot;SSH Keys&amp;quot; -&amp;gt; &amp;quot;Checkout SSH Keys&amp;quot;.
&lt;ul&gt;
&lt;li&gt;This is not about checking out any SSH keys, this is about specifying keys for CircleCI to be able to checkout.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Click &amp;quot;Add Key&amp;quot;.
&lt;ul&gt;
&lt;li&gt;You might think that you then need to do something with this key, but actually you don't. If you allow a few seconds to pass for the systems to do their magic, and then go to your project on GitHub -&amp;gt; &amp;quot;Security&amp;quot; -&amp;gt; &amp;quot;Settings&amp;quot; -&amp;gt; &amp;quot;Deploy Keys&amp;quot;, you will see that a key will be there, (which though looks entirely different from what CircleCI shows,) and GitHub will say that this key has been added by CircleCI with authorization from you. Whatever. Magic.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="completing-the-configuration"&gt;Completing the configuration
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Back in our local development environment, in the root directory of our source repository (same level as the &lt;code&gt;pom.xml&lt;/code&gt; or parent &lt;code&gt;pom.xml&lt;/code&gt;) create a folder called &lt;code&gt;.circleci&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In the &lt;code&gt;.circleci&lt;/code&gt; folder add a file called &lt;code&gt;mvn-settings.xml&lt;/code&gt; with the following content:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;&amp;lt;settings&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;servers&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;server&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;repsy-mikenakis-public&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;username&amp;gt;&lt;/span&gt;mikenakis&lt;span class="nt"&gt;&amp;lt;/username&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;password&amp;gt;&lt;/span&gt;${REPSY\_PASS}&lt;span class="nt"&gt;&amp;lt;/password&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;/server&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;/servers&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;&amp;lt;/settings&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;In the &lt;code&gt;.circleci&lt;/code&gt; folder also add a file called &lt;code&gt;config.yml&lt;/code&gt; with the following content:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-yml" data-lang="yml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2.1&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;workflows&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;my-workflow&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;jobs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;- &lt;span class="nt"&gt;build&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;context&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;my-context&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;jobs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;build&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;docker&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;- &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;cimg/openjdk:15.0.1&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;steps&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;- &lt;span class="l"&gt;checkout&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;- &lt;span class="nt"&gt;run&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;mvn -s .circleci/mvn-settings.xml clean&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;- &lt;span class="nt"&gt;run&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;mvn -s .circleci/mvn-settings.xml install&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;- &lt;span class="nt"&gt;run&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;mvn -s .circleci/mvn-settings.xml deploy&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Note that we are supposed to add some additional notation to achieve caching of our maven dependencies, so that they are not all fetched from scratch each time the CI/CD build pipeline runs, but:
&lt;ul&gt;
&lt;li&gt;I have not found a definitive description of how to do this;&lt;/li&gt;
&lt;li&gt;A magical incantation that I found somewhere initially seemed to work, but then later it caused problems, so I ditched it, and&lt;/li&gt;
&lt;li&gt;CircleCI should really be automating this in a way which is totally transparent to us.
So, for now caching will need to wait.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If OpenJDK 15 does not suit you, then you will need to find another docker image, CircleCI has many available. I later switched to JDK 16 with no problems.&lt;/li&gt;
&lt;li&gt;There are 3 separate maven goals so that the &lt;code&gt;clean&lt;/code&gt; goal can be easily commented out, and so that if the &lt;code&gt;install&lt;/code&gt; goal fails then the &lt;code&gt;deploy&lt;/code&gt; goal will not be executed at all. (Otherwise, rumor has it that you might get partial deployments.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="firing-it-up"&gt;Firing it up
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Commit and push to GitHub.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once these files have been committed to GitHub, CircleCI will take notice, and it will run our CI/CD pipeline. Do not expect it to run successfully on the first try; there will be errors, and there will be trouble. But once you get it to work successfully, it will be worth the trouble.&lt;/p&gt;</description></item><item><title>GitHub project: mikenakis-classdump</title><link>https://blog.michael.gr/post/2018-04-github-project-classdump/</link><pubDate>Sat, 07 Apr 2018 21:28:50 +0000</pubDate><guid>https://blog.michael.gr/post/2018-04-github-project-classdump/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2018-04-github-project-classdump/media/mikenakis-classdump-512.png"
width="512"
height="512"
loading="lazy"
class="gallery-image"
data-flex-grow="100"
data-flex-basis="240px"
&gt;
&lt;/p&gt;
&lt;p&gt;A command-line utility for dumping the contents of class files.&lt;/p&gt;
&lt;p&gt;Read the README.md file at &lt;a class="external"
href="https://github.com/mikenakis/Public/tree/master/classdump" target="_blank"
&gt;https://github.com/mikenakis/Public/tree/master/classdump&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cover image: The &lt;code&gt;mikenakis-classdump&lt;/code&gt; logo. Based on an image found on the interwebz.&lt;/p&gt;</description></item><item><title>Migrating a project from java 8 to java 9</title><link>https://blog.michael.gr/post/2017-10-migrating-project-from-java-8-to-java-9/</link><pubDate>Sat, 30 Sep 2017 20:27:45 +0000</pubDate><guid>https://blog.michael.gr/post/2017-10-migrating-project-from-java-8-to-java-9/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2017-10-migrating-project-from-java-8-to-java-9/media/Java9-migration.png"
width="700"
height="400"
loading="lazy"
class="gallery-image"
data-flex-grow="175"
data-flex-basis="420px"
&gt;
&lt;/p&gt;
&lt;p&gt;Now that Java 9 is out, I decided to migrate to it my pet project, which is around 120K lines of java.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The first step is to just start compiling and running against jdk9, without using any of its features yet.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is an account of the surprisingly few issues that I encountered during this first step and how I resolved them.&lt;/p&gt;
&lt;h4 id="issue-1-objectfinalize-has-been-deprecated"&gt;Issue #1: Object.finalize() has been deprecated.
&lt;/h4&gt;&lt;p&gt;The javadoc of Object.finalize() explains why it has been deprecated and suggests the use of java.lang.ref.Cleaner and java.lang.ref.PhantomReference as alternatives.&lt;/p&gt;
&lt;p&gt;Solution: For now, an acceptable solution is to just mark any overrides of Object.finalize() as also deprecated, so that no warnings are issued.&lt;/p&gt;
&lt;h4 id="issue-2-accessibleobjectisaccessible-has-been-deprecated"&gt;Issue #2: AccessibleObject.isAccessible() has been deprecated.
&lt;/h4&gt;&lt;p&gt;This means that method.isAccessible() and field.isAccessible() should not be used anymore.&lt;/p&gt;
&lt;p&gt;Solution:&lt;/p&gt;
&lt;p&gt;Replace this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object callMethod( Object instance, Method method )
{
boolean access = method.isAccessible();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object callMethod( Object instance, Method method )
{
boolean access = method.canAccess( instance );
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="issue-3-comsunxmlinternalstreamxmlinputfactoryimpl-is-not-visible-anymore"&gt;Issue #3: com.sun.xml.internal.stream.XMLInputFactoryImpl is not visible anymore.
&lt;/h4&gt;&lt;p&gt;Solution:&lt;/p&gt;
&lt;p&gt;Replace this:&lt;/p&gt;
&lt;p&gt;XMLInputFactory xmlInputFactory = new XMLInputFactoryImpl();&lt;/p&gt;
&lt;p&gt;with this:&lt;/p&gt;
&lt;p&gt;XMLInputFactory xmlInputFactory = XMLInputFactory.newDefaultFactory();&lt;/p&gt;
&lt;h4 id="issue-4-classnewinstance-has-been-deprecated"&gt;Issue #4: Class.newInstance() has been deprecated.
&lt;/h4&gt;&lt;p&gt;Solution:&lt;/p&gt;
&lt;p&gt;Replace this:&lt;/p&gt;
&lt;p&gt;Class.forName( &amp;quot;com.mysql.jdbc.Driver&amp;quot; ).newInstance();&lt;/p&gt;
&lt;p&gt;with this:&lt;/p&gt;
&lt;p&gt;Class.forName( &amp;quot;com.mysql.jdbc.Driver&amp;quot; ).getDeclaredConstructor().newInstance();&lt;/p&gt;
&lt;h4 id="issue-5-comsunniofileextendedopenoption-does-not-exist-anymore"&gt;Issue #5: com.sun.nio.file.ExtendedOpenOption does not exist anymore.
&lt;/h4&gt;&lt;p&gt;I was making use of ExtendedOpenOption.NOSHARE_WRITE, but the ExtendedOpenOption enum has now been moved into some module called jdk.unsupported and even though IntelliJ IDEA somehow does see the type, the compiler does not see it.&lt;/p&gt;
&lt;p&gt;Solution:&lt;/p&gt;
&lt;p&gt;Stop using com.sun.nio.file.ExtendedOpenOption. I wish I knew of an alternative.&lt;/p&gt;
&lt;h4 id="issue-6-the-java-compiler-now-resolves-symbolic-links-of-source-files"&gt;Issue #6 The java compiler now resolves symbolic links of source files
&lt;/h4&gt;&lt;p&gt;This is a problem for me, because I have all my projects in C:\Users\Michael\Projects, but this is actually a link to D:\Michael\Docs\Projects, which I normally never touch. This has been working fine for years, but now with java 9 when an error occurs in a source file, javac reports the error using the resolved source pathname, which is on drive D:, and this completely confuses the IDE which does not know of any source file with that pathname.&lt;/p&gt;
&lt;p&gt;Solution:&lt;/p&gt;
&lt;p&gt;Abandon the practice of accessing the project from a path which contains a symbolic link, work on the project in its actual location.&lt;/p&gt;
&lt;h4 id="issue-7-classloadergetsystemclassloader-cannot-be-cast-to-urlclassloader-anymore"&gt;Issue #7 ClassLoader.getSystemClassLoader() cannot be cast to URLClassLoader anymore.
&lt;/h4&gt;&lt;p&gt;This was definitely to be expected.&lt;/p&gt;
&lt;p&gt;Solution:&lt;/p&gt;
&lt;p&gt;Replace this:&lt;/p&gt;
&lt;p&gt;URLClassLoader urlClassLoader = (URLClassLoader)ClassLoader.getSystemClassLoader();
for( URL url : urlClassLoader.getURLs() ) { ...&lt;/p&gt;
&lt;p&gt;with this:&lt;/p&gt;
&lt;p&gt;ClassLoader classLoader = ClassLoader.getSystemClassLoader();
for( URL url : Collections.list( classLoader.getResources( &amp;quot;&amp;quot; ) ) ) { ...&lt;/p&gt;
&lt;h4 id="issue-8-jackson-fails-to-deserialize-exceptions-from-json"&gt;Issue #8 Jackson fails to deserialize exceptions from JSON.
&lt;/h4&gt;&lt;p&gt;For debugging purposes, I used to have exceptions serialized into JSON and deserialized later. For some unknown reason, this does not work anymore. Now each element of the stackTrace contains several additional fields, like classLoaderName, moduleName and moduleVersion, and although Jackson serializes them just fine, for some reason it fails to deserialize them. Upgrading to the latest version of jackson-jaxrs-json-provider (version 2.9.0) did not fix this problem.&lt;/p&gt;
&lt;p&gt;Solution: stop serializing and deserializing exceptions.&lt;/p&gt;
&lt;p&gt;At the end of all this, my 817 tests passed, so I consider the migration complete.&lt;/p&gt;</description></item></channel></rss>