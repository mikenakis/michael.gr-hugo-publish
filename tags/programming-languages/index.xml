<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming languages on Michael's Blog</title><link>https://blog.michael.gr/tags/programming-languages/</link><description>Recent content in Programming languages on Michael's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Michael Belivanakis (a.k.a. Mike Nakis)</copyright><lastBuildDate>Wed, 21 Jan 2026 10:28:27 +0100</lastBuildDate><atom:link href="https://blog.michael.gr/tags/programming-languages/index.xml" rel="self" type="application/rss+xml"/><item><title>On messages and message-passing</title><link>https://blog.michael.gr/post/2022-12-messages-and-message-passing/</link><pubDate>Sun, 18 Dec 2022 08:59:25 +0000</pubDate><guid>https://blog.michael.gr/post/2022-12-messages-and-message-passing/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2022-12-messages-and-message-passing/media/message-passing.png"
width="2673"
height="1494"
loading="lazy"
class="gallery-image"
data-flex-grow="178"
data-flex-basis="429px"
&gt;
&lt;/p&gt;
&lt;p&gt;Over the decades, numerous software system architectures have emerged which require invocations across subsystems to be done via message-passing instead of programmatic interface method calls. Such architectures are so common that many programmers have come to regard message-passing as an end in and of itself, oblivious of the fact that it is nothing but a (poor) technical mechanism for accomplishing a certain architectural goal.&lt;/p&gt;
&lt;p&gt;(Useful pre-reading: &lt;a
href="https://blog.michael.gr/post/2022-11-about-these-papers/"
&gt;About these papers&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;The architectural goal is to be able to perform general-purpose operations on invocations, for example routing the invocations according to configuration, or queuing the invocations for delivery on a different thread. In order to be able to do things like that, the invocations must first be expressed in a general-purpose form.&lt;/p&gt;
&lt;p&gt;Message-passing is simply the only general-purpose form that could be imagined by the pioneers who built the first asynchronous event-driven systems, or perhaps the only form that could readily be implemented using the programming languages available back then. However, in succeeding decades our thinking and our tools have advanced considerably, to the point where we now have much better ways of achieving things technically, so it might be worth taking a moment to re-examine the concept of message-passing.&lt;/p&gt;
&lt;p&gt;Here is a list of problems with message passing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Custom message classes have to be written and maintained, usually in large numbers, constituting nothing but incidental complexity which steers focus away from the class hierarchy of the problem domain, and towards the class hierarchy of the overelaborate inter-module communication apparatus.&lt;/li&gt;
&lt;li&gt;For each invocation, a message class needs to be instantiated, filled, and submitted, requiring several lines of custom-written code. This is also nothing but incidental complexity, diverting the attention of programmers from solving the problem at hand to negotiating the trifling technicalities of placing invocations.&lt;/li&gt;
&lt;li&gt;On the receiving end, each message must be examined in order to determine what kind of message it is, usually by means of an unwieldy switch statement, and its contents have to be extracted before any useful work can be done. Again, this is all incidental complexity, contributing nothing towards the end-goal of the software system; its sole purpose is to serve the message-passing bureaucracy.&lt;/li&gt;
&lt;li&gt;In order to reduce the total number of different message classes that need to be defined, programmers often reuse message classes for different purposes, filling different parts according to each purpose. This habit further increases the total amount of incidental complexity both at the sending and at the receiving end, and very often leads to bugs due to wrongly packed or wrongly unpacked messages.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, message-passing exists for the sole purpose of expressing invocations in a general-purpose form, but as it turns out, its use is laborious, and it tends to flood systems with debilitating amounts of incidental complexity.&lt;/p&gt;
&lt;p&gt;The most natural, simple, convenient, straightforward, robust, maintainable, and self-documenting paradigm for making and receiving invocations, which facilitates problem-solving instead of hindering it, is programmatic interface method calls. Unfortunately, interfaces are not general-purpose in and of themselves, because each interface constitutes a unique type, requiring custom-written code to place calls to it and custom-written code to receive calls for it, thus preventing us from applying general-purpose operations on it. So, we have two separate and seemingly conflicting concerns:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How to express invocations in the most convenient way&lt;/li&gt;
&lt;li&gt;How to perform general-purpose operations on the invocations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ideally, separate concerns should not be mixed; the need to somehow apply general-purpose operations on invocations should not be dictating how we write code, and it should certainly not be making our job harder. Therein lies perhaps the biggest objection to message-passing: they are an onerous contrivance that programmers by themselves would never opt to use out of their own free will, but usually gets imposed on them by software architects who do not actually have to write code using this contrivance.&lt;/p&gt;
&lt;p&gt;Message-passing has enjoyed widespread use mainly due to the historical inability of application programmers to think in terms of abstractions: it is always possible, even in systems that require message-passing, to write all application code so that it never deals with any messages at all, and uses nothing but application-specific programmatic interfaces instead; the trick is to create packaging and unpackaging adaptors, where on the sending side we are simply invoking a programmatic interface which is implemented by a packaging adaptor that creates messages, packs them, and sends them off to be enqueued, while on the receiving side a corresponding unpackaging adaptor is fed with messages from the queue, unpacks them, and calls the corresponding implementation of the interface. Alas, this arrangement requires a modicum of abstract thinking, and application programmers are generally not into that sort of thing.&lt;/p&gt;
&lt;p&gt;Furthermore, if we bother creating such packaging and unpackaging adaptors, the realization quickly starts to sink-in that all the message classes are irrelevant; there is no need to define a special message class containing a separate field for each parameter of each method, because the only code that would ever deal with such a class would be the corresponding pair of packaging and unpackaging adaptors; so, the adaptors might as well use a single universal message class which simply stores all parameters in an array of object, and voila, the entire menagerie of message classes becomes entirely unnecessary.&lt;/p&gt;
&lt;p&gt;Thus, it becomes evident that what we are really after is not message-passing per se; it is some general-purpose form of expressing invocations, so that general-purpose operations can be performed on them, and some mechanism for converting back and forth between this general-purpose form and the natural form, which is programmatic interface method calls, so that we can write code naturally. Ideally, the conversion mechanism would be automatic and transparent, so that we do not even have to write those adaptors. Messages have only existed due to the historical absence of such an automatic and transparent mechanism.&lt;/p&gt;
&lt;p&gt;Fortunately, with modern reflecting, intermediate-code-based, just-in-time compiled programming languages, today we have at our disposal all that is necessary to build such mechanisms. For more information see &lt;a
href="https://blog.michael.gr/post/2022-12-intertwine/"
&gt;Intertwine&lt;/a&gt;.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center"&gt;&lt;img src="https://blog.michael.gr/post/2022-12-messages-and-message-passing/media/grumpy-cat-message-passing.jpg"
width="493"
height="555"
loading="lazy"
class="gallery-image"
data-flex-grow="88"
data-flex-basis="213px"
&gt;
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center"&gt;Mandatory grumpy cat meme: &amp;quot;Message-Passing: it's awful&amp;quot; by michael.gr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;Cover image: Conceptual illustration of message-passing, by michael.gr, based on original art by Youmena and Made from the Noun Project.&lt;/p&gt;</description></item><item><title>Intertwine</title><link>https://blog.michael.gr/post/2022-12-intertwine/</link><pubDate>Sun, 11 Dec 2022 16:18:00 +0000</pubDate><guid>https://blog.michael.gr/post/2022-12-intertwine/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2022-12-intertwine/media/intertwine-logo.svg"
loading="lazy"
&gt;
&lt;/p&gt;
&lt;h3 id="abstract"&gt;Abstract
&lt;/h3&gt;&lt;p&gt;A mechanism is described for automatically converting method invocations of any programmatic interface into a single-method &lt;em&gt;&lt;strong&gt;normal form&lt;/strong&gt;&lt;/em&gt; and converting back to invocations of the original interface, so that general-purpose operations can be performed on the normal form without explicit knowledge of the interface being invoked. Implementations are provided for C# and for Java.&lt;/p&gt;
&lt;p&gt;(Useful pre-reading: &lt;a
href="https://blog.michael.gr/post/2022-11-about-these-papers/"
&gt;About these papers&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id="the-problem"&gt;The Problem
&lt;/h3&gt;&lt;p&gt;When creating software systems of nontrivial complexity we often need to be able to apply certain operations on the invocations that are being made between certain components. Examples of such operations are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Logging:&lt;/strong&gt; Recording information about each invocation being made.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multicasting:&lt;/strong&gt; Delivering a single invocation to multiple recipients.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Remoting:&lt;/strong&gt; Placing invocations across machine boundaries.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Desynchronization:&lt;/strong&gt; Queuing invocations for later execution, possibly on a different thread.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Synchronization:&lt;/strong&gt; Obtaining and holding a lock for the duration of the invocation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transformation:&lt;/strong&gt; Converting between invocation formats, e.g. method calls to REST and back.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ordinarily, the components doing the invocations are application-specific, and the interfaces between them are also application-specific, but the operators that we want to interject between them are general-purpose, so they need to remain agnostic of the application-specific details of the invocations, in a way analogous to how a general-purpose sorting algorithm is agnostic of the application-specific format of the data it sorts.&lt;/p&gt;
&lt;p&gt;Therefore, we need some way of expressing application-specific invocations in a general-purpose form.&lt;/p&gt;
&lt;h3 id="prior-art"&gt;Prior Art
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Messages and message-passing:&lt;/strong&gt; The mechanism historically used for expressing invocations in a general-purpose form is message-passing. Unfortunately, its use is laborious, and it floods systems with debilitating amounts of incidental complexity. For details, see &lt;a
href="https://blog.michael.gr/post/2022-12-messages-and-message-passing/"
&gt;On messages and message-passing&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Parameterless lambdas:&lt;/strong&gt; Application-specific method calls can be wrapped inside parameterless lambdas, and since all parameterless lambdas look the same, they can be handled by general-purpose code which may for example add them to a queue, and later dequeue and invoke them.
Unfortunately:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The wrapping of each application-specific method call inside a parameterless lambda must happen at each call site, which is cumbersome and reveals details about the underlying invocation delivery mechanism.&lt;/li&gt;
&lt;li&gt;The evaluation of the parameters that are passed to the application-specific method happens at the moment that the lambda makes the call, not at the moment that the lambda is constructed, which can lead to insidious bugs even if the evaluations have no side-effects. (And &lt;em&gt;woe to you on earth and sea&lt;/em&gt; if they do have side-effects.)&lt;/li&gt;
&lt;li&gt;The parameterless lambda completely hides the values of the parameters that are being passed to the application-specific method, as well as the identity of the method being invoked. Thus, parameterless lambdas cannot be used in scenarios that require information about each call being made.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Dynamic Proxies:&lt;/strong&gt; Both in Java and in C# there exist mechanisms that can be used to convert application-specific invocations to a general-purpose form, but not the other way around. These are &lt;code&gt;java.lang.reflect.Proxy&lt;/code&gt; for Java, and various libraries like Castle's and LinFu for C#. The reverse operation can be achieved using reflection, but this involves a round-trip to native-land, which incurs a heavy performance penalty. Furthermore, these mechanisms suffer from additional issues, such as messing with exceptions, doing more work than necessary, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="the-solution"&gt;The Solution
&lt;/h3&gt;&lt;p&gt;In order to be able to perform general-purpose operations on application-specific invocations we need a mechanism for converting application-specific invocations into a general-purpose form and back, so that the operators can act upon the general-purpose form. What follows is a description of such a mechanism, which I call &lt;em&gt;&lt;strong&gt;Intertwine&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Intertwine introduces a general-purpose form for expressing invocations, which is called &lt;em&gt;&lt;strong&gt;the normal form of invocations&lt;/strong&gt;&lt;/em&gt;, and is represented by a single method of the following signature:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;MethodKey&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;In C#, &lt;code&gt;AnyCall&lt;/code&gt; would be a &lt;em&gt;delegate.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;In Java, &lt;code&gt;AnyCall&lt;/code&gt; would be a &lt;em&gt;single-method interface&lt;/em&gt;, otherwise known as a &lt;em&gt;functional interface&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This method signature represents the fact that every conceivable interface method call can be fully described in terms of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A return value, of the common denominator type &lt;code&gt;Object&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A unique key which identifies which method of the interface is being invoked.&lt;/li&gt;
&lt;li&gt;An array containing arguments, of the common denominator type &lt;code&gt;Object&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Please note that the method identifier is &lt;code&gt;MethodKey&lt;/code&gt; in the Java implementation, but &lt;code&gt;int selector&lt;/code&gt; in the C# implementation. This is because the Java implementation was made a considerable time after the C# implementation, and is therefore a bit more advanced.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;MethodKey&lt;/code&gt; used in the Java implementation allows the caller and the callee to unambiguously identify methods even in situations where binary compatibility between the caller and the callee is not guaranteed, and therefore an integer method index does not necessarily refer to the same method on both the caller and the callee.&lt;/p&gt;
&lt;p&gt;The Java implementation of intertwine provides efficient means of converting back and forth between a &lt;code&gt;MethodKey&lt;/code&gt; and any of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The reflection &amp;quot;Method&amp;quot; object of the method. (This is &lt;code&gt;java.lang.reflect.Method&lt;/code&gt; in Java, or &lt;code&gt;System.Reflection.MethodInfo&lt;/code&gt; in C#.)&lt;/li&gt;
&lt;li&gt;The string representation of the prototype of the method.&lt;/li&gt;
&lt;li&gt;The zero-based method index of the method.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The sample code that follows was written for C#, so it uses an &lt;code&gt;int selector&lt;/code&gt; instead of &lt;code&gt;MethodKey key&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For methods of &lt;code&gt;void&lt;/code&gt; return type the value returned by AnyCall is unspecified. (It will in all likelihood be &lt;code&gt;null&lt;/code&gt;, but nobody should rely on this.)&lt;/li&gt;
&lt;li&gt;Value types (primitives) are boxed and unboxed as necessary.&lt;/li&gt;
&lt;li&gt;Certain features such as the &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; parameters in C#, receive special handling.&lt;/li&gt;
&lt;li&gt;Other features such as properties, indexers, virtual events, etc. are nothing but syntactic sugar which is implemented using regular method calls under the hood, so they require no special handling.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, the problem can now be restated as follows:&lt;/p&gt;
&lt;p&gt;How to convert any interface method invocation to an invocation of an AnyCall method, and how to convert back from an invocation of an AnyCall method to an invocation of the original interface method.&lt;/p&gt;
&lt;p&gt;For this, Intertwine introduces two new concepts: &lt;em&gt;&lt;strong&gt;Entwiners&lt;/strong&gt;&lt;/em&gt; and &lt;em&gt;&lt;strong&gt;Untwiners&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An Entwiner of interface &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; is a class which exposes (implements) interface &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; and delegates to an instance of &lt;em&gt;AnyCall&lt;/em&gt;. It can also be thought of as a &lt;em&gt;normalizer&lt;/em&gt; or &lt;em&gt;generalizer&lt;/em&gt; or &lt;em&gt;multiplexer.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;An Untwiner of interface &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; is a class which exposes an &lt;em&gt;AnyCall&lt;/em&gt; method and delegates to an instance of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt;. It can also be thought of as a &lt;em&gt;denormalizer&lt;/em&gt; or &lt;em&gt;specializer&lt;/em&gt; or &lt;em&gt;demultiplexer.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;More specifically:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The entwiner of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; does the following:
&lt;ul&gt;
&lt;li&gt;Accepts an instance of &lt;code&gt;Anycall&lt;/code&gt; as a constructor parameter and stores it in a &lt;code&gt;final&lt;/code&gt;/&lt;code&gt;readonly&lt;/code&gt; field.&lt;/li&gt;
&lt;li&gt;Implements each method of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; as follows:
&lt;ul&gt;
&lt;li&gt;Packs the parameters that were passed to the method into an array of &lt;code&gt;Object&lt;/code&gt;, performing any boxing necessary.&lt;/li&gt;
&lt;li&gt;Invokes anyCall passing it a key that uniquely identifies the method, and the array of parameters.&lt;/li&gt;
&lt;li&gt;Returns, possibly after unboxing, whatever was returned by the invocation of anyCall.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The untwiner of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; performs the opposite and complementary operation of the entwiner, namely:
&lt;ul&gt;
&lt;li&gt;Accepts an instance of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; as a constructor parameter and stores it in a &lt;code&gt;final&lt;/code&gt;/&lt;code&gt;readonly&lt;/code&gt; field.&lt;/li&gt;
&lt;li&gt;Implements the &lt;code&gt;anycall&lt;/code&gt; method of the &lt;code&gt;Anycall&lt;/code&gt; interface as follows:&lt;/li&gt;
&lt;li&gt;It uses the supplied &lt;code&gt;MethodKey&lt;/code&gt; to determine which method of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt; is being invoked, and for each method it does the
following:
&lt;ul&gt;
&lt;li&gt;Unpacks the parameters from the array of &lt;code&gt;Object&lt;/code&gt;, performing any unboxing necessary.&lt;/li&gt;
&lt;li&gt;Invokes the method of &lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt;, passing it the unpacked parameters.&lt;/li&gt;
&lt;li&gt;Returns, possibly after boxing, whatever was returned by the method, or &lt;code&gt;null&lt;/code&gt; if the method was of &lt;code&gt;void&lt;/code&gt; return type.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="a-hand-crafted-implementation"&gt;A hand-crafted implementation
&lt;/h3&gt;&lt;p&gt;Before we look at the automatic creation of entwiners and untwiners, let us take a look at an example of how we would implement an entwiner and untwiner for a certain interface if we were to do it by hand.&lt;/p&gt;
&lt;p&gt;Let us consider the following interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-3"&gt;&lt;a class="lnlinks" href="#hl-1-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-4"&gt;&lt;a class="lnlinks" href="#hl-1-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-5"&gt;&lt;a class="lnlinks" href="#hl-1-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;IFooable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Moo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Boo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;And let us consider the following class implementing that interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-2-1"&gt;&lt;a class="lnlinks" href="#hl-2-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-2"&gt;&lt;a class="lnlinks" href="#hl-2-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-3"&gt;&lt;a class="lnlinks" href="#hl-2-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-4"&gt;&lt;a class="lnlinks" href="#hl-2-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-5"&gt;&lt;a class="lnlinks" href="#hl-2-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;FooImplementation&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Moo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;Console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WriteLine&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;i: &amp;#34;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Boo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;Console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WriteLine&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;s: &amp;#34;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;, b: &amp;#34;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;And then let us consider the following method which invokes the interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-3-1"&gt;&lt;a class="lnlinks" href="#hl-3-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-2"&gt;&lt;a class="lnlinks" href="#hl-3-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-3"&gt;&lt;a class="lnlinks" href="#hl-3-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-4"&gt;&lt;a class="lnlinks" href="#hl-3-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-5"&gt;&lt;a class="lnlinks" href="#hl-3-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;InvokeFoo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;fooable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Moo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="m"&gt;42&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;fooable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Boo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;fubar!&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The InvokeFoo method can be directly hooked up to an instance of the implementing class in a completely conventional way as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-4-1"&gt;&lt;a class="lnlinks" href="#hl-4-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-4-2"&gt;&lt;a class="lnlinks" href="#hl-4-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-4-3"&gt;&lt;a class="lnlinks" href="#hl-4-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-4-4"&gt;&lt;a class="lnlinks" href="#hl-4-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-4-5"&gt;&lt;a class="lnlinks" href="#hl-4-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Run1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FooImplementation&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;InvokeFoo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Now, an entwiner for our IFooable interface could be hand-crafted as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-5-1"&gt;&lt;a class="lnlinks" href="#hl-5-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-5-2"&gt;&lt;a class="lnlinks" href="#hl-5-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-5-3"&gt;&lt;a class="lnlinks" href="#hl-5-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-5-4"&gt;&lt;a class="lnlinks" href="#hl-5-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-5-5"&gt;&lt;a class="lnlinks" href="#hl-5-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-5-6"&gt;&lt;a class="lnlinks" href="#hl-5-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-5-7"&gt;&lt;a class="lnlinks" href="#hl-5-7"&gt;7&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;EntwinerForFooable&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="k"&gt;readonly&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Constructor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="n"&gt;anycall&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;anycall&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Moo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt;&lt;span class="p"&gt;[]{&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Boo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt;&lt;span class="p"&gt;[]{&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Whereas an untwiner for IFooable could be hand-crafted as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-6-1"&gt;&lt;a class="lnlinks" href="#hl-6-1"&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-2"&gt;&lt;a class="lnlinks" href="#hl-6-2"&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-3"&gt;&lt;a class="lnlinks" href="#hl-6-3"&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-4"&gt;&lt;a class="lnlinks" href="#hl-6-4"&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-5"&gt;&lt;a class="lnlinks" href="#hl-6-5"&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-6"&gt;&lt;a class="lnlinks" href="#hl-6-6"&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-7"&gt;&lt;a class="lnlinks" href="#hl-6-7"&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-8"&gt;&lt;a class="lnlinks" href="#hl-6-8"&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-9"&gt;&lt;a class="lnlinks" href="#hl-6-9"&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-10"&gt;&lt;a class="lnlinks" href="#hl-6-10"&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-11"&gt;&lt;a class="lnlinks" href="#hl-6-11"&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-12"&gt;&lt;a class="lnlinks" href="#hl-6-12"&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-13"&gt;&lt;a class="lnlinks" href="#hl-6-13"&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-14"&gt;&lt;a class="lnlinks" href="#hl-6-14"&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-6-15"&gt;&lt;a class="lnlinks" href="#hl-6-15"&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UntwinerForFooable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="k"&gt;readonly&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Constructor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;Target&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;selector&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Moo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Boo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InvalidOperationException&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;With the above classes, we can now write the following piece of awesomeness:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-7-1"&gt;&lt;a class="lnlinks" href="#hl-7-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-7-2"&gt;&lt;a class="lnlinks" href="#hl-7-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-7-3"&gt;&lt;a class="lnlinks" href="#hl-7-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-7-4"&gt;&lt;a class="lnlinks" href="#hl-7-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-7-5"&gt;&lt;a class="lnlinks" href="#hl-7-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-7-6"&gt;&lt;a class="lnlinks" href="#hl-7-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-7-7"&gt;&lt;a class="lnlinks" href="#hl-7-7"&gt;7&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Run2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FooImplementation&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;untwiner&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;UntwinerForFooable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;entwiner&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;EntwinerForFooable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;untwiner&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;InvokeFoo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;entwiner&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Note that &lt;code&gt;Run2()&lt;/code&gt; has exactly the same end-result as &lt;code&gt;Run1()&lt;/code&gt;, but there is a big difference in what goes on under the hood: all outbound interface method calls from the &lt;code&gt;InvokeFoo&lt;/code&gt; function are now arriving at the entwiner, which converts them to &lt;code&gt;AnyCall&lt;/code&gt; invocations, which are then forwarded to the untwiner, which converts them back to &lt;code&gt;IFooable&lt;/code&gt; calls, which are then forwarded to our &lt;code&gt;FooImplementation&lt;/code&gt; object. This means that if we wanted to, we could interject a chain of objects between the entwiner and the untwiner, each one of these objects implementing an &lt;code&gt;AnyCall&lt;/code&gt; delegate and invoking another &lt;code&gt;AnyCall&lt;/code&gt; delegate, thus enabling us to perform any conceivable operation upon those invocations without having any built-in knowledge of the &lt;code&gt;IFooable&lt;/code&gt; interface.&lt;/p&gt;
&lt;p&gt;As the complexity of the interface increases, and as additional subtleties come into the picture, such as parameters passed with ref or out, coding entwiners and untwiners by hand can become very tedious and error-prone, so, obviously, we would like to have it automated.&lt;/p&gt;
&lt;h3 id="automating-it-with-reflection"&gt;Automating it with reflection
&lt;/h3&gt;&lt;p&gt;It is possible to write a general-purpose untwiner that does its job using reflection, but reflection is slow, so the result is going to suffer performance-wise. For the sake of completeness, here is a possible implementation for a general-purpose reflecting untwiner using reflection:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-8-1"&gt;&lt;a class="lnlinks" href="#hl-8-1"&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-2"&gt;&lt;a class="lnlinks" href="#hl-8-2"&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-3"&gt;&lt;a class="lnlinks" href="#hl-8-3"&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-4"&gt;&lt;a class="lnlinks" href="#hl-8-4"&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-5"&gt;&lt;a class="lnlinks" href="#hl-8-5"&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-6"&gt;&lt;a class="lnlinks" href="#hl-8-6"&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-7"&gt;&lt;a class="lnlinks" href="#hl-8-7"&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-8"&gt;&lt;a class="lnlinks" href="#hl-8-8"&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-9"&gt;&lt;a class="lnlinks" href="#hl-8-9"&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-10"&gt;&lt;a class="lnlinks" href="#hl-8-10"&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-11"&gt;&lt;a class="lnlinks" href="#hl-8-11"&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-12"&gt;&lt;a class="lnlinks" href="#hl-8-12"&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-13"&gt;&lt;a class="lnlinks" href="#hl-8-13"&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-14"&gt;&lt;a class="lnlinks" href="#hl-8-14"&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-8-15"&gt;&lt;a class="lnlinks" href="#hl-8-15"&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ReflectingUntwiner&lt;/span&gt; &lt;span class="c1"&gt;//WARNING: SLOW AS MOLASSES&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="k"&gt;readonly&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt; &lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="k"&gt;readonly&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Reflection&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MethodInfo&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;Methodinfos&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Constructor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="n"&gt;twinee&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Target&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Methodinfos&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;twinee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetMethods&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;BindingFlags&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Public&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;BindingFlags&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NonPublic&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="n"&gt;BindingFlags&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Instance&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;object&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Methodinfos&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;Invoke&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Note that untwiner creation could be optimized by caching the MethodInfos of frequently used types, but that's not the problem; the real bottleneck is the &lt;code&gt;MethodInfo.Invoke()&lt;/code&gt; call. If you put a breakpoint on the target and examine the stack, you will see that between the &lt;code&gt;AnyCall&lt;/code&gt; frame and the target frame there will be a managed-to-native transition and a native-to-managed transition, which is something to be avoided at all costs.&lt;/p&gt;
&lt;p&gt;Also note: it is impossible to write a reflecting entwiner.&lt;/p&gt;
&lt;h3 id="automating-it-with-intertwine"&gt;Automating it with Intertwine
&lt;/h3&gt;&lt;p&gt;The Intertwine library will automatically generate for us a pair of optimally-performing entwiner and untwiner classes for any interface. These classes are generated at runtime, so no extra build step is needed. To accomplish this, the C# implementation of Intertwine generates MSIL and creates assemblies from it; the Java Implementation generates bytecode and creates classes from it.&lt;/p&gt;
&lt;p&gt;The following method of the &lt;code&gt;Intertwine.Factory&lt;/code&gt; class creates an entwiner:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;NewEntwiner&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;(&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="n"&gt;anycall&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For &lt;code&gt;T&lt;/code&gt; we give the type of our interface, and for &lt;code&gt;anycall&lt;/code&gt; we give a delegate of ours that will be receiving calls. This method returns a reference to an implementation of our interface, provided by an Entwiner-derived class that has been dynamically generated specifically for our interface, and instantiated to work with the given &lt;code&gt;AnyCall&lt;/code&gt; instance. For every call received through a method of our interface, this special entwiner will be marshalling the arguments and forwarding the call to our &lt;code&gt;AnyCall&lt;/code&gt; delegate.&lt;/p&gt;
&lt;p&gt;The following method of the &lt;code&gt;Intertwine.Factory&lt;/code&gt; class creates an untwiner:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="n"&gt;NewUntwiner&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;(&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For target we give an implementation of our interface, and what we get is a reference to an &lt;code&gt;AnyCall&lt;/code&gt; delegate implemented by an Untwiner-derived class that was dynamically generated specifically for our interface, and instantiated to work with the given target instance. For every call received through the &lt;code&gt;AnyCall&lt;/code&gt; delegate, this special untwiner will be unmarshalling the arguments and forwarding the call to the appropriate method of our target interface.&lt;/p&gt;
&lt;p&gt;So, with the dynamically generated entwiners and untwiners we can now do the following epicness:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-11-1"&gt;&lt;a class="lnlinks" href="#hl-11-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-11-2"&gt;&lt;a class="lnlinks" href="#hl-11-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-11-3"&gt;&lt;a class="lnlinks" href="#hl-11-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-11-4"&gt;&lt;a class="lnlinks" href="#hl-11-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-11-5"&gt;&lt;a class="lnlinks" href="#hl-11-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-11-6"&gt;&lt;a class="lnlinks" href="#hl-11-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-11-7"&gt;&lt;a class="lnlinks" href="#hl-11-7"&gt;7&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Run3&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FooImplementation&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;AnyCall&lt;/span&gt; &lt;span class="n"&gt;untwiner&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Intertwine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Factory&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewUntwiner&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;IFooable&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;(&lt;/span&gt; &lt;span class="n"&gt;fooable&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;IFooable&lt;/span&gt; &lt;span class="n"&gt;entwiner&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Intertwine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Factory&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewEntwiner&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;IFooable&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;(&lt;/span&gt; &lt;span class="n"&gt;untwiner&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;InvokeFoo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;entwiner&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The actual implementation of &lt;code&gt;Intertwine.Factory&lt;/code&gt; is pretty straightforward, so there is not much to talk about. As one might expect, the generated types are cached. A static factory method is generated with each generated type, for instantiating the type, so as to avoid having to call &lt;code&gt;Activator.CreateInstance()&lt;/code&gt;, because that method uses reflection. The static factory method is invoked using &lt;code&gt;Delegate.Invoke()&lt;/code&gt;, which does not use reflection. You will find the code-generating code choke-full of comments, explaining exactly what each emitted opcode does.&lt;/p&gt;
&lt;p&gt;Intertwine for C#:
&lt;a class="external"
href="https://github.com/mikenakis/IntertwineCSharp" target="_blank"
&gt;https://github.com/mikenakis/IntertwineCSharp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Intertwine for Java:
&lt;a class="external"
href="https://github.com/mikenakis/Public/tree/master/intertwine" target="_blank"
&gt;https://github.com/mikenakis/Public/tree/master/intertwine&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="appendix-an-example-interface-multicasts-events-in-c"&gt;Appendix: An example: Interface multicasts (events) in C#
&lt;/h3&gt;&lt;p&gt;If you are still with me you may be thinking that it is about time for a demonstration. What follows is not just an example, but actually a complete and useful application of intertwine which you may be able to start utilizing in your projects right away.&lt;/p&gt;
&lt;p&gt;The C# language has built-in support for multicasts (events) but only delegates can be used as event observers. There are many cases, however, where interfaces would be more suitable. Java does not even have built-in support for multicasts, so programmers generally have to write their own, using single-method (functional) interfaces. In either language, if you want to achieve multicasting on multi-method interfaces, you have to rewrite the multicasting code for every single method of every single interface.&lt;/p&gt;
&lt;p&gt;Consider the following interface:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-12-1"&gt;&lt;a class="lnlinks" href="#hl-12-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-12-2"&gt;&lt;a class="lnlinks" href="#hl-12-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-12-3"&gt;&lt;a class="lnlinks" href="#hl-12-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-12-4"&gt;&lt;a class="lnlinks" href="#hl-12-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-12-5"&gt;&lt;a class="lnlinks" href="#hl-12-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-12-6"&gt;&lt;a class="lnlinks" href="#hl-12-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;ITableNotification&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RowInserted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Fields&lt;/span&gt; &lt;span class="n"&gt;fields&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RowDeleted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RowUpdated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Fields&lt;/span&gt; &lt;span class="n"&gt;fields&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;And consider the following hypothetical (not actually possible) way of using it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-13-1"&gt;&lt;a class="lnlinks" href="#hl-13-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-13-2"&gt;&lt;a class="lnlinks" href="#hl-13-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-13-3"&gt;&lt;a class="lnlinks" href="#hl-13-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;event&lt;/span&gt; &lt;span class="n"&gt;ITableNotification&lt;/span&gt; &lt;span class="n"&gt;tableNotificationEvent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;tableNotificationEvent&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;my_observer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;tableNotificationEvent&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RowUpdated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fields&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The above does not work because events in C# work only with delegates, not with interfaces. However, with Intertwine, the next best thing is actually possible:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-14-1"&gt;&lt;a class="lnlinks" href="#hl-14-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-14-2"&gt;&lt;a class="lnlinks" href="#hl-14-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-14-3"&gt;&lt;a class="lnlinks" href="#hl-14-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CSharp" data-lang="CSharp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;tableNotificationEventManager&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;InterfaceEventManager&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ITableNotifcation&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;tableNotificationEventManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Source&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RegisterObserver&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;my_observer&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;tableNotificationEventManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Trigger&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RowUpdated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fields&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;This approach is self-explanatory, and the amount of code you have to write in order to use it is optimal; you do not need to deal with anything more than what is necessary, and if you ever add a notification, it will be a new interface method, so all existing implementations of that interface will automatically be flagged by the compiler as incomplete. With the help of Intertwine, this event manager is implemented in just 150 lines of code, including extensive comments.&lt;/p&gt;
&lt;h3 id="end-notes"&gt;End-notes
&lt;/h3&gt;&lt;p&gt;Back in 2011 I posted a question on stackoverflow.com, titled &lt;a class="external"
href="https://stackoverflow.com/questions/6154205/multiplexing-interface-method-calls-into-a-single-delegate-and-demultiplexing" target="_blank"
&gt;Multiplexing interface method calls into a single delegate and demultiplexing&lt;/a&gt; asking if anyone knows of anything like Intertwine, but nobody did, so I built it myself.&lt;/p&gt;
&lt;p&gt;This post supersedes the original post from 2011: &lt;a
href="https://blog.michael.gr/post/2011-10-16-intertwine-normalizing-interface/"
&gt;Intertwine: Normalizing Interface Invocations&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Cover image: The Intertwine Logo, by michael.gr&lt;/p&gt;</description></item><item><title>On Visual Programming Languages</title><link>https://blog.michael.gr/post/2022-08-on-visual-programming-languages/</link><pubDate>Tue, 16 Aug 2022 10:48:21 +0000</pubDate><guid>https://blog.michael.gr/post/2022-08-on-visual-programming-languages/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2022-08-on-visual-programming-languages/media/visual-programming-language-logos.png"
width="1930"
height="851"
loading="lazy"
class="gallery-image"
data-flex-grow="226"
data-flex-basis="544px"
&gt;
&lt;/p&gt;
&lt;p&gt;This post is intended as support material for another post of mine; see &lt;a
href="https://blog.michael.gr/post/2023-12-09-authoritative-technical-design/"
&gt;Towards Authoritative Software Design&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The idea of creating software using visual tools has existed ever since the first aspiring programmer was bitterly disillusioned by discovering that programming almost exclusively entails writing lots of little text files containing nothing but boring and cryptic text.&lt;/p&gt;
&lt;p&gt;(Useful pre-reading: &lt;a
href="https://blog.michael.gr/post/2022-11-about-these-papers/"
&gt;About these papers&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Given the relative abundance of people who engage in programming, and the relative scarcity of people who engage in software design, it should come as no surprise that visual software development has largely been regarded as an issue of visual programming rather than an issue of visual software design.&lt;/p&gt;
&lt;p&gt;Thus, there has been a multitude of attempts to create so-called &lt;em&gt;Visual Programming Languages&lt;/em&gt; (&lt;a class="external"
href="https://en.wikipedia.org/wiki/Visual_programming_language" target="_blank"
&gt;see Wikipedia&lt;/a&gt;) such as Snap!, Scratch, EduBlocks, Blockly, etc. where code is expressed not as boring text, but instead as colorful blocks on a canvas.&lt;/p&gt;
&lt;p&gt;The following example is borrowed from &lt;em&gt;Computer Science with Snap!&lt;/em&gt; by Eckart Modrow from University of Goettingen, 2018.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2022-08-on-visual-programming-languages/media/snap.png"
width="482"
height="476"
loading="lazy"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="243px"
&gt;
&lt;/p&gt;
&lt;p&gt;Unfortunately, the blocks used in these visual programming languages tend to faithfully mirror the structure and concepts of textual code, so even though at first glance the two might seem different, a closer examination reveals that they are actually equivalent: it is still all just variables, expressions, flow control statements, function invocations, and even word-wrapping when an expression is too long to fit in the page; there is no real paradigm shift.&lt;/p&gt;
&lt;p&gt;The usefulness of these languages goes as far as teaching the basic principles of programming to kids, using elements that are colorful and can be manipulated with the mouse, but no further, because as it turns out, code expressed as text is far more expressive, terse, and malleable than blocks.&lt;/p&gt;
&lt;p&gt;(Not to mention, less distracting and less likely to cause epileptic seizures due to excessive application of color.)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Cover image: Logos of various visual programming languages.&lt;/p&gt;</description></item><item><title>What is wrong with Scala</title><link>https://blog.michael.gr/post/2021-10-what-is-wrong-with-scala/</link><pubDate>Mon, 04 Oct 2021 15:39:46 +0000</pubDate><guid>https://blog.michael.gr/post/2021-10-what-is-wrong-with-scala/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2021-10-what-is-wrong-with-scala/media/scala.svg"
loading="lazy"
&gt;
This is part of a series of posts in which I am documenting what is wrong with certain popular programming languages that I am (more or less) familiar with. The aim of these posts is to support a future post in which I will be describing what the ideal programming language would look like for me.&lt;/p&gt;
&lt;p&gt;I will be amending and revising these texts over time.&lt;/p&gt;
&lt;p&gt;(Useful pre-reading: &lt;a
href="https://blog.michael.gr/post/2022-11-about-these-papers/"
&gt;About these papers&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id="what-is-wrong-with-scala"&gt;What is wrong with Scala:
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;The garbage collector.&lt;/li&gt;
&lt;li&gt;Curly braces.&lt;/li&gt;
&lt;li&gt;Functional Nazism
&lt;ul&gt;
&lt;li&gt;It is true that Scala does not suffer from functional Nazism as much as other functional languages, but it still has some entirely unwarranted requirements and limitations that seem to have no purpose other than to hinder imperative programming:
&lt;ul&gt;
&lt;li&gt;Cannot reassign method parameters.&lt;/li&gt;
&lt;li&gt;No for-loop the way we know it.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Functional weirdness
&lt;ul&gt;
&lt;li&gt;Some language idioms may seem entirely natural to functional programming aficionados, but disciples of the imperative school tend to find them rather upsetting:
&lt;ul&gt;
&lt;li&gt;The ability to return the last evaluated value without an explicit return statement sometimes makes it hard to tell what will actually be returned by a function.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Incredibly complex syntax
&lt;ul&gt;
&lt;li&gt;Results in torturously slow compilation.&lt;/li&gt;
&lt;li&gt;&amp;quot;look ma, no semicolons&amp;quot; adds nothing of tangible value, but it does make things very difficult for the compiler.&lt;/li&gt;
&lt;li&gt;A compilation unit often becomes entirely unparseable from top to bottom just because of a single-character syntax error at an unknown place somewhere in it.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Arcane syntax
&lt;ul&gt;
&lt;li&gt;Generics use square brackets instead of angle brackets.&lt;/li&gt;
&lt;li&gt;Ultra-compact generic type bound specifications are probably very convenient for the seasoned Scala programmer, but a severe deterrent for the newcomer.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Companion objects feel entirely superfluous and clunky.&lt;/li&gt;
&lt;li&gt;Inelegant language keywords like &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;val&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Inelegant built-in collection class names like &lt;code&gt;Seq&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: the above list of disadvantages is kind of short, because I am &lt;em&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;/em&gt; intimately familiar with the language.&lt;/p&gt;
&lt;p&gt;Feedback is more than welcome: you'd be doing me a favor. However, be aware that blogger sometimes eats comments, so be sure to save your text before submitting it. If blogger eats your comment, please e-mail it to me.&lt;/p&gt;</description></item><item><title>What is wrong with C#</title><link>https://blog.michael.gr/post/2021-10-what-is-wrong-with-csharp/</link><pubDate>Mon, 04 Oct 2021 15:25:56 +0000</pubDate><guid>https://blog.michael.gr/post/2021-10-what-is-wrong-with-csharp/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2021-10-what-is-wrong-with-csharp/media/csharp.svg"
loading="lazy"
&gt;
&lt;/p&gt;
&lt;p&gt;This is part of a series of posts in which I am documenting what is wrong with certain popular programming languages that I am (more or less) familiar with. The aim of these posts is to support a future post in which I will be describing what the ideal programming language would look like for me.&lt;/p&gt;
&lt;p&gt;I will be amending and revising these texts over time.&lt;/p&gt;
&lt;p&gt;(Useful pre-reading: &lt;a
href="https://blog.michael.gr/post/2022-11-about-these-papers/"
&gt;About these papers&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id="what-is-wrong-with-c"&gt;What is wrong with C#:
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;The garbage collector.&lt;/li&gt;
&lt;li&gt;Curly braces.&lt;/li&gt;
&lt;li&gt;Member initializers execute in a static context.
&lt;ul&gt;
&lt;li&gt;This is far worse than Java's deficiency of member initializers not having access to constructor parameters; this renders the language almost unusable.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Delegates are superfluous and problematic.
&lt;ul&gt;
&lt;li&gt;They could have been implemented as single-method interfaces, as in Java, thus keeping the language simpler.&lt;/li&gt;
&lt;li&gt;The ability to have an anonymous method implementing a delegate is far less useful than the ability to have an anonymous class implementing an interface.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The built-in collection model is lame:
&lt;ul&gt;
&lt;li&gt;Arrays implement the &lt;code&gt;IList&lt;/code&gt; interface, which might initially seem like a great idea, until you realize that &lt;code&gt;IList&lt;/code&gt; has &lt;code&gt;Add()&lt;/code&gt;, &lt;code&gt;Insert()&lt;/code&gt; and &lt;code&gt;Remove()&lt;/code&gt; methods, which of course cannot be honored by an array.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;IReadOnlyList&lt;/code&gt; interface was added as an afterthought, and it is not a super-interface of &lt;code&gt;IList&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;IReadOnlyList&lt;/code&gt; interface does not have an &lt;code&gt;IndexOf()&lt;/code&gt; method. This poses problems that cannot be solved by adding an extension method, because the object implementing &lt;code&gt;IReadOnlyList&lt;/code&gt; may have its own &lt;code&gt;IEqualityComparator&lt;/code&gt;, which the extension method will be blissfully unaware of.&lt;/li&gt;
&lt;li&gt;Enumerators still have to implement the legacy, non-generic &lt;code&gt;GetEnumerator()&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Fluent style (Linq) is limited to working almost exclusively with &lt;code&gt;IEnumerable&amp;amp;lt;&amp;amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Built-in events are problematic. They are unsuitable as a language feature and should have been left for runtime libraries to implement.
&lt;ul&gt;
&lt;li&gt;If one event handler throws, the rest will not be invoked.&lt;/li&gt;
&lt;li&gt;If one event handler causes another event handler to be removed, the removed event handler will still be invoked.&lt;/li&gt;
&lt;li&gt;An event is a special kind of thing which cannot be passed to a function, not even by reference. (As all properties are.) As a result, you have to always hand-code the addition of a handler to an event, and to also separately hand-code the corresponding removal. It is absolutely impossible to pass an event to a function, along with a handler and a boolean flag specifying whether to add or remove the handler. This makes it impossible to gather all symmetric initialization and cleanup operations in one place, which in turn leads to buggy software.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Extension methods
&lt;ul&gt;
&lt;li&gt;They are a hack.&lt;/li&gt;
&lt;li&gt;They are one of the most calamitously misused features of the language.&lt;/li&gt;
&lt;li&gt;Java has shown how to do this right with default interface methods.&lt;/li&gt;
&lt;li&gt;Allegedly, default interface methods will also come to C#, but it is not like extension methods will ever be removed from the language to undo the harm they have caused.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Parameters declared with &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;Prior to the introduction of tuples, &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; parameters could sometimes come in handy, but only in very rare cases.&lt;/li&gt;
&lt;li&gt;At the same time, they are one of the most misused features of the language.&lt;/li&gt;
&lt;li&gt;Now that tuples are part of the language syntax, parameters by reference are nothing but a liability.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Names of variables poison enclosing scopes.
&lt;ul&gt;
&lt;li&gt;If you declare a local variable inside the curly braces of a &lt;code&gt;for&lt;/code&gt; loop, you are not allowed to declare a variable with the same name after the closing brace of the &lt;code&gt;for&lt;/code&gt; loop. Duh?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No function-local classes.
&lt;ul&gt;
&lt;li&gt;You can have function-local functions, which is awesome, but you cannot have function-local classes. Duh?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The language runtime is shared with other languages like Visual Basic, and some decisions have been made there in favor of Visual Basic.
&lt;ul&gt;
&lt;li&gt;For example, when you dereference a null pointer you do not get a &amp;quot;Null Pointer Exception&amp;quot;, you get an &amp;quot;Object Reference Is Not Set To An Instance Of An Object&amp;quot; exception. (Presumably because the words &amp;quot;Null&amp;quot; and &amp;quot;Pointer&amp;quot; would cause epileptic seizures to Visual Basic programmers.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No compiler-enforced function purity.
&lt;ul&gt;
&lt;li&gt;You cannot somehow declare that a method must be pure and have the compiler enforce that the method, and any overrides of that method, are pure.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No compiler-enforced immutability.
&lt;ul&gt;
&lt;li&gt;You cannot somehow declare and advertise that a class is immutable and have the compiler enforce that the class, and its descendants, are immutable.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Certain things about the runtime are completely bonkers. For example:
&lt;ul&gt;
&lt;li&gt;The notion of a &amp;quot;current directory&amp;quot;, which is a piece of mutable global state that is shared across all threads, and even across all AppDomains within a process. (So much for AppDomain isolation!)&lt;/li&gt;
&lt;li&gt;The behavior of the &lt;code&gt;ThreadAbortException&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;What happens to the process exit code if the dotNet process exits due to an unhandled exception. (See &lt;a class="external"
href="https://stackoverflow.com/q/60729865/773113" target="_blank"
&gt;https://stackoverflow.com/q/60729865/773113&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Collecting a stack trace is a ridiculously slow operation.&lt;/li&gt;
&lt;li&gt;Throwing an exception is a &lt;em&gt;stupendously&lt;/em&gt; slow operation.&lt;/li&gt;
&lt;li&gt;In order to send a file to the recycle bin, everyone suggests that you should include a module called &amp;quot;Microsoft.VisualBasic&amp;quot;. Duh?
&lt;ul&gt;
&lt;li&gt;Adding injury to insult, if you try this, you will discover that it is broken, it just does not work.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No namespace-private visibility
&lt;ul&gt;
&lt;li&gt;C# has always provided assembly-private visibility, which is much more useful than Java's package-private visibility, however at some point Java somewhat fixed that by introducing modules, and the ability to specify which packages are exposed by a module. Now C# lags behind Java in that it does not support namespace-private visibility, which means that everything is visible to everything within an assembly, which can easily lead to chaos if the assembly is large. There is a way to somewhat mitigate this by using partial classes as if they were namespaces, but it is hacky.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Interface method implementations are not tied to the interfaces they implement.
&lt;ul&gt;
&lt;li&gt;When you declare a class to implement a certain interface, and then you add a method to that class which implements a certain method of that interface, there is absolutely nothing in the declaration of that method to indicate or even hint that it is implementing a method of that interface. Consequently, if you remove the interface from the list of interfaces implemented by the class, the compiler cannot warn you that methods within this class that were implementing methods of that interface are not meaningful anymore. You can try to overcome this problem with explicit interface method implementation, but it is optional and therefore its use cannot be enforced, plus if you use it then you are stuck with other problems, see below.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Explicit interface method implementations are not directly accessible.
&lt;ul&gt;
&lt;li&gt;If you declare a method within a class that explicitly implements a method of an interface implemented by the class, then you cannot invoke that method from within that class, unless you first cast &lt;code&gt;this&lt;/code&gt; to that interface. What the actual fuck?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;switch&lt;/code&gt; statement requires a &lt;code&gt;break&lt;/code&gt; at the end.
&lt;ul&gt;
&lt;li&gt;If you omit the &lt;code&gt;break&lt;/code&gt; at the end, the compiler complains that &lt;code&gt;Control cannot fall out of switch from final case label&lt;/code&gt;. Huh?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>What is wrong with Java</title><link>https://blog.michael.gr/post/2021-10-what-is-wrong-with-java/</link><pubDate>Mon, 04 Oct 2021 15:22:38 +0000</pubDate><guid>https://blog.michael.gr/post/2021-10-what-is-wrong-with-java/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2021-10-what-is-wrong-with-java/media/java.svg"
loading="lazy"
&gt;
This is part of a series of posts in which I am documenting what is wrong with certain popular programming languages that I am (more or less) familiar with. The aim of these posts is to support a future post in which I will be describing what the ideal programming language would look like for me.&lt;/p&gt;
&lt;p&gt;I will be amending and revising these texts over time.&lt;/p&gt;
&lt;p&gt;(Useful pre-reading: &lt;a
href="https://blog.michael.gr/post/2022-11-about-these-papers/"
&gt;About these papers&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id="what-is-wrong-with-java"&gt;What is wrong with Java:
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;The garbage collector.&lt;/li&gt;
&lt;li&gt;Curly braces.&lt;/li&gt;
&lt;li&gt;Primitive types are cumbersome.
&lt;ul&gt;
&lt;li&gt;Each one of the primitive types &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; is a snowflake which must always be handled differently from the others. They cannot all be treated uniformly as value types.&lt;/li&gt;
&lt;li&gt;To allow for at least some uniform treatment, one must keep converting back and forth between them and their corresponding wrapper classes (&lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Long&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt;) which is clunky and inelegant.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Still no user-defined value types in 2022.
&lt;ul&gt;
&lt;li&gt;Since version 14, Java supports records, but they are still allocated on the heap and passed by reference. So, an array of 1000 records which would be a single memory block in C# is 1001 memory blocks in Java.&lt;/li&gt;
&lt;li&gt;Allegedly, a future version of Java will support value types, but knowing how bytecode is structured and how the JVM works:
&lt;ul&gt;
&lt;li&gt;This is going to be extremely difficult to achieve&lt;/li&gt;
&lt;li&gt;Will probably be a cumbersome addition to the language&lt;/li&gt;
&lt;li&gt;The existing awkward primitive types will of course stay with us forever in the name of backwards compatibility.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Still no value tuples in 2022. C# has been doing a pretty good job at that.&lt;/li&gt;
&lt;li&gt;No conditional compilation.
&lt;ul&gt;
&lt;li&gt;Cannot even declare a constant whose value is externally supplied.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Generics are decent, but still lacking.
&lt;ul&gt;
&lt;li&gt;Type erasure allows unsafe constructs which may result in &amp;quot;heap pollution&amp;quot;.&lt;/li&gt;
&lt;li&gt;Type erasure makes it impossible to disambiguate entities based on their generic parameters, thus making it impossible to overload based on generics. This forces us to give artificially different names to entities that would ideally share the same name.&lt;/li&gt;
&lt;li&gt;Working with generics inevitably requires either littering the code with &lt;code&gt;@SuppressWarnings( &amp;quot;unchecked&amp;quot; )&lt;/code&gt;, or entirely disabling the &amp;quot;unchecked&amp;quot; warning, which opens up another can of worms.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No C#-style properties.&lt;/li&gt;
&lt;li&gt;No operator overloading.
&lt;ul&gt;
&lt;li&gt;In general, the language design philosophy of Java seems to be overly protectionist towards the idiot programmer, at the expense of the expert programmer who just can't have a feature that they want because it would be potentially dangerous for the idiot. This is roughly the same narrow-minded protectionist design philosophy that has been employed by Apple and has given rise to what is known as &amp;quot;the mac user&amp;quot;, which is a code-word for &amp;quot;idiot&amp;quot;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No namespaces.
&lt;ul&gt;
&lt;li&gt;Packages are ill-conceived and lame:
&lt;ul&gt;
&lt;li&gt;Each source file must be associated with one and only one package. So, if the source file is to contain multiple classes, all these classes must belong to the same package.&lt;/li&gt;
&lt;li&gt;Each source file may contain no more than one public class. Any additional classes must be package-private.&lt;/li&gt;
&lt;li&gt;There is no equivalent to the namespace aliases of C#.&lt;/li&gt;
&lt;li&gt;Packages are unrelated to packaging. (See lack of assemblies.)&lt;/li&gt;
&lt;li&gt;Packages (and the lack of assemblies) force programmers to cram an impossibly large number of classes within the same package so as to be able to keep some of them package-private, because the moment you try moving a class into a separate package to reduce the clutter, this class must now become public, so as to remain accessible by classes from the original package.&lt;/li&gt;
&lt;li&gt;Despite the fact that package names look hierarchical, packages are not at all hierarchical:
&lt;ul&gt;
&lt;li&gt;Each package is completely separate from all other packages.&lt;/li&gt;
&lt;li&gt;There exists no special relationship between two packages by virtue of their names being one nested within the other. (In C#, a namespace inherits from all namespaces in its ancestry line.)&lt;/li&gt;
&lt;li&gt;It is impossible to address a class in a sub-package with a partial (relative) sub-package name.&lt;/li&gt;
&lt;li&gt;This, in combination with the fact that there is no equivalent to namespace aliases, means that two classes with identical names in different packages can only be handled using fully qualified class names.&lt;/li&gt;
&lt;li&gt;Since fully qualified class names are cumbersome to work with, most people resort to assigning globally unique names to their classes.
&lt;ul&gt;
&lt;li&gt;This is very clunky, and it looks retarded, because it essentially results in class names that contain the name of their package.&lt;/li&gt;
&lt;li&gt;This is an uphill struggle and never quite successful, because you might give unique names to all your classes, but you might use some library with class names that conflict with yours, so there will always be some fully qualified class names around.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No C#-style assemblies.
&lt;ul&gt;
&lt;li&gt;Individual class files scattered all over the place are cumbersome to work with.&lt;/li&gt;
&lt;li&gt;The filesystem/jar-file duality is very cumbersome to work with.&lt;/li&gt;
&lt;li&gt;Jar files only deal with packaging; they offer no support for specifying what is exported and what is kept private.&lt;/li&gt;
&lt;li&gt;Modules were added as an after-thought, and they give some control over what to publish and what to keep private, but the unit of publication is still the package, not the class, which means that package-private classes are still necessary, which in turn means that huge packages are still necessary.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Class loaders are lame.
&lt;ul&gt;
&lt;li&gt;They, as well as many other language features, are a relic from the java web applet era.&lt;/li&gt;
&lt;li&gt;They are very cumbersome to work with.&lt;/li&gt;
&lt;li&gt;They unnecessarily impose a significant performance penalty by doing a lot of work on a per-class basis instead of a per-module basis.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lame access rules.
&lt;ul&gt;
&lt;li&gt;Everything that is package-private is also protected. (Duh?)&lt;/li&gt;
&lt;li&gt;Inner classes have access to private members of the enclosing class; this is probably okay; however, the enclosing class also has access to private members of inner classes, which is retarded.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Member initializers have no access to constructor parameters.&lt;/li&gt;
&lt;li&gt;Member initializers execute between the invocation of the super constructor and the statement that immediately follows it, which technically makes sense, but these jumps in the flow of execution are completely counter-intuitive to the novice programmer, who is precisely the type of programmer that the language caters to. Scala has shown how to do this right.&lt;/li&gt;
&lt;li&gt;The syntax for invoking the super constructor suggests that one might be able to insert statements before the call to super, but this is not the case. (The deviation from the C++ syntax would be justifiable if the new syntax had something to offer, but it does not.) The language falls short of doing the one sensible thing that this syntax would allow, which would be to be able to put code before the call to super, as long as this code does not try to access &lt;code&gt;this&lt;/code&gt;, for example assertions on the constructor parameters before passing them to super; but no, you cannot do that.&lt;/li&gt;
&lt;li&gt;No named / optional parameters to functions. (No default parameter values.)&lt;/li&gt;
&lt;li&gt;Default interface methods cannot be final.
&lt;ul&gt;
&lt;li&gt;Any class implementing an interface may inadvertently re-implement functionality which has already been provided by a default method.&lt;/li&gt;
&lt;li&gt;An interface cannot guarantee that a certain method will have a specific behavior because any class implementing that interface may override that behavior.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Interface methods cannot be protected.
&lt;ul&gt;
&lt;li&gt;It is sometimes useful to have a certain interface method that is only visible by implementing classes, but no, we cannot have that, all methods must be public.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Interface methods cannot be private.
&lt;ul&gt;
&lt;li&gt;It is sometimes useful to have a certain interface method that is only visible by default interface methods within that same interface, but no, we cannot have that, all methods must be public.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lambda argument names are not allowed to mask the names of variables of the enclosing scope. This is very lame because:
&lt;ul&gt;
&lt;li&gt;It forces the programmer to invent new, unnatural names for lambda arguments.&lt;/li&gt;
&lt;li&gt;Variables of the enclosing scope cannot be masked, so they remain accessible within the lambda, and can thus be accessed by mistake, leading to bugs that are very hard to detect.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No member literals and not even a 'nameof' operator.&lt;/li&gt;
&lt;li&gt;No nullable/non-nullable semantics for reference types. (C# 8 does a fairly decent job at that.)&lt;/li&gt;
&lt;li&gt;No variable declarations inside assignment expressions. (&lt;code&gt;while( (var line = next()) != null )&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;No nested methods.
&lt;ul&gt;
&lt;li&gt;You can have a function-local class, but you cannot have a function-local function. The workaround is to declare and instantiate a function-local anonymous class containing the nested method, but this is cumbersome, unnecessarily verbose, and incurs a performance penalty.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No redefining of names (as with the &lt;code&gt;new&lt;/code&gt; keyword of C#)&lt;/li&gt;
&lt;li&gt;The long history of the language inevitably means that there are some bad choices of yore which interfere with newly introduced features. For example:
&lt;ul&gt;
&lt;li&gt;The ability to use the same name for a field and a function never really offered anything of value, but it did necessitate the introduction of the cumbersome double-colon operator when function references were added to the language.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Checked exceptions.
&lt;ul&gt;
&lt;li&gt;They were a good idea in principle, but turned out to be too cumbersome in practice.&lt;/li&gt;
&lt;li&gt;With the advent of lambdas, they represent nothing but hindrance.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Collecting a stack trace (and therefore also throwing an exception) might not be as excruciatingly slow as it is in C#, but it is still unnecessarily slow, and prohibitively slow for some purposes.&lt;/li&gt;
&lt;li&gt;No feature like the __FILE__ and __LINE__ intrinsic macros of C++.
&lt;ul&gt;
&lt;li&gt;There is no way to obtain this information without walking the stack, and is especially problematic since walking the stack is unreasonably slow.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The built-in collection model is very outdated and lame.
&lt;ul&gt;
&lt;li&gt;Arrays do not implement any of the collection interfaces so they always need special handling.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Iterator&lt;/code&gt; interface is lame.
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;hasNext()&lt;/code&gt; and &lt;code&gt;next()&lt;/code&gt; methods are unusable in a for-loop. (A for-each loop can be used with an &lt;code&gt;Iterable&lt;/code&gt;, but then you have no access to the &lt;code&gt;Iterator&lt;/code&gt;.)&lt;/li&gt;
&lt;li&gt;A filtering iterator cannot be implemented without cumbersome look-ahead logic and then it is impossible to use it for removing items from the collection because looking ahead means that you are always past the item you want to delete.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lack of unmodifiable collection interfaces means no compile-time readonlyness.
&lt;ul&gt;
&lt;li&gt;Every single collection instance looks mutable, since it is implementing an interface that has mutation methods, but quite often is secretly immutable, meaning that if you make the mistake of invoking any of the mutation methods, you will be slapped with a runtime exception.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Fluent collections (collection streams) are lame.
&lt;ul&gt;
&lt;li&gt;They are unnecessarily verbose
&lt;ul&gt;
&lt;li&gt;They require every single call chain to begin with a quite superfluous-looking &lt;code&gt;stream()&lt;/code&gt; operation&lt;/li&gt;
&lt;li&gt;They almost always have to be ended with an equally superfluous-looking &lt;code&gt;collect()&lt;/code&gt; operation.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;They are not particularly extensible because they are entirely based on a single interface (&lt;code&gt;Stream&lt;/code&gt;). Their only point of extensibility is at the very end of each call chain, by means of custom-written collectors.&lt;/li&gt;
&lt;li&gt;Collectors are convoluted, so writing one is not trivial.&lt;/li&gt;
&lt;li&gt;Collection streams work by means of incredibly complex logic behind the scenes, so:
&lt;ul&gt;
&lt;li&gt;They are very difficult to debug.&lt;/li&gt;
&lt;li&gt;They are noticeably slower than C#-style fluent collection operations even before we consider the collection step at the end.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The collection step is tantamount to making an unnecessary safety copy of the information produced by the collection stream chain.&lt;/li&gt;
&lt;li&gt;Collection streams are unnecessarily convoluted due to the ill-conceived notion that the mechanism used for fluent collection operations should also be usable for parallel collection operations.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Various standard classes are implemented in lame ways. For example:
&lt;ul&gt;
&lt;li&gt;All input-output stream classes suffer a performance handicap due to unnecessarily and ill-conceivedly trying to be thread-safe.&lt;/li&gt;
&lt;li&gt;Input-output functionality is often achievable not via interfaces, but instead via abstract classes with an unnecessarily verbose set of methods, which makes extending them a tedious and error prone endeavor. (E.g. java.io.Writer, java.io.StreamWriter.)&lt;/li&gt;
&lt;li&gt;There is no way to attempt parsing a number and obtain an indication as to whether the parsing succeeded or not, without:
&lt;ul&gt;
&lt;li&gt;Suffering the performance penalty of an exception being thrown&lt;/li&gt;
&lt;li&gt;Having to write code that catches the exception to take notice that parsing failed.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;(And funnily enough, even though the Java runtime makes liberal use of checked exceptions everywhere, the parse-failed exception is unchecked.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;The for-each loop does not do anything about closeable iterators. (The for-each loop of C# properly disposes disposable enumerators.)&lt;/li&gt;
&lt;li&gt;The try-with-resources statement requires a variable to be defined to hold the closeable object. (The equivalent 'using' statement of C# has no such requirement.)&lt;/li&gt;
&lt;li&gt;The language runtime if full of always-on error checks instead of using assertions.&lt;/li&gt;
&lt;li&gt;The inner workings of the language runtime are convoluted, and its performance is hindered, by the operation of various unrequired and arguably ill-conceived mechanisms such as &amp;quot;access checking&amp;quot;, &amp;quot;bytecode verification&amp;quot;, &amp;quot;protection domains&amp;quot;, and even some optional &amp;quot;security manager&amp;quot;. (The security manager is finally being deprecated as of Java 17.)&lt;/li&gt;
&lt;li&gt;No compiler-enforced method purity.
&lt;ul&gt;
&lt;li&gt;It is not possible to declare a method as pure and have the compiler enforce that it, and any overrides of it, are in fact pure,&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No compiler-enforced immutability.
&lt;ul&gt;
&lt;li&gt;It is not possible to declare a class as immutable and have the compiler enforce that it, and any derived classes, are in fact immutable.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Still no string interpolation in 2021.&lt;/li&gt;
&lt;li&gt;Inconsistent rules for curly braces.
&lt;ul&gt;
&lt;li&gt;In most cases, curly braces are unnecessary unless the scope they enclose consists of more than one statement.&lt;/li&gt;
&lt;li&gt;However, the curly braces are mandatory in some arbitrary cases, e.g. for method bodies and for try-catch-finally statements.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lame style conventions, for example:
&lt;ul&gt;
&lt;li&gt;Underscores are inadvisable, which is retared.&lt;/li&gt;
&lt;li&gt;Methods, fields, variables, and parameters are to be named in camelCase, which is retarded.&lt;/li&gt;
&lt;li&gt;Package names are to be named in all lowercase, which is retarded.&lt;/li&gt;
&lt;li&gt;The curly brace style is to be egyptian, which is retarded.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No means of programmatically breaking into the debugger as per the &lt;code&gt;System.Diagnostics.Debugger.Break()&lt;/code&gt; method of C#.&lt;/li&gt;
&lt;li&gt;Class&amp;lt;T&amp;gt; is a misnomer. It is actually a type, because it may stand for either a class or an interface. C# does better here, too.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: the above list of disadvantages is kind of long, because I am intimately familiar with the language.&lt;/p&gt;
&lt;p&gt;Feedback is more than welcome: you'd be doing me a favor. However, be aware that blogger sometimes eats comments, so be sure to save your text before submitting it. If blogger eats your comment, please e-mail it to me.&lt;/p&gt;</description></item><item><title>What is wrong with C++</title><link>https://blog.michael.gr/post/2021-10-what-is-wrong-with-cplusplus/</link><pubDate>Mon, 04 Oct 2021 14:23:59 +0000</pubDate><guid>https://blog.michael.gr/post/2021-10-what-is-wrong-with-cplusplus/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2021-10-what-is-wrong-with-cplusplus/media/cplusplus.svg"
loading="lazy"
&gt;
This is part of a series of posts in which I am documenting what is wrong with certain popular programming languages that I am (more or less) familiar with. The aim of these posts is to support a future post in which I will be describing what the ideal programming language would look like for me.&lt;/p&gt;
&lt;p&gt;I will be amending and revising these texts over time.&lt;/p&gt;
&lt;p&gt;(Useful pre-reading: &lt;a
href="https://blog.michael.gr/post/2022-11-about-these-papers/"
&gt;About these papers&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id="what-is-wrong-with-c"&gt;What is wrong with C++:
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Multiple inheritance.&lt;/li&gt;
&lt;li&gt;Incredibly complex syntax. (Would you like some const with your const?)&lt;/li&gt;
&lt;li&gt;Cumbersome syntax. (Member variables cannot be initialized at the point of declaration.)&lt;/li&gt;
&lt;li&gt;Requires splitting the code into header files and implementation files.&lt;/li&gt;
&lt;li&gt;The ability to use incredibly complex constructs (pointer to pointer to pointer) leads to code that is understood only by the original author, only within a short time after writing it. After that short period of time has elapsed, there exists nobody in the entire universe who understands that code.&lt;/li&gt;
&lt;li&gt;The ability to freely manipulate pointers often leads to illegal memory accesses.&lt;/li&gt;
&lt;li&gt;Manual memory management often results in dangling pointers or memory leaks.&lt;/li&gt;
&lt;li&gt;Lack of generic types.
&lt;ul&gt;
&lt;li&gt;Templates are much more cumbersome to write than generic types.&lt;/li&gt;
&lt;li&gt;Templates do not promote abstraction.&lt;/li&gt;
&lt;li&gt;Templates result in a larger executable, which at runtime translates to a larger working set, which translates to reduced performance.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lack of C#-style properties. (Though perhaps some of their functionality can be achieved by operator overloading?)&lt;/li&gt;
&lt;li&gt;Intentionally undefined behavior.
&lt;ul&gt;
&lt;li&gt;Is essentially a form of error-hiding, and often results in code that works by coincidence but will horribly break under slightly different circumstances.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No reflection.
&lt;ul&gt;
&lt;li&gt;RTTI is a very poor excuse for a substitute to reflection.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The built-in (stl) collection model is lame:
&lt;ul&gt;
&lt;li&gt;Arcane nomenclature (whoever thought you can push into a vector!)&lt;/li&gt;
&lt;li&gt;No collection class hierarchy: each collection class is a snowflake. They do not, for example, all inherit from some &lt;code&gt;Iterable&lt;/code&gt; common base class.&lt;/li&gt;
&lt;li&gt;No abstraction: each collection class has its very own snowflake iterator class.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The preprocessor hinders static analysis and removes any guarantees about the semantics of the source code.&lt;/li&gt;
&lt;li&gt;Gives the programmer a false sense of control over code generation.
&lt;ul&gt;
&lt;li&gt;Thinking both at the problem-solving level and at the code generation level results in severe cognitive overhead.&lt;/li&gt;
&lt;li&gt;At the end of the day, this is all an illusion, as the optimizer will generally do things quite differently from what the programmer imagined.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The &amp;quot;you don't pay for what you did not order&amp;quot; dogma prevents a multitude of extremely useful error checks (such as array index out of range) and safeguards (such as guaranteed zero values for non-explicitly initialized members and array elements.)&lt;/li&gt;
&lt;li&gt;Curly braces.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: the above list of disadvantages is kind of short, because my C++ is a bit rusty.&lt;/p&gt;
&lt;p&gt;Feedback is more than welcome: you'd be doing me a favor. However, be aware that blogger sometimes eats comments, so be sure to save your text before submitting it. If blogger eats your comment, please e-mail it to me.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Old comments&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Anonymous 2022-11-03 16:35:12 UTC&lt;/p&gt;
&lt;p&gt;Many of these things are out of date.&lt;/p&gt;
&lt;p&gt;&amp;quot;Member variables cannot be initialized at the point of declaration.&amp;quot; &amp;lt;- They can since C++11
&amp;quot;Requires splitting the code into header files and implementation files.&amp;quot; &amp;lt;- Not strictly true, pretty much everything can be in a header file since C++17
&amp;quot;No collection class hierarchy&amp;quot; &amp;quot;No abstraction&amp;quot; &amp;lt;- Since C++11 for ( type elem : range ) iteration is applicable to any range
&amp;quot;The preprocessor hinders static analysis and removes any guarantees about the semantics of the source code.&amp;quot; &amp;lt;- Static analysers can preprocess too
&amp;quot;a multitude of extremely useful error checks (such as array index out of range) and safeguards (such as guaranteed trap values for non-explicitly initialized members and array elements.)&amp;quot; &amp;lt;- undefined behaviour means debug builds are allowed to have these things, and checked equivalents are also available&lt;/p&gt;
&lt;p&gt;Others are fixable with a style guide&lt;/p&gt;
&lt;p&gt;&amp;quot;Manual memory management often results in dangling pointers or memory leaks.&amp;quot; &amp;lt;- Memory management is done by library code.
&amp;quot;Templates are much more cumbersome to write than generic types.&amp;quot; &amp;lt;- Only when you declare a class template's member functions out-of-line.&lt;/p&gt;
&lt;p&gt;And in some cases I'd say you are flat wrong&lt;/p&gt;
&lt;p&gt;&amp;quot;Templates do not promote abstraction&amp;quot; &amp;lt;- You can't add an interface to a class post-hoc, whereas you can have a class that models a type constraint post-hoc&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>A Programming Language</title><link>https://blog.michael.gr/post/2022-07-a-programming-language/</link><pubDate>Wed, 01 Sep 2021 04:47:26 +0000</pubDate><guid>https://blog.michael.gr/post/2022-07-a-programming-language/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2022-07-a-programming-language/media/a-programming-language-cover.jpg"
width="1000"
height="667"
loading="lazy"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="359px"
&gt;
&lt;/p&gt;
&lt;h3 id="abstract"&gt;Abstract
&lt;/h3&gt;&lt;p&gt;My thoughts and notes on how I would like a new programming language to look like.&lt;/p&gt;
&lt;p&gt;The unique selling point of the language is:&lt;/p&gt;
&lt;p&gt;Automatic memory reclamation without garbage collection.&lt;/p&gt;
&lt;p&gt;Other selling points of the language are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Simple and elegant. (So that it is suitable for the academia.)&lt;/li&gt;
&lt;li&gt;Expressive. (So that it is suitable for experienced programmers.)&lt;/li&gt;
&lt;li&gt;Consistent. (So that it is attractive to developer teams.)&lt;/li&gt;
&lt;li&gt;Guiding. (So that it promotes best practices.)&lt;/li&gt;
&lt;li&gt;Fast. (So that it is suitable for high performance computing.)&lt;/li&gt;
&lt;li&gt;Lean. (So that it is suitable for resource-constrained computing.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is work-in-progress; It is bound to be heavily amended as time passes, especially if I try some new language, like Kotlin or Rust.&lt;/p&gt;
&lt;h3 id="summary-of-language-characteristics"&gt;Summary of language characteristics
&lt;/h3&gt;&lt;p&gt;(Useful pre-reading: &lt;a
href="https://blog.michael.gr/post/2022-11-about-these-papers/"
&gt;About these papers&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;The main goals of the language are achieved via the following characteristics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;For simplicity and elegance:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scoping by indentation instead of curly braces. (Similar to python.)&lt;/li&gt;
&lt;li&gt;Keyword-rich syntax which avoids cryptic abbreviations and symbols.&lt;/li&gt;
&lt;li&gt;Clear distinction between what is a statement and what is an expression.&lt;/li&gt;
&lt;li&gt;Automatic memory management.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For expressiveness:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lightweight properties, user-defined operators, generics, etc.&lt;/li&gt;
&lt;li&gt;Type inference whenever possible.&lt;/li&gt;
&lt;li&gt;Explicit nullability of reference types.&lt;/li&gt;
&lt;li&gt;Full support for functional programming.&lt;/li&gt;
&lt;li&gt;Full support for imperative programming without functional Nazism.&lt;/li&gt;
&lt;li&gt;Async-transparency.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For consistency:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extensive, mandatory, and in many cases non-suppressible, code inspections.&lt;/li&gt;
&lt;li&gt;Whenever possible, only one way of expressing any given thing.&lt;/li&gt;
&lt;li&gt;Extensive and strict formatting rules ensure all code looks the same.&lt;/li&gt;
&lt;li&gt;Reformatability spares developers from having to type code in a particular way.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For performance:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Strongly typed.&lt;/li&gt;
&lt;li&gt;Primitive value types correspond to machine words.&lt;/li&gt;
&lt;li&gt;Intermediate-code-based, Just-In-Time compiled.&lt;/li&gt;
&lt;li&gt;Fibers. (By means of async-transparency.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For leanness:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reference counting instead of garbage collection.&lt;/li&gt;
&lt;li&gt;Minimalistic mandatory runtime library.&lt;/li&gt;
&lt;li&gt;Separate and optional standard library.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For a list of shortcomings of other languages, which this language intends to fix, see:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a
href="https://blog.michael.gr/post/2021-10-what-is-wrong-with-cplusplus/"
&gt;What is wrong with C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://blog.michael.gr/post/2021-10-what-is-wrong-with-java/"
&gt;What is wrong with Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://blog.michael.gr/post/2021-10-what-is-wrong-with-csharp/"
&gt;What is wrong with C#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://blog.michael.gr/post/2021-10-what-is-wrong-with-scala/"
&gt;What is wrong with Scala&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="language-characteristics-in-detail"&gt;Language characteristics in detail
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Supports reference types and value types, as C# does.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;null&lt;/code&gt; value is valid only with explicitly nullable reference types.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As in C# 8.0 with &lt;code&gt;#nullable enable&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;A non-nullable reference can be used when a nullable reference is expected.&lt;/li&gt;
&lt;li&gt;A nullable reference cannot be used when a non-nullable reference is expected, unless:
&lt;ul&gt;
&lt;li&gt;the compiler knows, via data-flow analysis, that the value is not null.
&lt;ul&gt;
&lt;li&gt;For example, by means of an if-statement which precludes null.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;the value is explicitly cast to non-null. (As with the &amp;quot;null-forgiving&amp;quot; or &amp;quot;damnit&amp;quot; operator in C#.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;However, unlike C#:
&lt;ul&gt;
&lt;li&gt;The non-null cast is also an assertion against null, so it does not just circumvent the nullability checks of the compiler, it acts as an if-statement which precludes null.&lt;/li&gt;
&lt;li&gt;Thus, a non-nullable reference can never accidentally hold null.&lt;/li&gt;
&lt;li&gt;It is illegal to apply the non-null cast on a reference that is already non-nullable.&lt;/li&gt;
&lt;li&gt;It is illegal to assign the result of the non-null-cast to a nullable reference.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Compiles into an intermediate code format. There are two possibilities:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LLVM.&lt;/li&gt;
&lt;li&gt;A new intermediate code format called ObjectCode, which is either interpreted or further compiled into machine code by a Just-In-Time (JIT) compiler.
&lt;ul&gt;
&lt;li&gt;Functionally, ObjectCode is a stack machine language, just as JVM ByteCode is.&lt;/li&gt;
&lt;li&gt;ObjectCode is expressed as a hierarchical data structure.
&lt;ul&gt;
&lt;li&gt;A binary ObjectCode file is the result of the serializing that data structure into a binary stream. Serialization into a text stream should also be possible.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ObjectCode is not trying hard to look like machine language, the way JVM ByteCode does. For example:
&lt;ul&gt;
&lt;li&gt;Instructions have no alternative short-form versions that accomplish the same thing but with fewer bytes.&lt;/li&gt;
&lt;li&gt;There are no instructions for operations between &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Real&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, etc; instead, these operations are available as methods exposed by those value types.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Very few instructions have knowledge of any particular data type:
&lt;ul&gt;
&lt;li&gt;Boolean operations have knowledge of the &lt;code&gt;boolean&lt;/code&gt; type. (So that the compiler can apply short-circuit evaluation and branching.)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;throw&lt;/code&gt; instruction has knowledge of the &lt;code&gt;Exception&lt;/code&gt; type.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;switch&lt;/code&gt; instruction has knowledge of the &lt;code&gt;integer&lt;/code&gt; type.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No unnecessary JVM gimmicks like bytecode verification, stack verification, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Executable code is packaged into modules which correspond to C# assemblies.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;So, no myriads of class files floating around.&lt;/li&gt;
&lt;li&gt;Each class in a module has its own timestamp.&lt;/li&gt;
&lt;li&gt;When a module is being made, unchanged classes are copied verbatim from the old module instead of being recompiled, thus retaining their timestamps.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For the benefit of benchmarking, the runtime environment can be &lt;em&gt;&lt;strong&gt;programmatically&lt;/strong&gt;&lt;/em&gt; instructed to JIT everything at once so that nothing gets interpreted from that moment on.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Async-transparency and fibers.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Looks and feels synchronous, but works asynchronously under the hood.&lt;/li&gt;
&lt;li&gt;A function can be declared as &lt;code&gt;async&lt;/code&gt;; this signifies that the function works asynchronously, but nothing else changes:
&lt;ul&gt;
&lt;li&gt;When invoking: you call it and obtain its result just as with any other function.,&lt;/li&gt;
&lt;li&gt;When implementing: you just return a result, just like any other function.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;When an async function is invoked, the compiler does not emit a direct invocation to the function; instead, it invokes a special InvokeAsync function of the runtime, which accepts the function to be invoked as a parameter, and returns the result returned by the function. So, it looks as if the runtime will invoke the target function, block-waiting for it to complete, and return the result. However, the runtime does the following instead:
&lt;ul&gt;
&lt;li&gt;starts the asynchronous operation,&lt;/li&gt;
&lt;li&gt;obtains a promise under the hood,&lt;/li&gt;
&lt;li&gt;sets aside the promise and the current stack,&lt;/li&gt;
&lt;li&gt;proceeds to do other stuff.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;When the promise is satisfied, the runtime:
&lt;ul&gt;
&lt;li&gt;gets the return value from the promise,&lt;/li&gt;
&lt;li&gt;switches back to that stack,&lt;/li&gt;
&lt;li&gt;continues execution from there.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Note: something called &amp;quot;_hyperscript&amp;quot; already purports to support async-transparency; I do not know whether they switch stacks or pass promises/futures under the hood all over the place. See &lt;a class="external"
href="https://hyperscript.org/docs/#async" target="_blank"
&gt;https://hyperscript.org/docs/#async&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Note: this is related to OpenJDK JEP 425: Virtual Threads. See &lt;a class="external"
href="https://openjdk.org/jeps/425" target="_blank"
&gt;https://openjdk.org/jeps/425&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;An abstraction of an &lt;code&gt;EventDriver&lt;/code&gt; is provided, which encapsulates an event driven system. A &lt;code&gt;ConcreteEventDriver&lt;/code&gt; is provided, which is a default (&amp;quot;reference&amp;quot;) implementation of an event-driven system.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;EventDriver&lt;/code&gt; does not contain a &lt;code&gt;post&lt;/code&gt; method; instead, it exposes an &lt;code&gt;Injector&lt;/code&gt; interface, which does. So, code that only needs to &lt;code&gt;post&lt;/code&gt; only needs to have access to an &lt;code&gt;Injector&lt;/code&gt;, not to the whole &lt;code&gt;EventDriver&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Threads and thread-pools exist for interfacing with legacy systems; the preferred way of working is with fibers and fiber-pools.
&lt;ul&gt;
&lt;li&gt;Each fiber-pool has its own event-driver.&lt;/li&gt;
&lt;li&gt;TODO: describe exactly what a fiber is.&lt;/li&gt;
&lt;li&gt;TODO: describe how a fiber exposes a proxy for invocation from other fibers and how the proxy asserts that everything passed back and forth is either thread-safe or immutable.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Note that in multi-threaded execution models purity is of very limited usefulness because it does not prevent reading mutable state, so it does not avoid race conditions. However, this language makes use of fibers instead of threads, so there can be no race conditions, so purity becomes useful.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Support for functional programming.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For example:
&lt;ul&gt;
&lt;li&gt;Lambdas.&lt;/li&gt;
&lt;li&gt;Tuples.&lt;/li&gt;
&lt;li&gt;Everything is read-only by default.
&lt;ul&gt;
&lt;li&gt;The keyword &lt;code&gt;mutable&lt;/code&gt; must be used to denote something which may vary. (Scala's &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; are too cryptic and too similar; mutability must stand out like a sore thumb.)&lt;/li&gt;
&lt;li&gt;So, the syntax for declaring a mutable local integer is:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mutable local x: integer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;It is an error to declare something as &lt;code&gt;mutable&lt;/code&gt; and forget to ever mutate it.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;All interfaces are pure by default.
&lt;ul&gt;
&lt;li&gt;A special keyword &lt;code&gt;impure&lt;/code&gt; must be used to denote an interface which is allowed to contain impure methods.&lt;/li&gt;
&lt;li&gt;It is an error to declare an interface as &lt;code&gt;impure&lt;/code&gt; and forget to include any impure methods in it.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Methods can be either pure or impure, and this has severe implications on what they may and may not do.&lt;/li&gt;
&lt;li&gt;Most language constructs like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt; etc. have both functional and imperative forms.
&lt;ul&gt;
&lt;li&gt;The functional forms must be pure; the imperative forms can be impure.&lt;/li&gt;
&lt;li&gt;The functional forms may not use flow-control keywords that would affect enclosing scopes; in other words,
&lt;ul&gt;
&lt;li&gt;A functional construct may not use the &lt;code&gt;return&lt;/code&gt; keyword to exit the current function&lt;/li&gt;
&lt;li&gt;A functional construct may not use the &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; keywords to exit or repeat an enclosing loop.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The functional forms make use of the &lt;code&gt;yield&lt;/code&gt; keyword to produce values. So, the functional &lt;code&gt;if&lt;/code&gt; statement is &lt;code&gt;if( x ) yield 5; else yield 6;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Functional loops evaluate to &lt;code&gt;Enumerable&lt;/code&gt; and each execution of &lt;code&gt;yield&lt;/code&gt; produces a new element.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The standard library offers various monads like &lt;code&gt;Optional&lt;/code&gt;, &lt;code&gt;Try&lt;/code&gt;, and other common functional goodies.&lt;/li&gt;
&lt;li&gt;The standard collections support fluent constructs.
&lt;ul&gt;
&lt;li&gt;The functional constructs are like Scala's collections, which means that they are somewhat like C#'s linq and not like Java's collection streams.&lt;/li&gt;
&lt;li&gt;There is no support in the standard collections for parallelization.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No such thing as the &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; parameters of C#.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;However:
&lt;ul&gt;
&lt;li&gt;No functional Nazism.
&lt;ul&gt;
&lt;li&gt;No obstacles to having mutable state, other than having to use an extra keyword here and there.&lt;/li&gt;
&lt;li&gt;A proper &lt;code&gt;for&lt;/code&gt; loop.
&lt;ul&gt;
&lt;li&gt;Even the functional version of the &lt;code&gt;for&lt;/code&gt; loop is a first-class language construct, not yet another higher order function.&lt;/li&gt;
&lt;li&gt;Thus, when single-stepping through code, you do not have to remember to use step-into instead of step-over in order to skip the header of the loop and reach the body of the loop.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Proper &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; keywords.&lt;/li&gt;
&lt;li&gt;Freedom to re-assign parameters.
&lt;ul&gt;
&lt;li&gt;Thus making the original value inaccessible.&lt;/li&gt;
&lt;li&gt;To allow this, the &lt;code&gt;mutable&lt;/code&gt; keyword must be added to the parameter.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;mutable&lt;/code&gt; keyword on a parameter has no meaning for the caller of the method, and therefore does not become part of the method prototype.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Everything that can be accomplished functionally can also be accomplished imperatively.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No functional gimmicks.
&lt;ul&gt;
&lt;li&gt;The expression evaluated last within a function does not magically become the return value of the function without a &lt;code&gt;return&lt;/code&gt; statement; &lt;code&gt;return&lt;/code&gt; statements cannot simply be omitted. Same for &lt;code&gt;yield&lt;/code&gt; statements.&lt;/li&gt;
&lt;li&gt;No copy-on-mutation collections.&lt;/li&gt;
&lt;li&gt;No such thing as Scala's &lt;code&gt;Unit&lt;/code&gt;. Two approaches are possible:
&lt;ul&gt;
&lt;li&gt;We maintain a clear distinction between functions and procedures, in which case &lt;code&gt;Unit&lt;/code&gt; is unnecessary just as &lt;code&gt;void&lt;/code&gt; is unnecessary.&lt;/li&gt;
&lt;li&gt;Everything is a function, but instead of &lt;code&gt;Unit&lt;/code&gt; we stick to good old familiar &lt;code&gt;void&lt;/code&gt;, which now becomes an actual data type of which there exists only one instance.
&lt;ul&gt;
&lt;li&gt;Normally, the instance of void should never need to be accessed, (and therefore might not even be accessible,) because it is implied when necessary. For example, the statement &lt;code&gt;return&lt;/code&gt; is equivalent to &lt;code&gt;return void.instance&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The compiler makes a very clear distinction between statements and expressions.
&lt;ul&gt;
&lt;li&gt;A block scope consists of statements.&lt;/li&gt;
&lt;li&gt;Statements and expressions are not interchangeable:
&lt;ul&gt;
&lt;li&gt;A statement may contain expressions, but an expression may not contain statements.&lt;/li&gt;
&lt;li&gt;An expression cannot appear in place of a statement.&lt;/li&gt;
&lt;li&gt;A statement cannot appear in place of an expression. (With the possible exception of throwing an exception.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Most languages allow invoking a function and ignoring its return value; we put an end to that abhorrent malpractice.&lt;/li&gt;
&lt;li&gt;When a statement is expected, and we use something which yields a value, that value must be dealt with, in order to be left with a statement and not an expression.&lt;/li&gt;
&lt;li&gt;The language might provide a mechanism for ignoring a value, (perhaps a cast to void?) but this can also be accomplished by invoking a void-returning method which accepts one parameter and just ignores it.&lt;/li&gt;
&lt;li&gt;Assignment is a statement, and it requires the use of the &lt;code&gt;let&lt;/code&gt; keyword, as in &lt;code&gt;let a = 5;&lt;/code&gt; unless a field or local is being declared and initialized at once, in which case the &lt;code&gt;let&lt;/code&gt; keyword is omitted, as in &lt;code&gt;local a = 5;&lt;/code&gt; This has some drawbacks and some benefits:
&lt;ul&gt;
&lt;li&gt;Drawback: We cannot initialize multiple variables in one go, as in &lt;code&gt;let a = b = c = 5;&lt;/code&gt; because everything after the first &lt;code&gt;=&lt;/code&gt; must be an expression. That's inconsequential, perhaps even arguably a benefit.&lt;/li&gt;
&lt;li&gt;Drawback: We cannot assign and compare in one go, as in &lt;code&gt;if( ( let a = f() ) &amp;gt; 5 )...&lt;/code&gt; because assignment is a statement, so it cannot be used inside an expression. That's inconsequential, perhaps even arguably a benefit.&lt;/li&gt;
&lt;li&gt;Benefit: since the compiler can always tell whether it is compiling a statement or an expression, it can treat certain things differently depending on whether they appear in a statement or an expression. Namely, the equals sign can now be used either in a statement, as the assignment operator, or in an expression, as the equality check operator.&lt;/li&gt;
&lt;li&gt;Thus, after so many decades, we can finally say good-bye to the inelegant double-equals (&lt;code&gt;==&lt;/code&gt;) legacy of C, and start using the single equals sign for equality comparison, as it was always meant to be.&lt;/li&gt;
&lt;li&gt;The inequality operator can either stay as &lt;code&gt;!=&lt;/code&gt; or become &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The prefix and postfix increment operators are problematic because they are expressions with side-effects, (they both mutate an existing value and yield a new value,) so we might disallow them, and require the use of the long form instead: &lt;code&gt;let x = x + 1;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;If we keep them, then they will certainly only be allowed in expressions.&lt;/li&gt;
&lt;li&gt;(You could make it a statement with &lt;code&gt;(void) x++;&lt;/code&gt; but why would you?)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We keep &lt;code&gt;static&lt;/code&gt; as in Java and avoid Scala's inelegant companion objects.&lt;/li&gt;
&lt;li&gt;There is no support in the standard collections for parallelization.&lt;/li&gt;
&lt;li&gt;When declaring a lambda, the keyword &lt;code&gt;function&lt;/code&gt; must be used.&lt;/li&gt;
&lt;li&gt;When declaring a tuple, the keyword &lt;code&gt;tuple&lt;/code&gt; must be used.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Everything is private by default, unless explicitly given a higher visibility.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Therefore, the language does not have a keyword to indicate that something is private.&lt;/li&gt;
&lt;li&gt;Note that this also applies to interface methods: if you want an interface method to be public, you have to declare it as public, otherwise it stays private and may only be invoked from other methods of the same interface.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Everything is non-inheritable by default, unless explicitly declared as inheritable.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(Except for interfaces, which are by definition inheritable.)&lt;/li&gt;
&lt;li&gt;Therefore, the language does not have a keyword to indicate that something
is non-inheritable (sealed in C#, final in Java.)&lt;/li&gt;
&lt;li&gt;Note that this also applies to interface methods: if you want an interface
method to be overridable, you have to declare it as overridable.&lt;/li&gt;
&lt;li&gt;This makes certain other rules unnecessary, for example we do not have to stipulate that it is an error to explicitly declare a method as non-overridable in a class which has already been declared as non-inheritable.&lt;/li&gt;
&lt;li&gt;It is an error to declare something as inheritable and fail to ever inherit from it.
&lt;ul&gt;
&lt;li&gt;This is enforceable because inheritance is confined within a module, so all members of an inheritance hierarchy are known during the compilation of the module.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Emphasis on purity.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There are two ways we can go about this, and which way we will go is yet to be decided.
&lt;ul&gt;
&lt;li&gt;Procedures and functions
&lt;ul&gt;
&lt;li&gt;A method can be either a procedure or a function.&lt;/li&gt;
&lt;li&gt;A procedure:
&lt;ul&gt;
&lt;li&gt;Does not return anything.&lt;/li&gt;
&lt;li&gt;Is impure. (Must have at least one side-effect.)&lt;/li&gt;
&lt;li&gt;Can indicate failure only by means of throwing an exception.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A function:
&lt;ul&gt;
&lt;li&gt;Returns something.&lt;/li&gt;
&lt;li&gt;Can indicate failure either by throwing an exception or by returning
a &lt;code&gt;Try&lt;/code&gt; monad.&lt;/li&gt;
&lt;li&gt;Is pure. (Must have no side-effects.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Experimental idea: the keyword &lt;code&gt;method&lt;/code&gt; can be used to denote a higher order method which is either a procedure or a function depending on whether its parameter is a procedure or a function.
&lt;ul&gt;
&lt;li&gt;It must have a parameter declared as &lt;code&gt;method&lt;/code&gt; instead of the more specific &lt;code&gt;procedure&lt;/code&gt; or &lt;code&gt;function&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;It may have additional parameters that are explicitly &lt;code&gt;function&lt;/code&gt; or &lt;code&gt;procedure&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;It must treat its parameter method as a function, meaning that when it invokes that method, it must obtain a return value from it.&lt;/li&gt;
&lt;li&gt;It can be coded as a function, meaning that it can return that value.&lt;/li&gt;
&lt;li&gt;From the point of view of the caller, it behaves either as a procedure or as a function depending on whether the caller passes a procedure or a function to its method parameter.&lt;/li&gt;
&lt;li&gt;The caller may actually pass yet another a method to it, in which case the caller is in turn a method instead of a procedure or function.&lt;/li&gt;
&lt;li&gt;Such a construct would eliminate the need to declare both a function and a procedure for each higher order operation, and at the same time avoid the inelegance of &lt;code&gt;Unit&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pure and impure methods
&lt;ul&gt;
&lt;li&gt;All methods are functions.&lt;/li&gt;
&lt;li&gt;Methods that have nothing to return must be declared to return &lt;code&gt;void&lt;/code&gt;, which is equivalent to Scala's &lt;code&gt;Unit&lt;/code&gt; in the sense that it is an actual data type of which there exists only one instance.
&lt;ul&gt;
&lt;li&gt;Thus, void-returning and non-void-returning functions can be treated in exactly the same way in all situations. For example:
&lt;ul&gt;
&lt;li&gt;From within a &lt;code&gt;void&lt;/code&gt; function we can use the &lt;code&gt;return&lt;/code&gt; keyword to return the result of invoking another &lt;code&gt;void&lt;/code&gt; function.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;This in turn means that a single higher order function can operate both on void-returning and non-void-returning functions.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Impure methods must be explicitly marked with the &lt;code&gt;impure&lt;/code&gt; keyword.&lt;/li&gt;
&lt;li&gt;An impure method may return either void or non-void.&lt;/li&gt;
&lt;li&gt;A pure method must return non-void. (It would not make sense to return void, because it cannot perform any side-effects, so its sole reason of existence is to return something.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In all cases:
&lt;ul&gt;
&lt;li&gt;A pure method / function:
&lt;ul&gt;
&lt;li&gt;May not assign to any field of &lt;code&gt;this&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;May not invoke any impure methods / procedures on any of its parameters, including &lt;code&gt;this&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;May not escape an impure interface of any of its parameters, including &lt;code&gt;this&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;It is okay to escape pure interfaces, since there will be no side-effects.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;May still declare and manipulate mutable locals, including the ability to escape mutable locals or impure interfaces thereof.&lt;/li&gt;
&lt;li&gt;It would be nice to be able to say that a pure method / function can never throw an exception; however, we cannot do that, because even a pure method / function can, for example, accidentally divide by zero.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Mechanisms are provided whereby purity checks can be suppressed when necessary, in order to allow for functions which, although formally pure, may under the hood modify caches, update statistics, perform diagnostic I/O, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Emphasis on readability, at the expense of terseness when necessary.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Typing is &lt;em&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;/em&gt; one of the major problems faced by our profession; unreadable code is.&lt;/li&gt;
&lt;li&gt;The language should be suitable for universities to teach, so unlike Scala, it needs to have a low entry barrier.&lt;/li&gt;
&lt;li&gt;All language keywords are fully spelled out and avoid unnecessary technicalities .
&lt;ul&gt;
&lt;li&gt;No inelegant abbreviations like &lt;code&gt;fun&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;mut&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;A function is denoted by &lt;code&gt;function&lt;/code&gt;. (Duh!)&lt;/li&gt;
&lt;li&gt;A field is denoted by &lt;code&gt;field&lt;/code&gt;. (Duh!)&lt;/li&gt;
&lt;li&gt;A mutable field is denoted by &lt;code&gt;mutable field&lt;/code&gt;. (Duh!)&lt;/li&gt;
&lt;li&gt;A local is denoted by &lt;code&gt;local&lt;/code&gt;. (Duh!)&lt;/li&gt;
&lt;li&gt;A mutable local is denoted by &lt;code&gt;mutable local&lt;/code&gt;. (Duh!)&lt;/li&gt;
&lt;li&gt;The Boolean type is &lt;code&gt;boolean&lt;/code&gt;, not &lt;code&gt;bool&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The Integer type is &lt;code&gt;integer&lt;/code&gt;, not &lt;code&gt;int&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;Nobody will ever have to type &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;,
because any halfway decent code editor will give you &lt;code&gt;integer&lt;/code&gt; if
you just type &lt;code&gt;i&lt;/code&gt;, hit &lt;code&gt;Ctrl+Space&lt;/code&gt; to open up auto-completion,
and then &lt;code&gt;Enter&lt;/code&gt; to pick the first suggestion.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Long Integer type is &lt;code&gt;long integer&lt;/code&gt;, not &lt;code&gt;long&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The 64-bit IEEE floating point type is &lt;code&gt;real&lt;/code&gt;, not &lt;code&gt;double&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The 32-bit IEEE floating point type is &lt;code&gt;short real&lt;/code&gt;, not &lt;code&gt;float&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In general, the language aims to reduce the amount of parentheses.
&lt;ul&gt;
&lt;li&gt;Expressions may not be parenthesized, only sub-expressions may.
&lt;ul&gt;
&lt;li&gt;So, the popular construct &lt;code&gt;return (result)&lt;/code&gt; is not just redundant; it is actually a compiler error.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In general, the language favors words over punctuation, so:
&lt;ul&gt;
&lt;li&gt;Inheritance by means of &lt;code&gt;extends&lt;/code&gt; and &lt;code&gt;implements&lt;/code&gt; keywords as in Java instead of the &lt;code&gt;:&lt;/code&gt; character of C#.&lt;/li&gt;
&lt;li&gt;Fully spelled out &lt;code&gt;for each a in b do&lt;/code&gt; like C# instead of the &lt;code&gt;for( a : b )&lt;/code&gt; of Java.&lt;/li&gt;
&lt;li&gt;Boolean operators are words, like Pascal and Python and unlike the
C family.
&lt;ul&gt;
&lt;li&gt;i.e. the operators are &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;not&lt;/code&gt; instead of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The compiler handles boolean operators, applying operator precedence and short-circuit evaluation.&lt;/li&gt;
&lt;li&gt;The compiler maps all other operators to method calls, (observing operator precedence rules,) as follows:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a + b&lt;/code&gt; maps to &lt;code&gt;a.Plus( b )&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a - b&lt;/code&gt; maps to &lt;code&gt;a.Minus( b )&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a * b&lt;/code&gt; maps to &lt;code&gt;a.Times( b )&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a / b&lt;/code&gt; maps to &lt;code&gt;a.Per( b )&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a % b&lt;/code&gt; maps to &lt;code&gt;a.Modulo( b )&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a ^ b&lt;/code&gt; maps to &lt;code&gt;a.Power( b )&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a = b&lt;/code&gt; maps to &lt;code&gt;a.Equals( b )&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a &amp;amp;lt; b&lt;/code&gt; maps to &lt;code&gt;a.Below( b )&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a &amp;amp;gt; b&lt;/code&gt; maps to &lt;code&gt;a.Above( b )&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a != b&lt;/code&gt; maps to &lt;code&gt;not a.Equals( b )&lt;/code&gt;. (*)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a &amp;amp;lt;= b&lt;/code&gt; maps to &lt;code&gt;not a.Above( b )&lt;/code&gt;. (*)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a =&amp;amp;gt; b&lt;/code&gt; maps to &lt;code&gt;not a.Below( b )&lt;/code&gt;. (*)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt; maps to &lt;code&gt;a.Negative&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~a&lt;/code&gt; maps to &lt;code&gt;a.TwosComplement&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;++a&lt;/code&gt; maps to &lt;code&gt;a.PreIncrement()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a++&lt;/code&gt; maps to &lt;code&gt;a.PostIncrement()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;So, when we code &lt;code&gt;a + b&lt;/code&gt;, this will only compile if the type of &lt;code&gt;a&lt;/code&gt; has a function called &lt;code&gt;Plus&lt;/code&gt; with a parameter of the type of &lt;code&gt;b&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;(*) These negations are meant to save us from having to have negative forms of the functions; I think they are okay; it remains to be seen if there are situations where this will not work. NaN comes to mind as a possible pitfall, but then again a comparison against NaN should perhaps throw an exception.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Preference towards having only one way for any given thing.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When multiple ways of accomplishing the same thing are conceivable, the language design tries, when possible, and when it makes sense, to make a specific choice and prohibit all other ways. For example:
&lt;ul&gt;
&lt;li&gt;When it is unnecessary to qualify an instance member with &lt;code&gt;this&lt;/code&gt;, it is an error to qualify it.&lt;/li&gt;
&lt;li&gt;When it is unnecessary to qualify a static member with the class name, it is an error to qualify it.&lt;/li&gt;
&lt;li&gt;When the body of the &amp;quot;then&amp;quot; part of an &lt;code&gt;if&lt;/code&gt; statement never falls through (because it ends with either a &lt;code&gt;return&lt;/code&gt; or a &lt;code&gt;throw&lt;/code&gt; statement) it is an error to use the &lt;code&gt;else&lt;/code&gt; keyword.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Encapsulation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A nested scope has access to private members of the enclosing scope.&lt;/li&gt;
&lt;li&gt;The enclosing scope never has access to private members of nested scopes.
&lt;ul&gt;
&lt;li&gt;Note that this corrects the insanity of Java which allows an enclosing class to have access to private members of nested classes. (Duh!?)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;When a source file declares a namespace as public, only the classes in that source file are exported.
&lt;ul&gt;
&lt;li&gt;This stipulation is necessary since multiple source files may declare a namespace, but only some of those source files might declare the namespace as public.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A module may expose interfaces, enums, records (value types), and classes. However, when a module exposes a class, what actually gets exposed is only the interface of that class, not a class itself. In other words, the language will never expose across modules the constructor of a class, nor its protected methods. This has some very interesting implications:
&lt;ul&gt;
&lt;li&gt;All classes participating in an inheritance hierarchy must be defined within a single module: One cannot extend a class defined in another module.&lt;/li&gt;
&lt;li&gt;All classes participating in an inheritance hierarchy are known during the compilation of the module that contains the hierarchy.
&lt;ul&gt;
&lt;li&gt;This allows for certain useful optimizations.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The creation of a new instance of a class defined in another module cannot be accomplished by invoking a constructor; it can only be accomplished via a factory method.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Memory management: Reference counting instead of garbage-collection.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The memory model looks a lot like the memory model of Java and C#:
&lt;ul&gt;
&lt;li&gt;The heap consists of big chunks of memory that are allocated from the operating system at once. The runtime does its own memory management within these chunks, for efficiency.&lt;/li&gt;
&lt;li&gt;Objects are actually pointers to objects that live on the heap.&lt;/li&gt;
&lt;li&gt;Pointers cannot be manipulated as they can in C++.&lt;/li&gt;
&lt;li&gt;Value types live either in local storage or as members of other types.&lt;/li&gt;
&lt;li&gt;When necessary, value types can be treated as reference types by means of boxing.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pointers are implemented as smart (shared) pointers, so that:
&lt;ul&gt;
&lt;li&gt;There is no need for garbage collection.&lt;/li&gt;
&lt;li&gt;There is no need for each object to have its own lock.&lt;/li&gt;
&lt;li&gt;There is no need for finalization.&lt;/li&gt;
&lt;li&gt;There are no preposterous situations like object resurrection.&lt;/li&gt;
&lt;li&gt;There are fewer sources of randomness and non-determinism in the memory layout and in the responsiveness of the code.&lt;/li&gt;
&lt;li&gt;Destruction is assured and immediate the moment an object ceases to be referenced.&lt;/li&gt;
&lt;li&gt;Destruction involves real destructors as in C++.&lt;/li&gt;
&lt;li&gt;While a destructor executes, all objects referenced by the object being destructed are guaranteed to still be present and alive. (Unlike garbage-collected languages, where finalizers have to cope with the fact that some of the referenced objects may have already been collected.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The reference count is accommodated in the object itself, so smart pointers can be appreciably more lightweight than in C++.&lt;/li&gt;
&lt;li&gt;The runtime may choose to implement smart pointers using double indirection, so as to be able to perform memory defragmentation.&lt;/li&gt;
&lt;li&gt;Addressing the pitfalls of reference counting:
&lt;ul&gt;
&lt;li&gt;Reference counting suffers from two pitfalls:
&lt;ul&gt;
&lt;li&gt;Long reference chains:
&lt;ul&gt;
&lt;li&gt;May result in stack overflow when disposed.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Circular references:
&lt;ul&gt;
&lt;li&gt;Result in memory leaks.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We address these pitfalls as follows:
&lt;ul&gt;
&lt;li&gt;Long reference chains:
&lt;ul&gt;
&lt;li&gt;We solve this by making destructors deliberately fail if they are ever re-entered, so that we can detect the deallocation of even the smallest chain that consists of only two nodes. The programmer can then modify their code to do one of the following:
&lt;ul&gt;
&lt;li&gt;Manually perform the destruction of the chain in a way that avoids recursion.&lt;/li&gt;
&lt;li&gt;Refactor things so that the objects are kept in a collection instead of forming an ad-hoc chain.&lt;/li&gt;
&lt;li&gt;Explicitly unlink and destroy the chain using the &lt;code&gt;delete chain&lt;/code&gt; keyword, which works in a non-recursive way.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Circular references:
&lt;ul&gt;
&lt;li&gt;A debug-time-only mark-sweep checker that runs on its own thread detects leaked cyclic object graphs and warns the programmer about them. (It does not attempt to fix anything.) The programmer can then modify their code to do one of the following:
&lt;ul&gt;
&lt;li&gt;Break any cycles in the graph before unlinking it.&lt;/li&gt;
&lt;li&gt;Explicitly unlink and destroy the cyclic graph using the &lt;code&gt;delete cyclic&lt;/code&gt; keyword, which gracefully handles cyclic object graphs.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;These means of addressing the pitfalls of reference counting are not perfect, so some extra maintenance will sometimes be required. For example, we might think that we are properly handling all cyclic object graphs, but as a result of a change somewhere, we may now discover that we have a new cyclic object graph, which we must deal with; Still, the extra trouble is expected to be rare, and it is expected to be very well worth all the trouble we save by not having to have a garbage collector.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Of interest: &lt;a class="external"
href="https://verdagon.dev/blog/hybrid-generational-memory" target="_blank"
&gt;https://verdagon.dev/blog/hybrid-generational-memory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Constructor syntax like Scala.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Constructor parameters in the class header.&lt;/li&gt;
&lt;li&gt;Constructor code in the class body. (With the additional restriction that it must all appear up-front.)&lt;/li&gt;
&lt;li&gt;Additional constructors by means of static factory methods.&lt;/li&gt;
&lt;li&gt;Any constructor parameters that are referenced by methods automatically become fields so that we do not have to declare extra fields and initialize them from the parameters.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Strong distinction between release runs and debug runs.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(But not necessarily different builds; Optimization is a JIT concern.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Externally supplied constant values.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A special type of constant can be defined, whose value is not specified in the source code, and must instead be supplied later:
&lt;ul&gt;
&lt;li&gt;During compilation, by means of a special parameter to the compiler, or&lt;/li&gt;
&lt;li&gt;At runtime, by means of a special parameter to the launcher.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;These constants are better than C-style &amp;quot;manifest constants&amp;quot; and C#-style &amp;quot;defined symbols&amp;quot; because they are well defined, strongly typed, mandatory, and obey normal static immutable field rules. This means that:
&lt;ul&gt;
&lt;li&gt;It is possible to know the set of all external constants that must be defined in order to compile and run something.&lt;/li&gt;
&lt;li&gt;An attempt to compile or run something without supplying all external constant values will always result in an error.&lt;/li&gt;
&lt;li&gt;An attempt to supply an external constant value for a non-existent external constant will always result in an error.&lt;/li&gt;
&lt;li&gt;Each externally supplied constant value must be of the correct type expected by the constant declared in the code.&lt;/li&gt;
&lt;li&gt;When using external constants for conditional compilation, the code paths that are not selected will result in no code being generated, but must still pass compilation, so there is no danger of code rot.&lt;/li&gt;
&lt;li&gt;With some help from the loader we can write tests that exercise code under different values for runtime-supplied external constants.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Integer types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fixed Integer types with explicitly defined sizes, as per C#.&lt;/li&gt;
&lt;li&gt;Flex integer types whose size is determined by the runtime according to what is most efficient for the underlying hardware architecture.
&lt;ul&gt;
&lt;li&gt;Each flex integer has a &amp;quot;Guaranteed Width&amp;quot;, which is the minimum width that this integer is guaranteed to have on any hardware architecture.
These widths are:
&lt;ul&gt;
&lt;li&gt;8 bits for &lt;code&gt;tiny integer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;16 bits for &lt;code&gt;short integer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;32 bits for &lt;code&gt;integer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;64 bits for &lt;code&gt;long integer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;On debug runs, the runtime checks all operations on flex integers, and if there is an overflow past the guaranteed width, a runtime exception is thrown. Thus, we ensure consistent flex integer behavior on any architecture.&lt;/li&gt;
&lt;li&gt;This corrects the narrow-mindedness of C# where &lt;code&gt;int&lt;/code&gt; has been defined to be exactly 32 bits long, even on architectures with a larger machine word size. (Which is pretty much all major architectures today that 64-bit is the norm.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Full set of signed and unsigned integers as per C#, both for the fixed and flex flavors.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exceptions&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lightweight exceptions that are inexpensive to throw and to catch.&lt;/li&gt;
&lt;li&gt;No such thing as the &amp;quot;checked&amp;quot; exceptions of Java.&lt;/li&gt;
&lt;li&gt;No extra baggage:
&lt;ul&gt;
&lt;li&gt;The base &lt;code&gt;Exception&lt;/code&gt; class does not even have a &amp;quot;message&amp;quot;, let alone a
&amp;quot;localized message&amp;quot;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;ToString()&lt;/code&gt; method of the base &lt;code&gt;Exception&lt;/code&gt; class:
&lt;ul&gt;
&lt;li&gt;Is not overridable.&lt;/li&gt;
&lt;li&gt;Yields a string consisting of the class name of the exception followed by the name and the string representation of the value of each one of its fields, obtained using reflection.&lt;/li&gt;
&lt;li&gt;If you want an exception to result in a human-readable error message that you can actually show to an end user, you have to accomplish this entirely by yourself. (Please make sure to do this in the end-user's native language, which, statistically speaking, is unlikely to be English.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Standard Collections Model&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The standard language runtime provides the following:
&lt;ul&gt;
&lt;li&gt;An assortment of unmodifiable collection interfaces: &lt;code&gt;Enumerable&lt;/code&gt;, &lt;code&gt;Collection&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enumerable&lt;/code&gt; exposes a property for accessing the current element, and separate methods for checking whether there exist more elements and for advancing to the next element, as in C#.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;Collection&lt;/code&gt; is an &lt;code&gt;Enumerable&lt;/code&gt; with a length and the ability to check whether it contains a certain element, as in Java.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt; is also a collection of &lt;code&gt;Map.Entry&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;This is as in C#, where a &lt;code&gt;Dictionary&lt;/code&gt; is a collection of &lt;code&gt;KeyValuePair&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;This is unlike Java, where &lt;code&gt;Map&lt;/code&gt; is not a collection, and in order to obtain the collection of entries you must invoke &lt;code&gt;Map.entrySet()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Factory methods create immutable collection classes implementing the unmodifiable collection interfaces.&lt;/li&gt;
&lt;li&gt;An assortment of &amp;quot;rigid&amp;quot; (i.e. mutable, but structurally immutable) interfaces which extend the unmodifiable interfaces adding methods to replace existing items but no methods to add or remove items: &lt;code&gt;RigidEnumerable&lt;/code&gt;, &lt;code&gt;RigidCollection&lt;/code&gt;, &lt;code&gt;RigidList&lt;/code&gt;, &lt;code&gt;RigidMap&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;An assortment of mutable collection interfaces which extend the rigid interfaces adding add/remove/clear methods: &lt;code&gt;MutableEnumerable&lt;/code&gt;, &lt;code&gt;MutableCollection&lt;/code&gt;, &lt;code&gt;MutableList&lt;/code&gt;, &lt;code&gt;MutableMap&lt;/code&gt;, &lt;code&gt;Queue&lt;/code&gt;, &lt;code&gt;Stack&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;MutableCollections&lt;/code&gt; factory exposing methods that create mutable collection classes implementing the mutable collection interfaces.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Values&lt;/code&gt; collection of a mutable map returns a &lt;code&gt;RigidCollection&lt;/code&gt; of map values, so that:
&lt;ul&gt;
&lt;li&gt;You can replace an element in this collection, which will have the side-effect of associating an existing key with a new value.&lt;/li&gt;
&lt;li&gt;You cannot add an element to this collection, which makes sense because you have no means of specifying the key that should map to the newly inserted value.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The method for adding an item to a collection is called 'Add', not 'Push'.
&lt;ul&gt;
&lt;li&gt;For consistency, even the &lt;code&gt;Stack&lt;/code&gt; collection exposes an &lt;code&gt;Add&lt;/code&gt; method, not a &lt;code&gt;Push&lt;/code&gt; method.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Collaboration between the language runtime and collections:
&lt;ul&gt;
&lt;li&gt;The for-each loop operates on &lt;code&gt;Enumerable&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;The loop variable can be reassigned, causing the current element of the Enumerable to be replaced with a new value. In this case, the for-each loop requires a &lt;code&gt;RigidEnumerable&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A special keyword allows removing the current item, in which case the for-each loop requires a &lt;code&gt;MutableEnumerable&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Since we have proper destructors, there is no need for special handling of disposable enumerators. (Something which C# provides, but Java lacks.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;An array literal evaluates to an instance of &lt;code&gt;RigidList&lt;/code&gt;, so the language is free from arrays, like Scala.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Heavy promotion of assertions and plenty of built-in extra error-checking on debug runs, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arithmetic checking
&lt;ul&gt;
&lt;li&gt;An exception is thrown when any of the following occurs:
&lt;ul&gt;
&lt;li&gt;Division by zero.&lt;/li&gt;
&lt;li&gt;Fixed integral type overflow. (This can be selectively suppressed on an individual expression basis as with the &amp;quot;unchecked&amp;quot; keyword of C#.)&lt;/li&gt;
&lt;li&gt;Flex integer guaranteed width overflow.&lt;/li&gt;
&lt;li&gt;(Possibly) Operations on NaNs.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Throwing Switches
&lt;ul&gt;
&lt;li&gt;If the switch data type is exhaustively switchable (e.g. boolean):
&lt;ul&gt;
&lt;li&gt;It is an error if not all cases are covered and no default case is provided.&lt;/li&gt;
&lt;li&gt;It is an error if all cases are covered and a default case is provided.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If the switch data type is not exhaustively switchable (e.g. integer):
&lt;ul&gt;
&lt;li&gt;If no default case is provided, an implicit default case is supplied by the compiler which throws an exception.&lt;/li&gt;
&lt;li&gt;This plays nicely with code coverage: no more uncoverable assertions in unreachable default clauses.&lt;/li&gt;
&lt;li&gt;If you want a switch statement with default case fall-through on a non-exhaustively switchable type, add an empty &lt;code&gt;default&lt;/code&gt; case. (Duh!)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Big on warnings and errors.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Most things traditionally thought of as warnings are errors.&lt;/li&gt;
&lt;li&gt;Most checks of the kind that IntelliJ IDEA calls &amp;quot;inspections&amp;quot; are built-into the language as warnings, many of them even as errors.&lt;/li&gt;
&lt;li&gt;Selective warning suppression only; no bulk suppression.
&lt;ul&gt;
&lt;li&gt;Warning suppression is possible only on the individual statement where the problem occurs, never on a larger scope.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Warnings always cause compilation to fail.
&lt;ul&gt;
&lt;li&gt;It is as if a &amp;quot;treat warnings as errors&amp;quot; option is always on and cannot be turned off.&lt;/li&gt;
&lt;li&gt;The difference between warnings and errors is &lt;em&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;/em&gt; that you can ignore warnings and proceed to run; the difference is that a warning can be suppressed, whereas an error cannot.&lt;/li&gt;
&lt;li&gt;Furthermore, the language designates a message as a warning or an error based &lt;em&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;/em&gt; on its severity, but instead on whether the programmer can reasonably be required to fix it or not.
&lt;ul&gt;
&lt;li&gt;If it is reasonable to require the programmer to fix it, then the programmer better fix it, so there is no need to be able to suppress it, so it is an error.&lt;/li&gt;
&lt;li&gt;If it is unreasonable to require the programmer to fix it, then the programmer should be able to suppress it, so it is a warning.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For example:
&lt;ul&gt;
&lt;li&gt;If you have an unused import statement, you can very easily remove that import statement, so it is reasonable to require you to fix it. Therefore, the &amp;quot;unused import&amp;quot; message is an error.&lt;/li&gt;
&lt;li&gt;If you have marked something as deprecated, and yet you must still make use of it in a couple of places until the day that it gets completely removed, then you have no way of fixing this problem, therefore you must be allowed to suppress it, therefore the &amp;quot;use of deprecated symbol&amp;quot; message is a warning. You will, however, have to explicitly suppress that warning on each and every usage of that symbol.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A warning suppression on a statement that does not actually produce a warning is an error.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Syntax:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Line-oriented, with scoping dictated by indentation (roughly as in Python) instead of curly braces.
&lt;ul&gt;
&lt;li&gt;Since it is very difficult (if not impossible) to express indentation rules in a formal grammar, this is handled by the tokenizer:
&lt;ul&gt;
&lt;li&gt;When the indentation increases, the tokenizer emits a hidden scope-start token.&lt;/li&gt;
&lt;li&gt;When the indentation decreases, the tokenizer emits a hidden scope-end token.&lt;/li&gt;
&lt;li&gt;The tokenizer also handles line breaking and line joining, so that the parser ends up parsing a C-style language.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;There are two types of statements: simple and compound.
&lt;ul&gt;
&lt;li&gt;A simple statement occupies a single line; it may contain expressions, but it may not contain any nested scopes.&lt;/li&gt;
&lt;li&gt;A compound statement begins with a simple statement as a header, and is followed by a dependent scope.&lt;/li&gt;
&lt;li&gt;A scope contains statements, which may in turn be either simple or compound.&lt;/li&gt;
&lt;li&gt;Some constructs that normally correspond to compound statements (e.g. the &lt;code&gt;if&lt;/code&gt; statement) also come in &amp;quot;expression form&amp;quot;.
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;for&lt;/code&gt; loop does not have an expression form, due to the extra complexity of the multiple statements that it contains; however, the &lt;code&gt;for-each&lt;/code&gt; loop does come in expression form.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Normally, each simple statement must be on a separate line.&lt;/li&gt;
&lt;li&gt;To allow joining multiple simple statements in one line, a special line-joining punctuation is used, which is the semicolon.&lt;/li&gt;
&lt;li&gt;Therefore, the semicolon is illegal at the end of a line.&lt;/li&gt;
&lt;li&gt;Normally, an entire simple statement must be contained within a single line; in other words, a simple statement may not span multiple lines.&lt;/li&gt;
&lt;li&gt;To allow splitting a simple statement into multiple lines, a special line-splitting construct is used. This construct is to be determined:
&lt;ul&gt;
&lt;li&gt;It may be a backslash at the end of the line that is being split into the next&lt;/li&gt;
&lt;li&gt;It may be double the amount of indentation on the next line, signifying that it belongs to the previous one.&lt;/li&gt;
&lt;li&gt;It may be both of the above.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Formatting:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The code formatting style of the language is thoroughly and unambiguously defined by an extensive set of rules.&lt;/li&gt;
&lt;li&gt;Some degree of freedom is allowed, but even that is unambiguously controlled by special punctuation that exists specifically for that purpose.&lt;/li&gt;
&lt;li&gt;This means that the formatting of a source file is thoroughly, accurately, and deterministically predictable from the language formatting rules and the punctuation present within the file.&lt;/li&gt;
&lt;li&gt;This in turn allows code editors that can:
&lt;ul&gt;
&lt;li&gt;at any moment reflow an entire source file to its proper format, or even:&lt;/li&gt;
&lt;li&gt;continuously reflow code, as it is being typed, to its proper format.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;This in turn allows a compiler which imposes strict enforcement of the formatting rules, so that the slightest deviation, even by a single space, is a compiler error.&lt;/li&gt;
&lt;li&gt;This brings us to the following paradox:
&lt;ul&gt;
&lt;li&gt;Even though the formatting rules are extremely detailed,&lt;/li&gt;
&lt;li&gt;And even though the enforcement of the formatting rules is draconian,&lt;/li&gt;
&lt;li&gt;The programmer never has to worry about code formatting, because it is being taken care of automatically.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The benefit of all this is that all code by all programmers will always have the exact same formatting, and yet no programmer will ever have to be bothered with having to type code in a specific way.&lt;/li&gt;
&lt;li&gt;(It will also make the language parser slightly faster.)&lt;/li&gt;
&lt;li&gt;Some indicative highlights of the formatting rules:
&lt;ul&gt;
&lt;li&gt;Tabs for indentation
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;tab&lt;/code&gt; character denotes indentation, and may only appear at the beginning of a line; it is prohibited anywhere else.&lt;/li&gt;
&lt;li&gt;Only the &lt;code&gt;tab&lt;/code&gt; character may be used to denote indentation; the use of anything else to denote indentation, including the space character, is an error.&lt;/li&gt;
&lt;li&gt;It is an error to have indentation in a line which is otherwise blank.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The language defines where a space may and may not appear.
&lt;ul&gt;
&lt;li&gt;When a space is expected, exactly one space must be given. (For example, right after a comma.)&lt;/li&gt;
&lt;li&gt;When zero spaces are expected, exactly zero spaces must be given. (For example, right before a comma.)&lt;/li&gt;
&lt;li&gt;Note that this prevents tabular code formatting, which is the practice of inserting spaces to column-align similar parts of consecutive statements.
&lt;ul&gt;
&lt;li&gt;That is okay, because tabular code formatting is a bad idea anyway, since it is a source of needless git merge conflicts.&lt;/li&gt;
&lt;li&gt;In any case, if some folks really need tabular code formatting, they can achieve it via spacing comments ( /* */ ).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The language strictly defines when and how blank lines may be used. For example:
&lt;ul&gt;
&lt;li&gt;There must never be two consecutive blank lines anywhere, at all, under any circumstances, for any reason, ever.&lt;/li&gt;
&lt;li&gt;There must always be exactly one blank line before a block comment. (Even a single-line block comment.)
&lt;ul&gt;
&lt;li&gt;If you want a comment without a blank line, then use a line comment instead of a block comment.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;There must never be a blank line anywhere else, including:
&lt;ul&gt;
&lt;li&gt;Between method definitions.
&lt;ul&gt;
&lt;li&gt;This allows us to define whole groups of single-line methods without wasting a lot of screen real estate.&lt;/li&gt;
&lt;li&gt;If you want blank lines between method definitions, add a block comment before each method definition; thus, a blank line will be mandatory before the block comment.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Between lines of code.
&lt;ul&gt;
&lt;li&gt;Most programmers have the habit of using blank lines within method bodies, to separate logical groups of lines of code. This is bad practice, because only the programmer who wrote the code knows why those lines form a separate group and why that group should stand out from the rest.&lt;/li&gt;
&lt;li&gt;If you have multiple conceptually distinct groups of lines of code within a single method, then either:
&lt;ul&gt;
&lt;li&gt;Add block comments explaining what each group does, (in which case a blank line before the block comment is mandatory,)
or&lt;/li&gt;
&lt;li&gt;Move each group into a separate function, and give the function a descriptive name.
&lt;ul&gt;
&lt;li&gt;The language supports functions nested within functions, so you can do this without polluting the namespace of the class.&lt;/li&gt;
&lt;li&gt;The language uses no curly braces, so you will not be wasting a lot of screen real estate in doing so.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Between class definitions.
&lt;ul&gt;
&lt;li&gt;This allows us to define whole groups of single-line classes without wasting a lot of screen real estate. Admittedly, single-line classes are rare, so let's just say that this rule exists just for consistency.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Special formatting punctuation allows overriding language default formatting rules on a case per case basis. For example:
&lt;ul&gt;
&lt;li&gt;A &amp;quot;line splitter&amp;quot; is a special punctuation character which allows splitting a construct into multiple lines when the language formatting rules would have normally required that construct to be all in one line.
&lt;ul&gt;
&lt;li&gt;For example: the language formatting rule for expressions is that an expression must fit in one line; so, if an expression needs to span multiple lines, a line splitter must be used to indicate precisely at which point the expression is to break into the next line.&lt;/li&gt;
&lt;li&gt;The use of a line splitter in a place where it is not required is an error.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The &amp;quot;line joiner&amp;quot; is a special punctuation character which allows a construct to appear all in one line when the language formatting rules would have normally required that construct to be split into multiple lines.
&lt;ul&gt;
&lt;li&gt;For example: the language formatting rule for methods is that the body of the method must be on a separate line from the prototype. So, if a very short method needs to fit entirely in one line, a line joiner can be used to allow this.&lt;/li&gt;
&lt;li&gt;The use of a line joiner in a place where it is not required is an error.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Capitalization
&lt;ul&gt;
&lt;li&gt;The language is case sensitive, and capitalization matters a lot more than in other languages.&lt;/li&gt;
&lt;li&gt;Identifier casing must be one of the following:
&lt;ul&gt;
&lt;li&gt;lowercase&lt;/li&gt;
&lt;li&gt;SentenceCase&lt;/li&gt;
&lt;li&gt;kebab-case&lt;/li&gt;
&lt;li&gt;SentenceKebab-case&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Note that kebab-case is possible because the language mandates spacing around operators, so there is no possibility to confuse an identifier containing a dash with the dash operator between two identifiers.&lt;/li&gt;
&lt;li&gt;The following are expressly disallowed:
&lt;ul&gt;
&lt;li&gt;The dash as first or last character of an identifier.&lt;/li&gt;
&lt;li&gt;camelCase.&lt;/li&gt;
&lt;li&gt;UPPERCASE and SCREAMING-KEBAB-CASE.&lt;/li&gt;
&lt;li&gt;Two or more consecutive capital letters.
&lt;ul&gt;
&lt;li&gt;For an explanation why, see the following section about spell-checking.&lt;/li&gt;
&lt;li&gt;Separate capital letters with dashes; for example, &lt;code&gt;XSpacing&lt;/code&gt; is not allowed, but &lt;code&gt;X-Spacing&lt;/code&gt; is fine.&lt;/li&gt;
&lt;li&gt;Do not use acronyms; use either:
&lt;ul&gt;
&lt;li&gt;fully spelled out words, i.e.. &amp;quot;GraphicalUserInterfaceStyle&amp;quot;, or&lt;/li&gt;
&lt;li&gt;words that replace acronyms, i.e. &amp;quot;GuiStyle&amp;quot;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Underscores and all forms of snake_case. (Though an underscore alone might act as a special identifier, or special punctuation, to be determined.)
&lt;ul&gt;
&lt;li&gt;This is because we support kebab-case, and snake_case does not look sufficiently different from kebab-case.&lt;/li&gt;
&lt;li&gt;Kebab-case is preferable to snake_case because on most keyboards the dash is slightly easier to produce than the underscore, since it does not require Shift.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Some capitalization rules apply to language constructs and are enforced by the compiler:
&lt;ul&gt;
&lt;li&gt;All names of types and namespaces must start with an uppercase letter.&lt;/li&gt;
&lt;li&gt;All public and protected member names must start with an uppercase letter.&lt;/li&gt;
&lt;li&gt;All private members must start with a lowercase letter.&lt;/li&gt;
&lt;li&gt;All local and parameter names must start with a lowercase letter.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Spell Checking
&lt;ul&gt;
&lt;li&gt;The language comes together with a spell-checking dictionary, the contents of which are part of the language specification.&lt;/li&gt;
&lt;li&gt;A module can have a supplemental user-defined spell-checking dictionary file which:
&lt;ul&gt;
&lt;li&gt;Is meant to be committed to source control&lt;/li&gt;
&lt;li&gt;Is meant to undergo code review just as any other source file.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The compiler spell-checks source code and issues a warning if it encounters any unrecognized words.
&lt;ul&gt;
&lt;li&gt;Specifically, the compiler will issue a warning when any of the following fails to pass spell-check:
&lt;ul&gt;
&lt;li&gt;Any part of an identifier.&lt;/li&gt;
&lt;li&gt;A word inside a string literal.&lt;/li&gt;
&lt;li&gt;A word in a comment, unless it is markup referring to an identifier.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For the purpose of spell-checking, identifiers are broken into parts based on SentenceCase and kebab-case boundaries, as well as boundaries between letters and digits. This means that:
&lt;ul&gt;
&lt;li&gt;&amp;quot;CryptoGraphy&amp;quot; will not pass spell-check unless &amp;quot;graphy&amp;quot; has been added to the spell-checker. (It shouldn't; it is not an English word; use &amp;quot;Cryptography&amp;quot; instead.)&lt;/li&gt;
&lt;li&gt;&amp;quot;Mousepointer&amp;quot; will not pass spell-check unless &lt;code&gt;mousepointer&lt;/code&gt; has been added to the spell-checker. (It shouldn't; it is not an English word; use &amp;quot;MousePointer&amp;quot; instead.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A warning for a misspelled identifier is issued only at the point of definition and not on each occurrence of the identifier, so that:
&lt;ul&gt;
&lt;li&gt;You only see the warning once, not five hundred times.&lt;/li&gt;
&lt;li&gt;There is no warning at all for identifiers that you have no control over, due to them being defined in external modules. In other words, a module does not have to duplicate the spelling dictionaries of external modules, nor does a module have to ship with its spelling dictionary.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Two or more consecutive capital letters are disallowed because:
&lt;ul&gt;
&lt;li&gt;Each individual capital letter acts as a word delimiter, so it constitutes a word by itself.&lt;/li&gt;
&lt;li&gt;To allow for single-letter variables, every individual letter passse spell-check.&lt;/li&gt;
&lt;li&gt;So, a word made of capital letters circumvents the spell-checker.&lt;/li&gt;
&lt;li&gt;The language does not allow circumventing the spell-checker.
&lt;ul&gt;
&lt;li&gt;(One day someone will inevitably submit a feature request for some means of disabling the spell checker; the answer they will receive is that if they do not have to use this language; there are so many other languages to choose from.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Comments&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Special formatting within comments is achievable with the use of &lt;code&gt;Markdown&lt;/code&gt; as opposed to HTML or any ad-hoc syntax.&lt;/li&gt;
&lt;li&gt;This special formatting is available in all comments, not just doc-comments.&lt;/li&gt;
&lt;li&gt;Some extensions to markdown are necessary in order to specify relationships between code.
&lt;ul&gt;
&lt;li&gt;For example, when defining a link, one can omit the part within the parentheses, in which case the part within the square brackets is expected to be a resolvable symbol, and the resulting link points to that symbol.&lt;/li&gt;
&lt;li&gt;The syntax for specifying the symbol requires no gimmicks like the hash-sign which is needed in Java's doc-comments to separate the type name from the member name.&lt;/li&gt;
&lt;li&gt;If the symbol is not fully qualified then there must be an import statement for that symbol somewhere within the source file.&lt;/li&gt;
&lt;li&gt;The use of a symbol in a comment is enough to prevent the corresponding import statement from being flagged by the compiler as unused.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Possibly: allow the comment that describes a parameter to be placed with the parameter itself.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Inheritance&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A class may extend only one other class but implement any number of interfaces.&lt;/li&gt;
&lt;li&gt;The only difference between a class and an interface is that an interface cannot have fields, a constructor, or a destructor; in all other respects, classes and interfaces are equivalent, meaning that an interface can have
static, public, protected, and private methods.&lt;/li&gt;
&lt;li&gt;By default, a class cannot be extended unless it is marked as &lt;code&gt;extensible&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;By default, a method of a class cannot be overridden/extended unless it is marked as follows:
&lt;ul&gt;
&lt;li&gt;If it is abstract, it must be marked as &lt;code&gt;abstract&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If it is overridable, must be marked as &lt;code&gt;overridable&lt;/code&gt;. (Duh!)
&lt;ul&gt;
&lt;li&gt;This corrects Java's exuberance of allowing any method to be overridden unless declared &amp;quot;final&amp;quot;, and C#'s unwarranted technicalism of calling such methods &amp;quot;virtual&amp;quot;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If it is overridable with the provision that overriding methods must invoke the base method, it must be marked as &lt;code&gt;extensible&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Methods that override other methods must be marked as follows:
&lt;ul&gt;
&lt;li&gt;A class method which implements an abstract method must be marked with &lt;code&gt;implements base&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A class method which overrides an overridable method must be marked with &lt;code&gt;overrides base&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A class method which extends an extensible method must be marked with &lt;code&gt;extends base&lt;/code&gt;. Within the extending method:
&lt;ul&gt;
&lt;li&gt;The base method must be invoked exactly once.
&lt;ul&gt;
&lt;li&gt;(This can become a bit complicated with alternative execution paths, so we might want to mandate that there must be only one possible execution path at the point where the base method is invoked.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The invocation of the base method can be simplified:
&lt;ul&gt;
&lt;li&gt;The name of the method can be replaced with &lt;code&gt;base&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The parameters can be omitted.
&lt;ul&gt;
&lt;li&gt;In this case the base method is invoked with the values that the parameters have at the moment of the invocation, allowing the extending method to alter the values of the parameters before invoking base.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A class method which implements a method of an interface must be marked with &lt;code&gt;implements X&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;X is the interface-qualified-method-name of the method being implemented. The implementing method name may differ from the implemented method name (as long as the parameter list matches) and it will be accessible via both names.&lt;/li&gt;
&lt;li&gt;X can also be a comma-separated list of interface-qualified-function-names, if the method implements multiple interface methods of different interfaces. In this case, the method will be accessible via any of the names.&lt;/li&gt;
&lt;li&gt;Note that this corrects the stupidity of C# where no special marking is necessary for a class method that implements an interface method.&lt;/li&gt;
&lt;li&gt;Note that C# provides a syntax for optionally specifying that a class method implements a method of a particular interface, but makes the implementing methods inaccessible, which renders the feature unusable.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Note that a class method may both override a superclass method and implement interface methods by adding both &lt;code&gt;overrides&lt;/code&gt; and &lt;code&gt;implements&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A class method does not automatically become overridable or extensible by virtue of implementing, overriding, or extending another method; it must in turn be marked as overridable or extensible if that is the intention.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Built-in Intertwine.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Built-in Domain-Oriented Programming features.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alternatively, look into Scala's implicit parameter lists.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Built-in support for testing.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bundled Testana, see &lt;a
href="https://blog.michael.gr/post/2024-10-testana/"
&gt;Testana: A better way of running tests&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Somewhat different testing semantics than JUnit:
&lt;ul&gt;
&lt;li&gt;The test class does not get re-instantiated prior to invoking each test method.&lt;/li&gt;
&lt;li&gt;No 'before' method: use the test class constructor for this.&lt;/li&gt;
&lt;li&gt;No 'after' method: use the test class destructor for this.&lt;/li&gt;
&lt;li&gt;Use of the exact same assertion facility for test code as for production code.&lt;/li&gt;
&lt;li&gt;No other test facility gimmicks like &amp;quot;expect&amp;quot;, &amp;quot;assume&amp;quot;, etc.: write the darn thing in code.&lt;/li&gt;
&lt;li&gt;Test methods are always executed in the order in which they appear in the source file.&lt;/li&gt;
&lt;li&gt;When a test class is derived from another test class, the test methods of the base class are always executed before the test methods of the derived class.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To enable separate testing of debug runs and release runs, assertions are always enabled for the testing code, but for the code-under-test they can be either enabled or disabled.&lt;/li&gt;
&lt;li&gt;Even though all source files that constitute a module are compiled into a single binary file, (as per C# assemblies,) each class within that binary file comes with its own timestamp, to accommodate tools like
Testana.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(Possibly) Explicit distinction between logic classes and data classes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(Possibly) Built-in versioned externalization of data classes.&lt;/li&gt;
&lt;li&gt;(Possibly) Built-in data-modelling framework for the data classes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Built-in internationalization features (i.e. Unicode strings and culture-aware operations) but also full support for ANSI strings and culture-neutral operations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lightweight properties, exactly like in C#, with additional compiler support for obtaining a property as a separate entity and manipulating it independently of the object that it belongs to. (Probably a value type containing a reference to the object that owns the property and a reference to the reflection object that represents the property.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NO compiler support for events.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Time Coordinate Data Type&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Internally represented as a 64-bit IEEE floating point number of days since some epoch, allowing for:
&lt;ul&gt;
&lt;li&gt;low-precision coordinates billions of years away from the epoch&lt;/li&gt;
&lt;li&gt;femtosecond precision coordinates near the epoch.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A special static &amp;quot;this&amp;quot; keyword (&lt;code&gt;this class&lt;/code&gt;?) that you can use to refer to the current type in a static context without having to code the name of the type as you have to do in Java and in C#.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Proper method literals and field literals&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No compromise like the &lt;code&gt;nameof()&lt;/code&gt; of C#.&lt;/li&gt;
&lt;li&gt;For example:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Method m = method someMethod;&lt;/code&gt; assigns to &lt;code&gt;m&lt;/code&gt; the reflection method object of someMethod but causes a compiler error if someMethod has overloads.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Method m = method someMethod(int);&lt;/code&gt; assigns to &lt;code&gt;m&lt;/code&gt; the reflection method object of a specific overload of someMethod.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Method m = this method;&lt;/code&gt; assigns to &lt;code&gt;m&lt;/code&gt; the reflection method object of the method that is currently being compiled.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Field f = field someField;&lt;/code&gt; assigns to &lt;code&gt;f&lt;/code&gt; the reflection field object of someField.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Source intrinsics&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A source-line intrinsic similar to the &lt;code&gt;__LINE__&lt;/code&gt; macro of C and C++ or the &lt;code&gt;[CallerLineNumber]&lt;/code&gt; attribute of C#.&lt;/li&gt;
&lt;li&gt;A source-file intrinsic similar to the &lt;code&gt;__FILE__&lt;/code&gt; macro of C and C++ or the &lt;code&gt;[CallerFileName]&lt;/code&gt; attribute of C#. Note that the source filename yielded by this intrinsic is relative to the root of the source tree, &lt;em&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;/em&gt; absolute.&lt;/li&gt;
&lt;li&gt;A source-root intrinsic which yields the absolute path to the root of the source tree.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Namespaces, mostly as seen in C#, but with some differences.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You cannot just import a namespace and make everything in it accessible; instead, you have to do one of the following:
&lt;ul&gt;
&lt;li&gt;Import a specific name from a namespace; (like a java import statement without a wildcard;) then, you can use that one name without qualification.&lt;/li&gt;
&lt;li&gt;Import an entire namespace, but with a namespace alias, like in XML; then, you can use any name from that namespace, but each name will have to be qualified with the chosen alias.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Compiler-enforced conformity between directory names and namespace names, as in java, and unlike C#. (Or, as in C# with ReSharper.)&lt;/li&gt;
&lt;li&gt;Compiler-enforced conformity between source file names and class names, as in Java and unlike C#, with a couple of differences:
&lt;ul&gt;
&lt;li&gt;The file name of a source file may match a namespace defined in that file.&lt;/li&gt;
&lt;li&gt;The file name of a source file may match the base-most class defined in the file, but the file may also contain additional classes derived from it.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;System functionality injection&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;System functionality is available strictly via interfaces.&lt;/li&gt;
&lt;li&gt;The main entry point function of a program declares in its argument list each system interface that it intends to use. Yes, this can become unwieldly; and yet that's how it is going to be.&lt;/li&gt;
&lt;li&gt;When about to run an application, the runtime uses reflection to discover which interfaces are needed by the entry point, and passes each one of them to it.&lt;/li&gt;
&lt;li&gt;From that moment on, user code makes sure to propagate system interfaces to all application code that needs them.&lt;/li&gt;
&lt;li&gt;This means that no system functionality is provided statically. For example:
&lt;ul&gt;
&lt;li&gt;The data type for expressing time coordinates does not include a static method for obtaining the current time, as in most other languages. Instead, there is a &lt;code&gt;SystemClock&lt;/code&gt; interface which provides this functionality, and this interface must be obtained via &lt;code&gt;main()&lt;/code&gt; and propagated to all places that need to use it.&lt;/li&gt;
&lt;li&gt;Similarly, if you want to open a file, you cannot just instantiate a file class; you have to obtain the &lt;code&gt;FileSystem&lt;/code&gt; interface, and ask it to open a &lt;code&gt;File&lt;/code&gt; for you.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Runtime environment:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DirectoryPath&lt;/code&gt; and &lt;code&gt;FilePath&lt;/code&gt; interfaces that encapsulate file-system pathnames and filenames, so that one rarely needs to engage in string manipulation with paths.&lt;/li&gt;
&lt;li&gt;No such thing as a &amp;quot;current directory&amp;quot;; All paths are absolute. When a path is constructed from a string, the absolute path is immediately computed, and the computation may take into account whatever the host
system considers to be the &amp;quot;current directory&amp;quot; of the process. (So, by obtaining the &lt;code&gt;DirectoryPath&lt;/code&gt; of &amp;quot;.&amp;quot; one can discover the current directory, but one has no way of changing it, and the runtime environment
will never change it.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Cover image: &amp;quot;Coding Software Running On A Computer Monitor&amp;quot; by Scopio from NounProject.com&lt;/p&gt;</description></item><item><title>C# Bloopers</title><link>https://blog.michael.gr/post/2012-01-05-csharp-bloopers/</link><pubDate>Thu, 05 Jan 2012 12:21:02 +0000</pubDate><guid>https://blog.michael.gr/post/2012-01-05-csharp-bloopers/</guid><description>&lt;p&gt;&lt;img src="https://blog.michael.gr/post/2012-01-05-csharp-bloopers/media/csharp-logo-2023.svg"
loading="lazy"
&gt;
&lt;/p&gt;
&lt;p&gt;Please do not get me wrong; C# is awesome. It is the language of my choice, even though I am pretty well versed in C++ and Java. That having been said, it cannot be denied that C# has its share of flaws, too. In this series of posts I am documenting some of them, in no particular order.&lt;/p&gt;
&lt;p&gt;Also please note that some of the issues described here are Visual Studio bloopers, or DotNet bloopers, and not C#-in-general bloopers.&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2011-12-31-csharp-blooper-1-no-warnings-about/"
&gt;C# Blooper 1: No warnings about uninitialized readonly members&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2012-01-06-csharp-blooper-2-no-warnings-about/"
&gt;C# Blooper 2: No warnings about accessing uninitialized members&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2012-01-06-csharp-blooper-3-no-warnings-about-fields/"
&gt;C# Blooper 3: No warnings about fields having already been initialized&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2012-11-09-csharp-blooper-4-lameannoying-variable/"
&gt;C# Blooper 4: Lame/annoying variable scoping rules, Part 1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2012-11-09-csharp-blooper-5-lameannoying-variable/"
&gt;C# Blooper 5: Lame/annoying variable scoping rules, Part 2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2012-11-09-csharp-blooper-6-no-warnings-about-unused/"
&gt;C# Blooper 6: No warnings about unused parameters&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2012-11-10-csharp-blooper-7-no-warnings-about-unused/"
&gt;C# Blooper 7: No warnings about unused private methods&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2013-01-04-csharp-blooper-8-no-warnings-for-conditions/"
&gt;C# Blooper 8: No warnings for conditions that are always true/false&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2013-01-04-csharp-blooper-9-annoying-case-statement/"
&gt;C# Blooper 9: Annoying case statement fall-through rules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2013-01-04-csharp-blooper-10-switch-statements-are-not/"
&gt;C# Blooper 10: Switch statements are not properly formatted&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2013-01-04-csharp-blooper-11-zero-to-enum-conversion/"
&gt;C# Blooper 11: Zero to Enum conversion weirdness&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2013-01-04-csharp-blooper-12-where-constraints-not/"
&gt;C# Blooper 12: 'Where' constraints not included in method signatures&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2013-01-04-csharp-blooper-13-stack-and-queue-do-not/"
&gt;C# Blooper 13: 'Stack' and 'Queue' do not implement 'ICollection'&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://blog.michael.gr/post/2013-01-04-csharp-blooper-14-weird-annoying-interface/"
&gt;C# Blooper 14: Weird / annoying interface method visibility rules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Stay tuned, there is more to come.&lt;/p&gt;</description></item></channel></rss>