<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="\rAbstract A Software Design Pattern for concurrent systems is presented, which makes race conditions something that can be asserted against and thus deterministically eliminated rather than stochastically reduced or minimized.\nA description of the problem Every Software Engineer who has dealt with concurrency knows that it is hard. The bane of concurrency is race conditions: when a thread accesses data without taking into account the fact that the data is shared with other concurrently running threads which may alter that data at any unforeseeable moment in time.\n"><title>Coherence: The Assertable Lock</title><link rel=canonical href=https://blog.michael.gr/post/2020-12-12-coherence/><link rel=stylesheet href=/scss/style.min.32a512555d79ccc2867a9b2e645843323dfbe8892f99ff86e4dbb5b7316dbb25.css><meta property='og:title' content="Coherence: The Assertable Lock"><meta property='og:description' content="\rAbstract A Software Design Pattern for concurrent systems is presented, which makes race conditions something that can be asserted against and thus deterministically eliminated rather than stochastically reduced or minimized.\nA description of the problem Every Software Engineer who has dealt with concurrency knows that it is hard. The bane of concurrency is race conditions: when a thread accesses data without taking into account the fact that the data is shared with other concurrently running threads which may alter that data at any unforeseeable moment in time.\n"><meta property='og:url' content='https://blog.michael.gr/post/2020-12-12-coherence/'><meta property='og:site_name' content="Michael's Blog"><meta property='og:type' content='article'><meta property='article:section' content='post'><meta property='article:tag' content='software-architecture'><meta property='article:tag' content='software-engineering'><meta property='article:tag' content='papers'><meta property='article:published_time' content='2020-12-12T13:51:31+00:00'><meta property='article:modified_time' content='2025-10-13T23:36:55+02:00'><meta name=twitter:title content="Coherence: The Assertable Lock"><meta name=twitter:description content="\rAbstract A Software Design Pattern for concurrent systems is presented, which makes race conditions something that can be asserted against and thus deterministically eliminated rather than stochastically reduced or minimized.\nA description of the problem Every Software Engineer who has dealt with concurrency knows that it is hard. The bane of concurrency is race conditions: when a thread accesses data without taking into account the fact that the data is shared with other concurrently running threads which may alter that data at any unforeseeable moment in time.\n"><link rel="shortcut icon" href=/favicon.svg><script async src="https://www.googletagmanager.com/gtag/js?id=TODO"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","TODO")}</script></head><body class="article-page
article-page"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><ol class=menu id=main-menu><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol><a href=/><img src=/logo.svg width=210 loading=lazy alt=Logo></a><figure class=site-avatar><a href=/><img src="https://gravatar.com/avatar/8d1c5b5578843f958430afe30e0cbb2fb5092b1712d1933ea37d7bf5cb4305ed?size=400" width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure></header><ul class=menu-social><li><a href=/contact-via-e-mail/ title=e-Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z"/><path d="M3 7l9 6 9-6"/></svg></a></li><li><a href=/contact-via-whatsapp/ title=WhatsApp rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 21l1.65-3.8a9 9 0 113.4 2.9L3 21"/><path d="M9 10a.5.5.0 001 0V9A.5.5.0 009 9v1a5 5 0 005 5h1a.5.5.0 000-1h-1a.5.5.0 000 1"/></svg></a></li><li><a href=https://github.com/mikenakis target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/mikenakis target=_blank title=LinkedIn rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 11v5"/><path d="M8 8v.01"/><path d="M12 16v-5"/><path d="M16 16v-3a2 2 0 10-4 0"/><path d="M3 7a4 4 0 014-4h10a4 4 0 014 4v10a4 4 0 01-4 4H7a4 4 0 01-4-4z"/></svg></a></li><li><a href=https://stackoverflow.com/users/773113/mike-nakis target=_blank title="Stack Overflow" rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 17v1a2 2 0 002 2h12a2 2 0 002-2v-1"/><path d="M8 16h8"/><path d="M8.322 12.582l7.956.836"/><path d="M8.787 9.168l7.826 1.664"/><path d="M10.096 5.764l7.608 2.472"/></svg></a></li><li><a href=https://twitter.com/mikenakis target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ul><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/portfolio/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Portfolio</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#abstract>Abstract</a></li><li><a href=#a-description-of-the-problem>A description of the problem</a></li><li><a href=#solutions-that-try-to-avoid-the-problem>Solutions that try to avoid the problem</a></li><li><a href=#a-deeper-look-at-the-problem>A deeper look at the problem</a></li><li><a href=#restating-the-problem>Restating the problem</a></li><li><a href=#the-solution>The solution</a></li><li><a href=#further-research>Further Research</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/post/2020-12-12-coherence/>Coherence: The Assertable Lock</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2020-12-12 Sat 13:51:31 UTC</time></div><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
<time class=article-time--reading>15 minute read</time></div></footer></div></header><section class=article-content><p><img src=/post/2020-12-12-coherence/media/coherence.jpg width=1280 height=853 loading=lazy class=gallery-image data-flex-grow=150 data-flex-basis=360px></p><h3 id=abstract>Abstract</h3><p>A Software Design Pattern for concurrent systems is presented, which makes race conditions something that can be asserted against and thus <strong>deterministically eliminated</strong> rather than stochastically reduced or minimized.</p><h3 id=a-description-of-the-problem>A description of the problem</h3><p>Every Software Engineer who has dealt with concurrency knows that it is hard. The bane of concurrency is race conditions: when a thread accesses data without taking into account the fact that the data is shared with other concurrently running threads which may alter that data at any unforeseeable moment in time.</p><p>(Useful pre-reading: <a href=/post/2022-11-about-these-papers/>About these papers</a>)</p><p>There exist two kinds of race conditions that I can think of, let's call them <em><strong>physical</strong></em> and <em><strong>logical</strong></em>. (I just made up these terms, perhaps they have already been studied and given other names, but I am unaware of that.)</p><ul><li><strong>Physical Race Conditions</strong> happen due to the way the underlying hardware works. One example is trying to read a variable consisting of who machine words, thus requiring two successive read operations which are not atomic, while another thread is simultaneously writing to that variable, resulting in garbage being read. Another example is two threads simultaneously performing increment operations on the same memory location, where a memory increment is implemented by the CPU as a non-atomic sequence of read-increment-write operations, resulting in some of the increments being lost.</li><li><strong>Logical Race Conditions</strong> happen when application logic fails to account for concurrency. For example, checking whether a collection contains a value, and if not, adding the value to the collection: when two threads try to do this, it will sometimes happen that they will both find that the collection does not contain the value in question, and will both add it, resulting in a duplicate. Depending on whether the implementation of the collection allows duplicates or not, this will result either in soft malfunction, (a duplicate where it was not intended,) or in hard failure due to the collection throwing a "duplicate element" exception.</li></ul><p>Note that logical race conditions can occur even if we have taken all necessary precautions (i.e. locking) to avoid physical race conditions. Incidentally, this is the reason why many of the so-called "concurrent" collections like the "concurrent map" are of very limited use: sure, they guarantee that they will not crash and burn, but they do not guarantee correct results.</p><p>Race conditions exhibit a disastrous combination of unfortunate qualities:</p><ul><li><strong>Non-deterministic:</strong> you cannot reproduce them at will, they just appear to happen at random, so you can almost never use the debugger to troubleshoot them.</li><li><strong>Sensitive to troubleshooting instrumentation:</strong> not only they never manifest while single-stepping through code, but if you introduce extra code to detect them, they may seemingly disappear, because they are highly dependent on timing. The moment you remove the instrumentation however, they may start manifesting again.</li><li><strong>Elusive:</strong> their effects are usually observed not at the moment that they occur but after the fact, so it is difficult to tell what happened and why it happened.</li><li><strong>Confusing:</strong> sometimes, the malfunction that they cause seems at first impossible to happen, requiring extensive troubleshooting before the realization sinks in that it must be due to a race condition.</li><li><strong>Multi-faced:</strong> in many cases the effects of a race condition differ on each manifestation, so you are never sure whether you are chasing one issue or several issues at the same time.</li><li><strong>Untestable:</strong> there is no unit test that can catch race conditions or give any assurances for their absence.</li><li><strong>Treacherous:</strong> a race condition which happens on average once every million seconds of usage may take months before it manifests in your development environment, and yet once there are a million customers using your software, there will be one customer encountering it roughly every second.</li><li><strong>Catastrophic:</strong> program state corruption tends to result in complete failure of the software.</li></ul><h3 id=solutions-that-try-to-avoid-the-problem>Solutions that try to avoid the problem</h3><p>Since concurrency with locks is so hard, a number of mechanisms have been invented that try to implement concurrency without locking.</p><ul><li><p><strong>Immutability (functional programming):</strong> if all program state is immutable, then there is no possibility of one thread modifying some state while another thread is trying to read it, because there is no state that can be modified. Therefore, no locking is necessary.</p><p>Disadvantages:</p><ul><li>Functional programming and immutability are not ubiquitous, and it is yet to be seen whether they will ever become ubiquitous.</li><li>Many implementations of Functional Programming are not purely functional, they mix mutability with immutability, so the problem remains.</li><li>Functional programming is only common in high-level systems running on garbage-collecting virtual machines. It is rare in mid-level systems and virtually absent in low-level systems.</li><li>Many of the data structures that give the illusion of mutability while their inner workings are immutable tend to be computationally more expensive than their straightforward mutable counterparts.</li></ul></li><li><p><strong>Message-passing:</strong> threads never share any data, instead they only work on data that they exclusively own, and they exchange data by means of immutable messages passed through message queues. Essentially, in the entire system there is only one little piece of code which employs locking, and that is the concurrent message queue implementation. The idea is that we should be able to get at least that small part right.</p><p>Disadvantages:</p><ul><li>Performance suffers as the amount of data exchanged among threads increases.</li><li>Performance also suffers since data can never be manipulated in-place, it must be placed in a message, the message must be posted into a queue, a thread context switch must usually occur for the receiving thread to process the message, and then the reverse path must be followed for the original thread to receive the result. (When manipulating data in-place, a thread context switch will only occur when attempting to obtain a lock while another thread already holds that lock, which may be a rare occurrence.)</li><li>Nowadays in order to avoid the tedious creation of countless message classes you are more likely to just post a lambda into the message queue, but then you have a lambda which is declared in one thread but executed in another thread, so you still have to be extremely careful with what that lambda is allowed to touch.</li></ul></li><li><p><strong>Other:</strong> exotic mechanisms such as the single-writer principle of the Rust programming language.</p><p>Disadvantages:</p><ul><li>They tend to require compiler support. (So, a mechanism that can be implemented in any language would still be of value.)</li></ul></li></ul><p>So, avoiding race conditions when practicing concurrency by means of locking is an existing problem in need of a solution.</p><h3 id=a-deeper-look-at-the-problem>A deeper look at the problem</h3><p>At the heart of the race condition problem lies the "to lock or not to lock" conundrum. The choice of what to do lies in a continuum between two absurd extremes:</p><ul><li><strong>Ultra-fine grain locking:</strong> Always lock every single little piece of mutable state when accessing it, and only while accessing it.</li><li><strong>Ultra-coarse grain locking:</strong> Place a global lock on the entirety of your mutable state on program start and release it on program exit.</li></ul><p>Obviously, neither of these extreme approaches would work.</p><ul><li><p>Ultra-fine grain locking would result in an unreasonable amount of bloat in
all code that we write, it would suffer performance-wise, and although it
would eliminate physical race conditions, it would do nothing for
logical race conditions.</p></li><li><p>Ultra-coarse grain locking would not work either because increasing the
lifetime of a lock also increases the chances that other threads will be
blocked, with the absurd extreme of the lock lifetime being equal to program
runtime resulting in all threads becoming permanently blocked and no actual
sharing of any mutable state ever taking place.</p></li></ul><p>So, the answer to the "to lock or not to lock" conundrum always lies somewhere in-between:</p><blockquote><p>Always lock for as long as necessary, but try not to lock any longer than necessary.</p></blockquote><p>This leads to the number one cause of race conditions:</p><p>Trying to lock for as long as necessary but to avoid locking longer than necessary means that there will always be code which is accessing mutable state without first acquiring a fine grain lock, and instead is <em><strong>assuming</strong></em> that a coarser grain lock has already been acquired by some other code higher up the call-tree. (Remember, computer science trees are upside-down.) This assumption leaves open the possibility of human error, as the programmer who wrote the code higher up the call-tree may have forgotten to lock, thus putting all code below it at risk of race conditions.</p><p>This situation is so widespread that it may be hard to realize its full extent: every single time we invoke a standard runtime library mutable collection class (which is one of the most frequent things we do) we are engaging in this assumption: the collection is not concurrency aware, so it is not placing any locks, but it is manipulating mutable state, so under conditions of concurrency it will fail unless a lock is in place. Essentially, the collection class is doing its job while <em>praying</em> that someone up the call tree has remembered to acquire the necessary lock.</p><p>The grain of locks affects two things: performance and correctness.</p><ul><li><p>Choosing the grain of the locks in the most performant way is more of an art than a science, requiring a master of the craft to do it right, and that is okay: experts will always be useful. If no expert is available, performance might end up being suboptimal, but the software will still run, so strictly speaking the expert is not necessary.</p></li><li><p>Choosing the grain of the locks in such a way that the program remains correct is also more of an art than a science as things stand today, so it also requires a master of the craft to do it right; however, if we want to be thinking of our profession as a science rather than an art, we cannot have software that tends to crash and burn unless a master of the craft has written it. Therefore, we need a mechanism for detecting and protecting ourselves against the human error which is practically inevitable when an apprentice rather than a master touches the code, or even when the master touches the code while having a bad day.</p></li></ul><h3 id=restating-the-problem>Restating the problem</h3><p>A very important first step in solving a problem often is to restate it
using terminology that is more conducive to solving it. The term "Race
Condition" is somewhat cumbersome because it refers to an unfortunate event
which may or may not happen, depending on non-deterministic
circumstances. The original 1954 paper by David Huffman, titled "The synthesis of sequential switching circuits", which contains the
first known mention of the term, regards race conditions as something which
may exist when a certain instability is detected, so even the original sense referred to events that may potentially occur.</p><p>However, if we care about software correctness, then we do not want to be leaving anything to chance, so the fact that the unfortunate event <em><strong>may</strong></em> happen is irrelevant: if circumstances can arise at all which would potentially allow a race condition to occur, then for all practical purposes it must be assumed that the race condition <em><strong>will</strong></em> occur. Therefore, the race conditions themselves should be of no interest to us; what should be of interest is modes of operation that allow race conditions to occur. We will call them Race Modes.</p><p><em>A <strong>Race Mode</strong> is an erroneous mode of operation in which a race condition can potentially occur.</em></p><p>A piece of software either enters race modes, or it does not. If it does enter race modes, then race conditions may occur, and as already established, it should be presumed that they will occur. If the software never enters any race modes, then no race conditions can occur.</p><p>So, the problem has been restated from "avoiding race conditions" to "avoiding race modes". The difference may be subtle, but it is important enough to make.</p><h3 id=the-solution>The solution</h3><p>In restating the problem as described above we have set ourselves a new goal: how to assert against race modes. If race modes can be asserted against, then the concurrency problem stops being subject to chance and becomes quite deterministic instead: if our software runs and no assertion failures occur, then it never enters a race mode, and therefore no race conditions are possible. (Note that the assertions are not meant to catch race conditions; the assertions are meant to catch race modes.)</p><p>The mechanism that I have come up with for asserting against race modes is called <em><strong>Coherence</strong></em> and in its simplest form it can be thought of as an abstraction of an <em>Assertable Lock</em>.</p><p>There are two things you can do with coherence: enter it, and assert it. (By entering coherence we mean executing a piece of code while in coherence, so once that piece of code is done executing, coherence will be exited.) So, coherence gives us the ability to:</p><ul><li>Take measures at certain places in our code to prevent entering a race mode.</li><li>Ensure in all other places in our code that the necessary measures have been taken to guarantee we are not in a race mode.</li></ul><p>Thus, coherence saves us from doing ultra-fine grain locking and from making assumptions about locking: by turning locks into something assertable, we do not have to acquire a lock every single time we touch mutable state, but we can assert that a lock has been acquired by code higher up the call tree. Since assertions can compile to nothing on the release build, this is a zero-runtime-cost solution.</p><p>The name Coherence was chosen as opposed to Assertable Lock because Coherence is meant to be a high level abstraction. The use of an abstraction is necessary for two reasons:</p><ul><li><p>Coherence is meant to be asserted ubiquitously by any code that accesses mutable state, even by general purpose code such as the standard collection classes. However, general purpose code tends to be (and should remain) agnostic of concurrency, so it should not be burdened with such a low-level and concurrency-specific concept as locking.</p></li><li><p>Depending on the concurrency characteristics of the execution environment, there can be different implementations of coherence, some of which do not even involve actual locking, so using the term 'Lock' would be inaccurate and misleading.</p></li></ul><p>Examples of possible coherence implementations depending on the concurrency characteristics of the execution environment:</p><ul><li>In a strictly single-threaded environment, a dummy implementation is needed which never places any locks and never fails a coherence check.</li><li>In a share-nothing environment, a simple implementation will suffice which never places any locks and only fails a coherence check if the currently executing thread is not the thread that owns the mutable state, i.e. the thread in which the mutable state was created.</li><li>In a thread-pooled, share-nothing environment, a somewhat more elaborate implementation is needed which takes into account the fact that the thread which owns the mutable state may not necessarily be the thread that created the mutable state, since threads are picked from a pool.</li><li>In a multi-threaded environment with a small amount of shared state, a singular locking implementation will suffice which enters coherence by obtaining a lock on the totality of the shared state and fails the coherence check when that lock has not been obtained. This represents a coarse grain lock, so it might result in sub-optimal performance, but it has the advantage of being simple and avoiding deadlocks.</li><li>In a multi-threaded environment with a large amount of shared state and high thread contention over it, necessitating finer grain locking for good enough performance, a plural coherence implementation can be used which allows placing independent locks on independent subsets of the shared state, and fails a coherence check when the lock corresponding to a particular subset of state has not been obtained. Care must be exercised to always enter and assert the correct instance of coherence for each subset of state, and to avoid deadlocks in doing so.</li><li>Regardless of the concurrency characteristics of the execution environment, when the lifetime of a certain piece of mutable state is confined within a single call tree, a simple coherence implementation will again suffice which does not place a lock and simply asserts that the current thread is the thread in which the state was created. (To guard against the mutable state somehow escaping the scope of the call tree in which it was meant to be confined.)</li></ul><p>Note that Coherence only allows asserting its state and purposefully disallows testing its state. In other words, you cannot have an "if coherence is entered then..." construct. This is done so as to prevent misuse and to allow for high performance coherence implementations that, on the release build, may not have explicit knowledge of whether coherence has been entered or not.</p><p>Note that unlike most existing locking mechanisms, which explicitly allow a thread to obtain a lock multiple times, coherence explicitly disallows re-entrance. I have chosen to do it this way because my approach to Software Engineering is "leave nothing to chance", so if you are unsure whether you have already obtained a lock on something, and you would like the locking mechanism to be forgiving in case you try to lock twice, then you must be doing something wrong. It is my firm belief that when a piece of framework is in a position of alerting you that you are doing something wrong, it should be alerting you that you are doing something wrong. Of course it may be that I am wrong here, and unbeknownst to me there exist legitimate reasons for having to allow coherence reentrancy; this remains to be seen.</p><h3 id=further-research>Further Research</h3><p>As mentioned earlier, in multi-threaded environments with a large amount of shared state and high thread contention over it, performance concerns often necessitate dividing the state into subsets and having an individual lock for each subset, so that different subsets can be locked independently of each other.</p><p>Unfortunately, when we do this, we run the danger of entering deadlocks, and as it stands, the plural coherence implementation, which is suitable for these scenarios, does not address the issue of deadlocks.</p><p>Some research is necessary to determine whether the plural coherence implementation could do any of the following:</p><ul><li>Detect a deadlock once it happens and provide diagnostic information.</li><li>Detect a deadlock once it happens and somehow take corrective measure.</li><li>Detect the possibility of deadlocks and alert the programmer by means of hard error.</li><li>Be structured in such a way as to make deadlocks impossible.</li></ul><hr><p>Cover image by reginasphotos from pixabay.com</p></section><footer class=article-footer><section class=article-tags><a href=/tags/software-architecture/>Software Architecture</a>
<a href=/tags/software-engineering/>Software Engineering</a>
<a href=/tags/papers/>Papers</a></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on 2025-10-13 Mon 23:36:55 CEST</span></section></footer></article><script>var idcomments_post_id,idcomments_post_url,idcomments_acct="131c02e0ef20d1a4606aa4e3490711ba"</script><span id=IDCommentsPostTitle style=display:none></span>
<script type=text/javascript src=https://www.intensedebate.com/js/genericCommentWrapperV2.js></script><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/2024-03-codecoverage/><div class=article-details><h2 class=article-title>Artificial Code Coverage</h2></div></a></article><article><a href=/post/2024-01-types-of-dependencies/><div class=article-details><h2 class=article-title>Types of dependencies</h2></div></a></article><article><a href=/post/2023-12-27-call-graph-acyclicity/><div class=article-details><h2 class=article-title>Call Graph Acyclicity</h2></div></a></article><article><a href=/post/2023-12-09-authoritative-technical-design/><div class=article-details><h2 class=article-title>Towards Authoritative Software Design</h2></div></a></article><article><a href=/post/2023-01-14-mocking/><div class=article-details><h2 class=article-title>If you are using mock objects you are doing it wrong</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy; 2001 - 2026 Michael Belivanakis (a.k.a. Mike Nakis)</section><section class=powerby>Made using <b><a href=https://obsidian.md target=_blank>Obsidian</a></b> and <b><a href=https://gohugo.io/ target=_blank>Hugo</a></b><br>Theme based on <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank data-version=%s>hugo-theme-stack</a></b> by <a href=https://jimmycai.com target=_blank>Jimmy Cai</a><br></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>