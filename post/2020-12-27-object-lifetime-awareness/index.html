<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content=" Abstract Garbage collectors have given us a false sense of security with respect to what happens to an object once we stop thinking about it. The assumption is that it will be magically taken care of, but this does not always go as hoped, resulting in memory leaks and bugs due to failure to perform necessary cleanup. Tools for troubleshooting such problems are scarce, and not particularly helpful, so finding and fixing such problems is notoriously difficult.\nA methodology is presented, which differs from current widespread practices, for maintaining awareness of, and exercising full deterministic control over, the lifetime of certain objects in a garbage-collected environment. We issue hard errors in the event of misuse, and accurate diagnostic messages in the event of omissions, thus improving the robustness of software and lessening the troubleshooting burden.\n">
<title>Object Lifetime Awareness</title>

<link rel='canonical' href='//localhost:1313/post/2020-12-27-object-lifetime-awareness/'>

<link rel="stylesheet" href="/scss/style.min.21ef8ebc918342b23127db7e1cef326889b262bc982b25546ec94e1a9c73073b.css"><meta property='og:title' content="Object Lifetime Awareness">
<meta property='og:description' content=" Abstract Garbage collectors have given us a false sense of security with respect to what happens to an object once we stop thinking about it. The assumption is that it will be magically taken care of, but this does not always go as hoped, resulting in memory leaks and bugs due to failure to perform necessary cleanup. Tools for troubleshooting such problems are scarce, and not particularly helpful, so finding and fixing such problems is notoriously difficult.\nA methodology is presented, which differs from current widespread practices, for maintaining awareness of, and exercising full deterministic control over, the lifetime of certain objects in a garbage-collected environment. We issue hard errors in the event of misuse, and accurate diagnostic messages in the event of omissions, thus improving the robustness of software and lessening the troubleshooting burden.\n">
<meta property='og:url' content='//localhost:1313/post/2020-12-27-object-lifetime-awareness/'>
<meta property='og:site_name' content='Michael&#39;s Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='software-architecture' /><meta property='article:tag' content='software-engineering' /><meta property='article:tag' content='papers' /><meta property='article:published_time' content='2020-12-27T10:46:17&#43;00:00'/><meta property='article:modified_time' content='2025-10-22T21:32:42&#43;02:00'/>
<meta name="twitter:title" content="Object Lifetime Awareness">
<meta name="twitter:description" content=" Abstract Garbage collectors have given us a false sense of security with respect to what happens to an object once we stop thinking about it. The assumption is that it will be magically taken care of, but this does not always go as hoped, resulting in memory leaks and bugs due to failure to perform necessary cleanup. Tools for troubleshooting such problems are scarce, and not particularly helpful, so finding and fixing such problems is notoriously difficult.\nA methodology is presented, which differs from current widespread practices, for maintaining awareness of, and exercising full deterministic control over, the lifetime of certain objects in a garbage-collected environment. We issue hard errors in the event of misuse, and accurate diagnostic messages in the event of omissions, thus improving the robustness of software and lessening the troubleshooting burden.\n">
    <link rel="shortcut icon" href="/favicon.ico" />

      <script async src="https://www.googletagmanager.com/gtag/js?id=TODO"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'TODO');
        }
      </script>
    </head>
    <body class="
    article-page
     article-page">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
	
		
			<ol class="menu" id="main-menu">
				<li class="menu-bottom-section">
					<ol class="menu">
						
							<li id="dark-mode-toggle">
								<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



								<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



								<span>Dark Mode</span>
							</li>
						
					</ol>
				</li>
			</ol>
			

		<a href="/"><img src="/logo.svg" width="210" loading="lazy" alt="Logo"></a>

		
		
			
				<figure class="site-avatar">
					 <a href="/">
						
							<img src="https://gravatar.com/avatar/8d1c5b5578843f958430afe30e0cbb2fb5092b1712d1933ea37d7bf5cb4305ed?size=400" width="300" height="300" class="site-logo" loading="lazy" alt="Avatar">
						
					</a>
					
				</figure>
			
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="//localhost:1313/">Michael&#39;s Blog</a></h1>
            <h2 class="site-description">&#34;If it&#39;s worth doing, it&#39;s worth doing right.&#34;</h2>
        </div>
    </header><ul class="menu-social">
            
                <li>
                    <a 
                        href='/contact-via-e-mail/'
                        
                        title="e-Mail"
                        rel="me"
                    >
                        
                        
                            <!--
category: Communication
tags: [inbox, gmail, email, envelope, message]
version: "1.0"
unicode: "eae5"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M3 7a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v10a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-10z" />
  <path d="M3 7l9 6l9 -6" />
</svg>

                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='/contact-via-whatsapp/'
                        
                        title="WhatsApp"
                        rel="me"
                    >
                        
                        
                            <!--
tags: [logo, app, application, communication, text, messages, communicator, photos, images, videos, giphy]
category: Brand
version: "1.13"
unicode: "ec74"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M3 21l1.65 -3.8a9 9 0 1 1 3.4 2.9l-5.05 .9" />
  <path d="M9 10a.5 .5 0 0 0 1 0v-1a.5 .5 0 0 0 -1 0v1a5 5 0 0 0 5 5h1a.5 .5 0 0 0 0 -1h-1a.5 .5 0 0 0 0 1" />
</svg>

                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://github.com/mikenakis'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <!--
tags: [logo, website, hosting, project, programming, software, development]
category: Brand
version: "1.18"
unicode: "ec1c"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>

                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://www.linkedin.com/in/mikenakis'
                        target="_blank"
                        title="LinkedIn"
                        rel="me"
                    >
                        
                        
                            <!--
tags: [logo, website, corporation, work, business, internet]
category: Brand
version: "1.15"
unicode: "ec8c"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M8 11v5" />
  <path d="M8 8v.01" />
  <path d="M12 16v-5" />
  <path d="M16 16v-3a2 2 0 1 0 -4 0" />
  <path d="M3 7a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v10a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4z" />
</svg>

                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://stackoverflow.com/users/773113/mike-nakis'
                        target="_blank"
                        title="Stack Overflow"
                        rel="me"
                    >
                        
                        
                            <!--
tags: [social, media, programming, website]
category: Brand
version: "1.43"
unicode: "ef58"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M4 17v1a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-1" />
  <path d="M8 16h8" />
  <path d="M8.322 12.582l7.956 .836" />
  <path d="M8.787 9.168l7.826 1.664" />
  <path d="M10.096 5.764l7.608 2.472" />
</svg>

                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com/mikenakis'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <!--
tags: [logo, app, application, community, social, communication, website, user, post, images, photos, comment, feedback]
category: Brand
version: "1.18"
unicode: "ec27"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c0 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>

                        
                    </a>
                </li>
            
        </ul><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
            </ol>
        </li>
    </ol>
</aside>


    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">Table of contents</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li>
      <ol>
        <li><a href="#abstract">Abstract</a></li>
        <li><a href="#definition">Definition</a></li>
        <li><a href="#a-first-look-at-the-problem">A first look at the Problem</a></li>
        <li><a href="#existing-mechanisms">Existing mechanisms</a></li>
      </ol>
    </li>
    <li><a href="#finalization">Finalization</a></li>
    <li><a href="#disposal">Disposal</a></li>
    <li><a href="#automatic-disposal">&ldquo;Automatic&rdquo; disposal</a></li>
    <li><a href="#weak-references">Weak References</a>
      <ol>
        <li><a href="#a-deeper-look-at-the-problem">A deeper look at the problem</a></li>
        <li><a href="#the-solution">The Solution</a></li>
        <li></li>
        <li><a href="#detecting-omissions">Detecting omissions</a></li>
        <li><a href="#addendum-lifeguards">Addendum: Lifeguards</a></li>
        <li><a href="#addendum-ad-hoc-alive-states">Addendum: Ad-hoc alive states</a></li>
        <li><a href="#addendum-unmanaged-resources">Addendum: Unmanaged Resources</a></li>
        <li><a href="#further-research-and-recommendations">Further research and recommendations</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">
</header><div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/post/2020-12-27-object-lifetime-awareness/">Object Lifetime Awareness</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2020-12-27 Sun 10:46:17 UTC</time>
            </div>
        

        
            <div>
                <!--
tags: [material, measure, time, timer, clock, sand]
version: "1.66"
category: System
unicode: "f146"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M6 20v-2a6 6 0 1 1 12 0v2a1 1 0 0 1 -1 1h-10a1 1 0 0 1 -1 -1z" />
  <path d="M6 4v2a6 6 0 1 0 12 0v-2a1 1 0 0 0 -1 -1h-10a1 1 0 0 0 -1 1z" />
</svg>

                <time class="article-time--reading">
                    35 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>


    <section class="article-content">
    
    
    <p><img src="/post/2020-12-27-object-lifetime-awareness/images/le-penseur.jpg"
	width="3648"
	height="5472"
	srcset="/post/2020-12-27-object-lifetime-awareness/images/le-penseur_hu_9d5b056aaaccb843.jpg 480w, /post/2020-12-27-object-lifetime-awareness/images/le-penseur_hu_c19a599b08f288b2.jpg 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="66"
		data-flex-basis="160px"
	
>
</p>
<h4 id="abstract">Abstract
</h4><p>Garbage collectors have given us a false sense of security with respect to what happens to an object once we stop thinking about it. The assumption is that it will be magically taken care of, but this does not always go as hoped, resulting in memory leaks and bugs due to failure to perform necessary cleanup. Tools for troubleshooting such problems are scarce, and not particularly helpful, so finding and fixing such problems is notoriously difficult.</p>
<p>A methodology is presented, which differs from current widespread practices, for maintaining awareness of, and exercising full deterministic control over, the lifetime of certain objects in a garbage-collected environment. We issue hard errors in the event of misuse, and accurate diagnostic messages in the event of omissions, thus improving the robustness of software and lessening the troubleshooting burden.</p>
<p>(Useful pre-reading: <a 
   href="/post/2022-11-about-these-papers/"
   >About these papers</a>)</p>
<h4 id="definition">Definition
</h4><p>An object can be said to have a concept of lifetime if at some point it must perform some cleanup actions, after which it must never be accessed again.</p>
<h4 id="a-first-look-at-the-problem">A first look at the Problem
</h4><p>One of the original promises of garbage collectors was that we should not have to worry about the lifetime of objects; however, there exist various known situations where objects do, by their very nature, have an inherent notion of lifetime, so we do have to worry about it; for example:</p>
<ul>
<li>Objects that model real-world processes with an inherent concept of lifetime, such as:
<ul>
<li>A user&rsquo;s visit to a web site, represented by a web session which at some moment expires.</li>
<li>The printing of a document, represented by a print job which at some moment completes.</li>
</ul>
</li>
<li>Objects implementing application behaviors with a clearly defined end, such as:
<ul>
<li>A dialog window which at some moment gets dismissed and ceases to exist.</li>
</ul>
</li>
</ul>
<p>Additionally, there exist certain programmatic constructs which require a notion of lifetime; for example:</p>
<ul>
<li>An event observer which must at some point unregister from the event source that it had previously registered with.</li>
<li>A database transaction which must at some point end, either by committing it or rolling it back.</li>
<li>Generally, any situation where:
<ul>
<li>We must remember to undo something which was previously done.</li>
<li>Some initialization must be balanced by some corresponding cleanup.</li>
</ul>
</li>
</ul>
<p>Furthermore, any object which contains an object that has a notion of lifetime needs to have a notion of its own lifetime, so as to be in a position of controlling the lifetime of the contained object. Thus, there tends to be a need for objects with a notion of lifetime to form a containment hierarchy whose root is the main application object.</p>
<p>Unfortunately, in garbage collected environments, object lifetime is not given as much attention as it deserves. Software architectures tend to underestimate its importance, give it only a partial treatment, and invariably do it in ad-hoc ways, without any clearly defined methodology or aiding infrastructure. All to often, an object with an inherent notion of lifetime is built without explicit knowledge of it; instead, its lifetime is treated only implicitly. Thus, the software design has no knowledge of, and no control over, the lifetime of that object, and relies on the garbage collector to magically take care of it.</p>
<p>Once we leave an object up to the garbage collector to take care of, we completely relinquish control over what happens next: there are no guarantees as to when the object will be collected, or even as to whether it will in fact be collected; there will be nothing to inform us of the outcome, and we have no way of influencing the outcome. Thus, when object-lifetime related trouble happens, it is by its nature very difficult to troubleshoot, diagnose, and fix; nonetheless, most programmers try to avoid dealing with object lifetime if they can, and each time problems pop up, they try to fix them on an as needed basis.</p>
<p>The following kinds of trouble are common:</p>
<ul>
<li><strong>Direct failure to perform necessary cleanup:</strong> the false sense of security offered by the garbage collector sometimes makes programmers forget that it only reclaims unused memory, it does not do any other cleanup for us, such as unregistering observers from event sources. This usually needs to be done manually, and it requires that the observer must have a notion of lifetime. An event source could in theory be asserting that every single observer did eventually remember to deregister; however, such a technique would require not only observers to have a notion of lifetime, but also the event source itself. Thus, there is no widespread use of such a technique, because there is no widespread use of object lifetime awareness in the first place.</li>
<li><strong>Memory leaks:</strong> in an ideal world, the magic of the garbage collector would always be strong and true, but in practice it is not, due to subtle human error such as inadvertently keeping around a reference to an object, thus preventing it from being garbage collected. Lack of object lifetime awareness only exacerbates this problem.</li>
<li><strong>Troubleshooting in the dark:</strong> an object with a notion of lifetime can either be alive or dead. If the lifetime of the object is explicit, we can always inspect that state with the debugger. If not, then we never know whether the object that we are looking at is meant to be alive or not.</li>
<li><strong>Inability to detect misuse:</strong> a very common mistake is continuing to access an object even after its lifetime is over. When the object has no explicit knowledge of its own lifetime, it cannot assert against such mistakes.</li>
</ul>
<h4 id="existing-mechanisms">Existing mechanisms
</h4><p>Garbage collectors and their associated execution environments do provide some machinery which is related to the topic of object lifetime management, namely <em><strong>finalization</strong></em>, <em><strong>disposal</strong></em>, <em><strong>&ldquo;automatic&rdquo; disposal</strong></em>, and <em><strong>weak references</strong></em>, but as we shall see this machinery alone is woefully inadequate.</p>
<h3 id="finalization">Finalization
</h3><p>In Java we have the <code>Object.finalize()</code> method, and in C# we have &ldquo;destructors&rdquo;, which are actually not destructors at all, they are finalizers, too. <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>  The garbage collector will invoke the finalizer of an object right before reclaiming the memory occupied by it, so that the object can in theory perform some cleanup at that moment. Unfortunately, this mechanism is notoriously unreliable:</p>
<ul>
<li>An object will not be finalized unless it first becomes eligible for collection, and in order for that to happen, it must first become unreachable. However, the object may remain reachable due to subtle mistakes such as unknowingly keeping a reference to it in some list, thus resulting in objects which never get finalized.</li>
<li>When an object does become eligible for collection, the moment that it will actually be collected largely depends upon the whim of the garbage-collector, which is non-deterministic, both according to the documentation and as observed by experimentation. There are no guarantees as to when an object will be collected, or even as to whether it will ever be collected, despite being eligible.
<ul>
<li>If the garbage collector works in aggressive mode, (common in servers,) the object will be collected sooner rather than later, but how soon depends on variables that we practically have no control over, such as at what rate existing objects are becoming eligible for collection, how many objects are pending to be finalized, etc. So:
<ul>
<li>Even though the object may be finalized within milliseconds, there are no guarantees as to how many milliseconds, and also please note that &ldquo;milliseconds&rdquo; is still a far cry from &ldquo;now&rdquo;.</li>
<li>Even if the object gets finalized as quickly as possible, this is still going to happen in a separate thread, so finalization will always be desynchronized from the set of instructions which rendered the object eligible for finalization. If these instructions are followed by another set of instructions that in any way rely on finalization having already taken place, the second set of instructions will almost always fail.</li>
</ul>
</li>
<li>If the garbage collector works in non-aggressive mode, (common in desktop and console applications,) then:
<ul>
<li>The object might not be collected unless the virtual machine starts running out of memory, which is at an entirely unknown and usually distant time in the future.</li>
<li>The object may still not be collected at all if our software completes before exhausting its available memory. If we are only dealing with unmanaged resources that belong to the current process, they will be automatically reclaimed upon process termination, so all will be good, but if we are dealing with resources that are external to our process, (e.g. controlling a peripheral,) these resources will not be released.</li>
</ul>
</li>
</ul>
</li>
<li>The garbage collector orchestrates collection and finalization according to memory availability concerns, but not according to other concerns which it has no knowledge of; consequently, if we are acquiring instances of a certain scarce resource at a high rate, the garbage collector will not hasten collection and finalization in response to the scarcity of that resource, because it has no knowledge of that scarcity. However, if that resource only gets recycled when collection and finalization occurs, and if we do not happen to be allocating and freeing memory fast enough to trigger frequent enough collection and finalization, then we will be consuming the resource faster than it is being recycled, so we will run out of it, despite everything seemingly being done right.</li>
<li>Finalization is unordered and does not respect containment hierarchy, which means that when the finalizer is invoked on an object, a random subset of the objects contained in this object may have already been finalized. This is a completely chaotic situation which makes it impossible to get anything non-trivial done within a finalizer.</li>
<li>The chaotic and non-deterministic conditions under which the finalizer executes make it virtually impossible to test any code that you put in a finalizer, so virtually all finalizers are written on a best-effort basis: if it seems to work as written, it will hopefully keep working, fingers crossed.</li>
<li>Finalization is documented as having a high performance cost, so the standing advice is that it is best to minimize its use, or avoid it altogether if possible.</li>
</ul>
<p>Therefore, relying on finalization does not give us control over anything, on the contrary it takes control away from us. The official literature of both Microsoft DotNet and the Java Virtual Machine recommends using finalization for the purpose of releasing unmanaged resources, which is not just unhelpful but actually wrongful advice to give. The entire software industry has been blindly following this advice without first questioning its correctness, which has resulted in lots of buggy software out there.</p>
<h3 id="disposal">Disposal
</h3><p>In Java we have the <code>Closeable</code> interface, and in C# we have the <code>IDisposable</code> interface. The benefit of using these interfaces is that they allow explicit (i.e. deterministic and synchronous) triggering of cleanup, instead of relying on finalization to trigger it.</p>
<p>A C#-only note: In the C# world there is an understanding that <code>IDisposable</code> may also be used for performing regular cleanup at the end of an object&rsquo;s lifetime; however, its primary reason of existence is still regarded as being the release of unmanaged resources, so people are trying to use it for both purposes. At the same time, the releasing of unmanaged resources is still regarded as something that must always be attempted during finalization, so people are trying to write disposal methods which must work both when explicitly invoked during normal program flow, and when invoked by the finalizer. Needless to say, the complexity of this task is daunting, and the result is incredible amounts of confusion. The <a class="external" 
   href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose" target="_blank"
   ><code>Dispose(bool)</code> pattern</a> has been invented to help manage the chaos, but the result is still preposterously complicated, it suffers from boilerplate code on every single object that implements the pattern, it is largely untestable, and what is most disappointing is that absolutely no thinking seems to have gone in the direction of avoiding all this chaos in the first place.</p>
<p>Overall, the problem with disposal is that it is very easy to accidentally omit, and when it is omitted there is usually nothing to tell us that we did something wrong, other than performance degradation and inexplicable malfunction. As a matter of fact, the designers of both Java and C# anticipated the inevitability of such omissions, so they invented finalization as a fallback mechanism which is hoped to save the day despite the omissions. However, since finalization is notoriously unreliable, it is not a solution either; it is more like implementing an insurance policy by purchasing lottery tickets.</p>
<p>Unfortunately, the availability of finalization, and its deceitful promise of making everything right by magic, has steered programmers to regard disposal as largely optional, while in reality it is essential. All that disposal needs in order to be actually useful is a mechanism that will warn us when we forget to perform it, instead of a mechanism that will try to magically fix our omissions.</p>
<h3 id="automatic-disposal">&ldquo;Automatic&rdquo; disposal
</h3><p>Both Java and C# provide special &ldquo;automatic&rdquo; disposal constructs, namely the <code>try-with-resources</code> statement of java, and the <code>using</code> keyword of C#, both of which implicitly invoke the disposal method even if an exception is thrown.  However:</p>
<ul>
<li>The only thing that is automatic about these constructs is that if you remember to use them, then they will save you from having to write some code that disposes an object; unfortunately,
<ul>
<li>You may very easily forget to use them.</li>
<li>You may very easily forget that your object requires disposal and therefore be unaware of the fact that you should have used them.</li>
</ul>
</li>
<li>These constructs can only be used in the simplistic scenario where the lifetime of an object is fully contained within the scope of a single method; unfortunately, in all but the most trivial situations what we actually have is objects which are contained within other objects and live for a prolonged time, so the method that creates them is different from the method that destroys them. In all these cases, the automatic disposal constructs are of no use whatsoever, and the programmer must remember to do everything right.</li>
</ul>
<h3 id="weak-references">Weak References
</h3><p>A weak reference is an object which receives special treatment by the execution environment, to achieve something which is not normally possible. It contains a reference to a target object, which is disregarded by the garbage collector when determining whether the target object is accessible. Therefore, if there are no other references to the target object, then the target object is allowed to be garbage-collected, at which point the reference inside the weak reference object is replaced with null.</p>
<p>Weak references do not actually help us manage the lifetime of objects, but they have been suggested as a mechanism that can help us design things so that there is no need to manage the lifetime of objects. The idea is that we can implement the observer pattern using weak references, so that observers do not need to remember to unregister themselves from the event source; instead, they can simply be allowed to become garbage-collected, and the event source will subsequently forget them.</p>
<p>This approach suffers from a number of drawbacks:</p>
<ul>
<li>Weak references might save us from having to worry about the lifetime of event observers, but they do nothing for a wide range of other situations that require cleanup at the end of an object&rsquo;s lifetime.</li>
<li>Weak observers run the danger of being prematurely garbage-collected. When this happens, it is very difficult to troubleshoot, and the fix tends to require tricks and hacks.</li>
<li>Weak references are a bit too low level, a bit too esoteric, and a bit like magic, so suggesting their widespread use by the average programmer is a bit of a tough proposition.</li>
<li>The use of weak references represents a step backwards from the stated goal of gaining more control over the inner workings of our software.</li>
</ul>
<h4 id="a-deeper-look-at-the-problem">A deeper look at the problem
</h4><p>In a language like C++, which has proper destructors, the lifetime of an object is well defined, and the compiler does all the work necessary to guarantee that this lifetime will end at the exact right moment, as long as we are using either local storage or smart pointers. However, in garbage-collected languages we have none of that; the lifetime of objects is not well defined by the language, so there is virtually nothing that the compiler can do for us. (As we have already shown, the <code>try-with-resources</code> statement of Java and the <code>using</code> keyword of C# are of very limited usefulness.)</p>
<p>In order to implement necessary cleanup at the end of an object&rsquo;s lifetime in garbage-collected languages, programmers either rely on finalization, or explicitly invoke objects to let them know that their lifetime is over. As we have already shown, finalization is asynchronous and non-deterministic, so it is unsuitable for basing any essential function of our software upon it, which means that explicit object lifetime termination is the only viable option.</p>
<p>Unfortunately, explicit object lifetime termination suffers from its own range of problems:</p>
<ul>
<li>There is usually nothing in the code to give us a hint that we should place a call to end the lifetime of an object.</li>
<li>When we forget to end the lifetime of an object, there is never any immediate error to tell us that we forgot.</li>
<li>The problems that subsequently occur tend to be subtle, so we often do not notice them until a considerable time after the fact. For example, forgetting to unregister an observer from an event source turns the observing object into a memory leak, and causes the observing method to keep being needlessly invoked by the event source, to perform actions that in the best case only waste clock cycles without any value or effect, and in the non-best case cause malfunction.</li>
<li>When the malfunction does get noticed, it often seems inexplicable and does not tend to point to the source of the problem.</li>
<li>Even when we discover that a certain malfunction is due to the lifetime of an object not having been ended, it is usually difficult to tell at which point in the code it should have been ended. Often, in order to know this, we first need to know where in the code the object was allocated, but this information is not normally available.</li>
<li>Writing tests to catch omissions in object lifetime control is not only hard and tedious, but it also requires testing against the implementation rather than testing against the interface, which violates recommended best practices. (To test whether object A properly ends the lifetime of object B, we have to mock B and ensure that its lifetime termination method is invoked by A, but if we do this then we are by definition testing against the implementation of A.)</li>
</ul>
<h4 id="the-solution">The Solution
</h4><p>Whereas it is generally true that &ldquo;if you do everything right there will be no problems&rdquo;, this is a very bad rule to live by, because it completely disregards another very important rule which says &ldquo;there will be mistakes&rdquo;. Reliance on everything being done right tends to result in brittle software designs, because some things will inevitably go wrong. We are definitely not advocating designs that are tolerant of mistakes; however, a software design must at the very least offer means of detecting mistakes and responding to them with hard error, diagnostic messages, or both; a design which relies on mistakes not being made, and at the same time is incapable of detecting the mistakes that will nonetheless be made, is doomed to run into trouble.</p>
<p>Object lifetime awareness is a design pattern for writing robust software. It begins by acknowledging that in garbage collected languages there tends to be widespread uncertainty with respect to the lifetime of objects, which results in bugs that are very difficult to troubleshoot and fix. While the garbage collector would ideally be taking care of a lot of things, by its nature it cannot take care of everything, and in practice it often does not even take care of things that it is expected to, due to subtle human error.</p>
<p>The impetus behind object lifetime awareness is that we have had enough of this uncertainty, so we are taking matters into our own hands by establishing definitive knowledge of the lifetime of our objects and taking full control over it. When an object has an inherent notion of lifetime, this notion must always be made explicit, and handled in a certain structured and recognizable manner, so that when mistakes occur, we receive hard errors and diagnostic messages, allowing us to fix problems without troubleshooting in the dark.</p>
<p>Specifically, every lifetime-aware object must do the following:</p>
<ul>
<li>Encapsulate an &ldquo;alive&rdquo; state which:
<ul>
<li>Starts as &ldquo;true&rdquo;.</li>
<li>At some moment transitions to &ldquo;false&rdquo;.</li>
<li>Is not exposed.</li>
<li>It can be asserted.</li>
<li>Can be inspected with a debugger.</li>
</ul>
</li>
<li>On debug runs, the lifetime-aware object must respond with hard error to any attempt to invoke any of its public instance methods once its lifetime is over.</li>
<li>On debug runs, the lifetime-aware object must discover any omission to end its lifetime, and generate a diagnostic message if so.  (More on how to achieve this later.)</li>
</ul>
<p>Please note that the definition of a &ldquo;debug run&rdquo; varies depending on which language you are using:</p>
<ul>
<li>In C# it is a run of the debug build.</li>
<li>In Java it is a run with assertions enabled.</li>
</ul>
<p>Please also note that automated test runs are usually debug runs.</p>
<p>Luckily we do not have to add lifetime awareness to all objects, we only need to add it to objects that belong to one or more of the following categories:</p>
<ul>
<li>Objects that by their nature have a concept of lifetime, such as timers, windows, files, network connections, notification suppressors, etc.</li>
<li>Objects that once initialized, are known to have some cleanup to do eventually.</li>
<li>Objects with which other objects may register in some way. (To ensure that each object that registers does not forget to unregister.)</li>
<li>Objects that contain (own) other lifetime-aware objects.</li>
</ul>
<p>In each system the objects that can benefit from lifetime awareness tend to be relatively few, while the majority of objects can continue being blissfully unaware of their lifetime, letting the garbage collector handle it.</p>
<p>In certain rare cases, a lifetime-aware object may control its own lifetime; however, far more often, the lifetime of an object is meant to be controlled by other objects. In these cases, the lifetime-aware object should implement the disposal interface of the language, primarily in order to document the fact that it is lifetime-aware, and secondarily so that the &ldquo;automatic&rdquo; disposal mechanism of the language can be used when the opportunity arises.</p>
<ul>
<li>In Java, that would be an object implementing the <code>Closeable</code> interface, thus allowing us to sometimes make use of the <code>try-with-resources</code> statement.</li>
<li>In C#, that would be the an object implementing the <code>IDisposable</code> interface, thus allowing us to sometimes make use of the <code>using</code> keyword.</li>
</ul>
<p>Please note that the use of these interfaces here has nothing to do with releasing unmanaged resources;  The goal is object lifetime awareness, while the releasing of unmanaged resources is at best a side note and largely a red herring in this discussion. It is true that the original intention of these interfaces was to allow releasing unmanaged resources, but there is absolutely nothing, either in the interfaces themselves, or in the language specifications, or in the respective compilers, or in the respective runtime environments, which says that this has to be the only purpose of these interfaces, or the only way they should be used, or the only way they can be used. So, here we are using them for something else. Please completely disregard the issue of unmanaged resources for now, we will address them later.</p>
<p>By making objects aware of their own lifetime, we achieve the following:</p>
<ul>
<li>Any discrepancy between an object&rsquo;s expected alive state and its actual alive state (i.e. whether we think it should be alive vs. whether it actually is alive) can be asserted against and therefore be swiftly and infallibly detected without any need for white-box testing.</li>
<li>The alive state of an object can be explicitly and deterministically controlled without ever having to rely on finalization to do it for us.</li>
<li>All necessary cleanup can be done when the alive state transitions to false, thus ensuring that each initialization action is always balanced by its corresponding cleanup action. This includes ending the lifetime of any contained (owned) objects, unregistering the object from whatever it had previously registered with, etc.</li>
<li>At the end of the object&rsquo;s lifetime we can take whatever extra measures are within our power to take in order to ensure that the lifetime of other objects is being correctly managed. For example, we can assert that any objects which had previously registered with this object have by now unregistered themselves.</li>
<li>More broadly, we construct our software to be in complete control over its inner workings, instead of leaving things to chance.</li>
</ul>
<h4 id="">
</h4><h4 id="detecting-omissions">Detecting omissions
</h4><p>The main thing which makes object lifetime awareness a viable proposition is the promise of useful diagnostic messages in response to omissions to explicitly end the lifetime of objects. Without such diagnostic messages, object lifetime awareness would not be much different from existing practices.</p>
<p>Interestingly enough, (or perversely enough, depending on how you would like to see it,) the mechanism that we leverage in order to detect such omissions is the garbage collector itself. The idea is that an object can check during finalization whether it is still alive or not: if it discovers that it is being finalized while still alive, then this means that the programmer forgot to explicitly end the lifetime of the object at an earlier moment.</p>
<p>It is very important to note that once we detect that an object is still alive during finalization, we specifically refrain from repeating the widespread mistake of trying to correct the problem: we most certainly do not attempt to end the lifetime of the object at that moment; instead, we only generate a diagnostic message, alerting the programmer that they forgot to end the lifetime of the object at an earlier time. This is important because the checks performed during finalization are meant to be of a strictly diagnostic nature, (a quality assurance mechanism if you wish,) so they are only meant to be performed on debug runs, so our software better be working correctly without them on release runs.</p>
<p>One might protest that an object which has accidentally become a memory leak will never be finalized, so it will never discover that its lifetime was not ended. Luckily, this can be taken care of with a bit of infrastructural support and a bit of discipline: During application shutdown we ensure that our system undergoes an orderly and thorough cleanup phase, where all remaining lifetime-aware objects are terminated. Typically, this simply means ending the lifetime of the main application object, and this should cascade throughout the entire containment hierarchy, ending the lifetime of all objects. Once this cleanup phase is complete, and if this is a debug run, we force a full garbage collection, and we wait for it to complete before exiting the application. In doing so, we ensure that all finalizers are invoked, and this includes the finalizers of any objects that were inadvertently memory-leaked. Thus, any omission to end the lifetime of an object is detectable in the worst case during application shutdown. For this to work optimally, some extra discipline is necessary, for example avoiding to directly or indirectly anchor lifetime-aware objects in static storage.</p>
<p>In actual practice most omissions to control the lifetime of objects happen without the objects necessarily also becoming memory-leaked, so the objects do get garbage-collected, so the omissions are detected at various moments during runtime when garbage collection occurs. For this reason, it is beneficial on debug runs to introduce regular forced garbage collection, thus detecting omissions as soon as possible after they happen. The right moment to force garbage collection tends to be:</p>
<ul>
<li>On web servers, immediately after servicing each client request.</li>
<li>On desktop applications, immediately after each application logic idle event.</li>
</ul>
<p>(An application logic idle event is similar to the graphical user interface idle event, except that it happens less frequently, i.e. not after every single event from the input system such as a mouse move, but only after the application logic has actually had some work to do.)</p>
<ul>
<li>On data processing systems with a main loop, at the end of each iteration of the main loop.</li>
</ul>
<p>It is worth stressing that forced garbage collection only needs to be employed as a diagnostic tool, and only on debug runs. On release runs there is never a need to force garbage collection because all object lifetime control issues are presumed to have already been addressed.</p>
<p>Forced garbage collection can also be used as a diagnostic tool during automated software testing; however, if our tests are fine-grained, (as the case usually is with unit tests,) it is advisable to refrain from forcing garbage collection after each test, because a full run of the garbage collector tends to be expensive, so its frequent use may multiply the total run time of a test suite by a very large factor. The ideal is to perform just one forced garbage collection at the end of all tests, and if any object lifetime control failures are detected, then and only then do another run of all tests with forced garbage collection enabled after each test, to detect precisely in which tests the failures occur.</p>
<p>In order to force garbage collection at will during testing, one needs a testing framework which supports this, and I am not aware of any, but if you do not make use of any exotic features of your existing testing framework, it is easy to write your own and take control yourself.</p>
<h4 id="addendum-lifeguards">Addendum: Lifeguards
</h4><p>For an object to be aware of its own lifetime and to issue diagnostic messages when its lifetime is not properly controlled, a certain amount of functionality is needed, and we do not want to be coding this functionality by hand in each class that we write, so we will be delegating as much of the work as possible to a separate class. An appropriate name for such a class would be <code>ObjectLifetimeGuard</code>, but this is a mouthful, so we will simply abbreviate it to <code>LifeGuard</code>.</p>
<p>The lifeguard exposes only 2 methods:</p>
<ul>
<li>A lifetime-assertion method which is invoked to assert that the lifeguard is still alive.</li>
<li>An end-of-lifetime method which is invoked to let the lifeguard know that its lifetime is over.</li>
</ul>
<p>With the introduction of the lifeguard, each lifetime-aware class only needs to do the following:</p>
<ul>
<li>Obtain during construction, and fully encapsulate, an instance of <code>LifeGuard</code>.</li>
<li>Perform an assertion at the beginning of each public instance method, (by definition only on debug runs, since it is an assertion,) which simply delegates to the lifetime-assertion method of the lifeguard.</li>
<li>Implement the object disposal interface of the language at hand, performing whatever cleanup actions are necessary, and then delegating to the end-of-lifetime method of the lifeguard.</li>
</ul>
<p>The lifeguard does the following:</p>
<ul>
<li>On debug runs, it encapsulates an <code>alive</code> state which starts as <code>true</code>.</li>
<li>It implements the is-alive-assertion method as follows:
<ul>
<li>On debug runs, it returns <code>true</code> if the object is alive, and throws an exception if not.</li>
<li>On release runs, it always throws an exception, because it is only meant to be invoked from within assertions, and assertions are not meant to execute on release runs.</li>
</ul>
</li>
<li>It implements the end-of-lifetime method as follows:
<ul>
<li>On debug runs, it first asserts that the object is currently alive, and then transitions the alive state to false.</li>
<li>On release runs, it does nothing.</li>
</ul>
</li>
<li>On debug runs it defines a finalizer which checks whether the object is still alive during finalization, and generates a diagnostic message if so.</li>
</ul>
<p>Notes:</p>
<ul>
<li>
<p>A lifeguard is obtained by invoking a factory method instead of using the <code>new</code> keyword, because this method will return something different depending on whether this is a debug run or a release run. The factory can come in the form of a <code>static</code> method for simplicity, or it can come in some other form if necessary.</p>
</li>
<li>
<p>The interface of the lifeguard has been designed in such a way that its alive state can be asserted without being exposed. This has the effect of:</p>
</li>
<li>
<p>Preventing misuse</p>
<ul>
<li>Allowing for a high performance implementation for release runs which does not even contain that state.</li>
<li>Still allowing the alive state to be inspected with a debugger on debug runs.</li>
</ul>
</li>
</ul>
<p>Lifetime-aware objects that have a need for some similar state which is queryable must implement it separately. The fact that on debug runs this state will be mirroring the <code>alive</code> state of the lifeguard is irrelevant.</p>
<ul>
<li>In certain environments which support asynchronous method invocations it might be impossible to guarantee that no method is ever invoked past end of lifetime; these are exceptions to the rule, which need special handling by means of <code>if</code> statements instead of assertions. Since the lifeguard only allows asserting the alive state without exposing it, such objects will need to implement their own <code>alive</code> state in parallel to the lifeguard.</li>
<li>As a rule, triggering hard error is preferable over generating diagnostic messages; however, an omission to end the lifetime of an object can only be detected during finalization, and by that time it is already too late for any fail-fast measures, so what we have here is an exception to the rule: in this particular case, it is okay if we just generate a diagnostic message. If needed, extra measures can be taken to alert the programmer to not forget to look at the diagnostic messages.</li>
<li>The diagnostic message generated in the event of an omission to end the lifetime of an object is meant to include a stack trace, complete with source filenames and line numbers, showing precisely where in the source code the object was allocated, to help us easily locate and fix the problem.</li>
</ul>
<p>Unfortunately, this stack trace needs to be collected by the lifeguard during construction, just in case it will need to be displayed during finalization, but in many environments collecting a stack trace is unreasonably expensive, so if each lifeguard instantiation was to involve collecting a stack trace, this would run the danger of slowing down our debugs runs to the point of making them unusable. (Obtaining a stack trace with source filenames and line numbers a few dozen times per second incurs a noticeable penalty on the JVM, while under DotNet the penalty is catastrophically more severe.)</p>
<p>For this reason, a special procedure is necessary: by default, stack traces are not collected, so a lifeguard which detects an omission to end the lifetime of an object reports only enough information to help us identify the class of the containing object. Once we know the class, we can go to the source code and flip a flag which enables stack trace collection for lifeguards of that specific class only, so that we can then re-run and obtain a message which includes a stack trace. Once we have solved the problem, we put the flag back to its default value to avoid the performance hit.</p>
<ul>
<li>Both in C# and in Java there is an established tradition which says that methods involved in the closing or disposing of things should be forgiving, in the sense that multiple invocations should be permitted with no penalty. In my opinion this practice is ill-conceived, so instead I prescribe an end-of-lifetime method which asserts that it is never invoked twice. This is in line with the overall theme of object lifetime awareness, which is to gain greater control over the inner workings of our software. I am perfectly aware of the fact that this is parting ways with a tradition cherished by the entire industry; it is perfectly fine to part ways with traditions when you know better, especially since another term for tradition is &ldquo;capricious progress-stopper&rdquo;.</li>
<li>The lifeguard is designed in such a way that on release runs it contains no state and performs no action; therefore, it need not be instantiated once per lifetime-aware object; instead, it can be a singleton, and all lifetime-aware objects can receive the same reference to its one and only dummy instance. Thus, the performance cost of using the lifeguard on release runs is near zero.</li>
</ul>
<p>An implementation of lifeguard in C# is as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CSharp" data-lang="CSharp"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nn">SomeNamespace</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Sys</span> <span class="p">=</span> <span class="n">System</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Collections</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">Generic</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">SysDiag</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">SysComp</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Runtime</span><span class="p">.</span><span class="n">CompilerServices</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="k">class</span> <span class="nc">LifeGuard</span> <span class="p">:</span> <span class="n">Sys</span><span class="p">.</span><span class="n">IDisposable</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="kd">static</span> <span class="n">LifeGuard</span> <span class="n">Create</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">collectStackTrace</span> <span class="p">=</span> <span class="kc">false</span><span class="p">,</span> <span class="c1">//</span>
</span></span><span class="line"><span class="cl"><span class="na">		[SysComp.CallerFilePath]</span> <span class="kt">string?</span> <span class="n">callerFilePath</span> <span class="p">=</span> <span class="kc">null</span><span class="p">,</span> <span class="c1">//</span>
</span></span><span class="line"><span class="cl"><span class="na">		[SysComp.CallerLineNumber]</span> <span class="kt">int</span> <span class="n">callerLineNumber</span> <span class="p">=</span> <span class="m">0</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span> <span class="p">!</span><span class="n">DebugMode</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">ProductionLifeGuard</span><span class="p">.</span><span class="n">Instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">Assert</span><span class="p">(</span> <span class="n">callerFilePath</span> <span class="p">!=</span> <span class="kc">null</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span> <span class="n">collectStackTrace</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="k">new</span> <span class="n">VerboseDebugLifeGuard</span><span class="p">(</span> <span class="m">1</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="k">new</span> <span class="n">TerseDebugLifeGuard</span><span class="p">(</span> <span class="n">callerFilePath</span><span class="p">!,</span> <span class="n">callerLineNumber</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="kd">abstract</span> <span class="k">void</span> <span class="n">Dispose</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">bool</span> <span class="n">IsAliveAssertion</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="kd">sealed</span> <span class="k">class</span> <span class="nc">ProductionLifeGuard</span> <span class="p">:</span> <span class="n">LifeGuard</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="kd">static</span> <span class="k">readonly</span> <span class="n">ProductionLifeGuard</span> <span class="n">Instance</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ProductionLifeGuard</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="kd">private</span> <span class="n">ProductionLifeGuard</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">//nothing to do</span>
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="kd">override</span> <span class="k">void</span> <span class="n">Dispose</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">//nothing to do</span>
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="kd">override</span> <span class="kt">bool</span> <span class="n">IsAliveAssertion</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">Sys</span><span class="p">.</span><span class="n">Exception</span><span class="p">();</span> <span class="c1">//never invoke on a release build</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="k">class</span> <span class="nc">DebugLifeGuard</span> <span class="p">:</span> <span class="n">LifeGuard</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">private</span> <span class="kt">bool</span> <span class="n">alive</span> <span class="p">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="kd">private</span> <span class="k">readonly</span> <span class="kt">string</span> <span class="n">message</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kd">protected</span> <span class="n">DebugLifeGuard</span><span class="p">(</span> <span class="kt">string</span> <span class="n">message</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">this</span><span class="p">.</span><span class="n">message</span> <span class="p">=</span> <span class="n">message</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="kd">sealed</span> <span class="kd">override</span> <span class="k">void</span> <span class="n">Dispose</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">Assert</span><span class="p">(</span> <span class="n">alive</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">alive</span> <span class="p">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">System</span><span class="p">.</span><span class="n">GC</span><span class="p">.</span><span class="n">SuppressFinalize</span><span class="p">(</span> <span class="k">this</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="kd">sealed</span> <span class="kd">override</span> <span class="kt">bool</span> <span class="n">IsAliveAssertion</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">Assert</span><span class="p">(</span> <span class="n">alive</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kd">protected</span> <span class="kd">static</span> <span class="kt">string</span> <span class="n">GetSourceInfo</span><span class="p">(</span> <span class="kt">string?</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lineNumber</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">=&gt;</span> <span class="s">$&#34;{filename}({lineNumber})&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="p">~</span><span class="n">DebugLifeGuard</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">SysDiag</span><span class="p">.</span><span class="n">Debug</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span> <span class="s">&#34;Object still alive!&#34;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">SysDiag</span><span class="p">.</span><span class="n">Debug</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span> <span class="n">message</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="kd">override</span> <span class="kt">string</span> <span class="n">ToString</span><span class="p">()</span> <span class="p">=&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">alive</span> <span class="p">?</span> <span class="s">&#34;&#34;</span> <span class="p">:</span> <span class="s">&#34;END-OF-LIFE&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="kd">sealed</span> <span class="k">class</span> <span class="nc">TerseDebugLifeGuard</span> <span class="p">:</span> <span class="n">DebugLifeGuard</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="n">TerseDebugLifeGuard</span><span class="p">(</span> <span class="kt">string</span> <span class="n">callerFilePath</span><span class="p">,</span> <span class="kt">int</span> <span class="n">callerLineNumber</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">:</span> <span class="k">base</span><span class="p">(</span> <span class="s">$&#34;    {GetSourceInfo( callerFilePath, callerLineNumber )}&#34;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="kd">sealed</span> <span class="k">class</span> <span class="nc">VerboseDebugLifeGuard</span> <span class="p">:</span> <span class="n">DebugLifeGuard</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="n">VerboseDebugLifeGuard</span><span class="p">(</span> <span class="kt">int</span> <span class="n">framesToSkip</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">:</span> <span class="k">base</span><span class="p">(</span> <span class="n">buildMessage</span><span class="p">(</span> <span class="n">framesToSkip</span> <span class="p">+</span> <span class="m">1</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kd">private</span> <span class="kd">static</span> <span class="kt">string</span> <span class="n">buildMessage</span><span class="p">(</span> <span class="kt">int</span> <span class="n">framesToSkip</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">=&gt;</span> <span class="kt">string</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span> <span class="s">&#34;\r\n&#34;</span><span class="p">,</span> <span class="n">getStackFrames</span><span class="p">(</span> <span class="n">framesToSkip</span> <span class="p">+</span> <span class="m">1</span> <span class="p">)</span> <span class="c1">//</span>
</span></span><span class="line"><span class="cl">						<span class="p">.</span><span class="n">Select</span><span class="p">(</span> <span class="n">getSourceInfoFromStackFrame</span> <span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kd">private</span> <span class="kd">static</span> <span class="n">SysDiag</span><span class="p">.</span><span class="n">StackFrame</span><span class="p">[]</span> <span class="n">getStackFrames</span><span class="p">(</span> <span class="kt">int</span> <span class="n">framesToSkip</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">var</span>                  <span class="n">stackTrace</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SysDiag</span><span class="p">.</span><span class="n">StackTrace</span><span class="p">(</span> <span class="n">framesToSkip</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="kc">true</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">SysDiag</span><span class="p">.</span><span class="n">StackFrame</span><span class="p">[]</span> <span class="n">frames</span>     <span class="p">=</span> <span class="n">stackTrace</span><span class="p">.</span><span class="n">GetFrames</span><span class="p">()!;</span>
</span></span><span class="line"><span class="cl">			<span class="n">Sys</span><span class="p">.</span><span class="n">Type</span>             <span class="n">type</span>       <span class="p">=</span> <span class="n">frames</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">GetMethod</span><span class="p">().</span><span class="n">DeclaringType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">Assert</span><span class="p">(</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Sys</span><span class="p">.</span><span class="n">IDisposable</span><span class="p">).</span><span class="n">IsAssignableFrom</span><span class="p">(</span> <span class="n">type</span> <span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">frames</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="n">f</span><span class="p">.</span><span class="n">GetFileName</span><span class="p">()</span> <span class="p">!=</span> <span class="kc">null</span> <span class="p">)</span> <span class="c1">//</span>
</span></span><span class="line"><span class="cl">					<span class="p">.</span><span class="n">ToArray</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kd">private</span> <span class="kd">static</span> <span class="kt">string</span> <span class="n">getSourceInfoFromStackFrame</span><span class="p">(</span> <span class="n">SysDiag</span><span class="p">.</span><span class="n">StackFrame</span> <span class="n">frame</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">string</span> <span class="n">sourceInfo</span> <span class="p">=</span> <span class="n">GetSourceInfo</span><span class="p">(</span> <span class="n">frame</span><span class="p">.</span><span class="n">GetFileName</span><span class="p">(),</span> <span class="n">frame</span><span class="p">.</span><span class="n">GetFileLineNumber</span><span class="p">()</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="s">$&#34;    {sourceInfo}: {frame.GetMethod().DeclaringType}.{frame.GetMethod().Name}()&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Note that in theory, <code>private readonly string message</code> may have already been finalized by the time the destructor attempts to use it. In reality, I have never encountered this happening. If it becomes a problem, a simple <code>string.Intern()</code> could be used to permanently anchor these strings in memory, and that is okay despite the fact that it essentially introduces a memory leak, because it is only applicable to debug runs.</p>
<p><code>DebugMode</code> is defined as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CSharp" data-lang="CSharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">bool</span> <span class="n">DebugMode</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">get</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if</span> <span class="n">DEBUG</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This allows us to minimize the use of <code>#if DEBUG</code>, which is ugly and cumbersome, and often results in code rot in the <code>#endif</code> part, which is only discoverable when trying to compile the release build.</p>
<h4 id="addendum-ad-hoc-alive-states">Addendum: Ad-hoc alive states
</h4><p>Object lifetime awareness comes with a piece of advice:</p>
<blockquote>
<p>Avoid ad-hoc alive states, implement them as separate lifetime-aware objects instead.</p></blockquote>
<p>What this means is that a class should refrain from exposing a pair of methods for entering and exiting some special state of that class, and instead it should expose only one method which creates a new lifetime-aware object to represent that special state, and to exit the state when its lifetime is ended. Then, if the class has any methods which may only be invoked while in that special state, these methods must be moved into the special state object, so that they are not even available unless the special state has been entered.</p>
<p>By following this advice we split the interface of our object into smaller interfaces that are more simple and intuitive, we clearly document what is going on by making use of the lifetime-awareness pattern, and we take advantage of the error-checking and diagnostic facilities of the lifetime-awareness mechanism.</p>
<p>An example of an interface which could have benefited from this advice is the JDBC API. This interface exposes a multitude of methods for dealing with a relational database, and among them it exposes a pair of methods for beginning and ending a transaction. A better way of structuring that interface would have been to expose a single method for creating a new transaction object, which in turn ends the transaction when disposed. Then, all the data manipulation methods would be moved into that object, so that it is impossible to manipulate data unless a transaction is active.</p>
<h4 id="addendum-unmanaged-resources">Addendum: Unmanaged Resources
</h4><p>As we have shown, by leveraging hard error and diagnostic messages on debug runs and test runs, the object lifetime awareness pattern guarantees cleanup at the end of an object&rsquo;s lifetime.</p>
<p>Conveniently enough, this cleanup can, and should, include the releasing of unmanaged resources.</p>
<p>This in turn means that we never need to involve finalization for this task, not even as a fallback mechanism: unmanaged resources can be released infallibly, deterministically, and synchronously, i.e. <em>always right now,</em> as opposed to at some unknown moment later in time, if at all.  This also means that on release runs we do not need finalization at all.</p>
<p>In essence, the releasing of unmanaged resources loses the special status that it has enjoyed so far, and becomes regular cleanup just as any other kind of cleanup. Our software sees to it that all necessary cleanup is always performed, without leaving anything to chance, and without any distinctions between really important cleanup and not-so-important cleanup.</p>
<p>C#-only note: This also means that there is no more need for that <code>Dispose(bool)</code> nonsense, either.</p>
<h4 id="further-research-and-recommendations">Further research and recommendations
</h4><p>Lifetime aware objects may benefit from a lifetime control service being propagated throughout the containment hierarchy so that they can register and unregister from it, thus:</p>
<ul>
<li>Eliminating the need for a static factory of lifeguard;</li>
<li>Allowing us to at any given moment traverse the entire graph of lifetime-aware objects to see who is still alive;</li>
<li>Making it impossible to inadvertently construct a lifetime-aware object without having explicit knowledge of the fact that it is lifetime-aware, since the lifetime control service must be passed to its constructor.</li>
</ul>
<p>Object lifetime awareness has the theoretic potential of completely eliminating all finalization overhead. Unfortunately, as things stand today, this potential cannot be realized, because existing runtime environments still offer essential classes that make unconditional use of finalization; e.g. classes that represent files, sockets, etc. These environments could benefit from new implementations of such essential classes that make use of the object lifetime awareness pattern so as to also avoid finalization. (While at it, please also note that these same classes could really benefit from not being needlessly multithreading-aware; when we have a use for multithreading awareness, we can add it ourselves, thank you.)</p>
<p>Additionally, if it could be definitively established that finalization is to be used only for the purpose of generating diagnostic messages, then the entire machinery implementing finalization in runtime environments could be greatly simplified from the monster of complexity that it is today. Consider, for example, that garbage collectors are currently built to handle such preposterous situations as &ldquo;object resurrection&rdquo;, which is what may happen if a finalizer decides to anchor an object in memory, thus taking an object which had previously become eligible for collection and making it not eligible anymore. If finalization could be made trivial, then object resurrection could become impossible, or it could result in hard error rather than having to be handled.</p>
<p>Also see my previous post <a 
   href="/post/2015-03-on-dispose-bool-disposing-abomination/"
   >Mandatory disposal vs. the &ldquo;Dispose-disposing&rdquo; abomination</a></p>
<hr>
<p>Cover image: <em>The Thinker</em> (French: <em>Le Penseur</em>) by Auguste Rodin (From <a class="external" 
   href="https://en.wikipedia.org/wiki/The_Thinker" target="_blank"
   >Wikipedia</a>)</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>The language feature that C# calls &ldquo;destructor&rdquo; is a misnomer; it is not a destructor, it is a finalizer, and the choice of the tilde syntax to denote finalizers in C# as if they were C++ destructors has caused nothing but confusion. Microsoft has been reluctantly <a class="external" 
   href="https://docs.microsoft.com/en-us/archive/blogs/ericlippert/whats-the-difference-between-a-destructor-and-a-finalizer" target="_blank"
   >acknowledging this</a> and quietly <a class="external" 
   href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/destructors" target="_blank"
   >correcting their terminology</a> in their documentation.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/software-architecture/">Software-Architecture</a>
        
            <a href="/tags/software-engineering/">Software-Engineering</a>
        
            <a href="/tags/papers/">Papers</a>
        
    </section>


    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            Last updated on 2025-10-22 Wed 21:32:42 CEST
        </span>
    </section></footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">Related content</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/post/2024-03-codecoverage/">
        
        

        <div class="article-details">
            <h2 class="article-title">Artificial Code Coverage</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/post/2024-01-types-of-dependencies/">
        
        

        <div class="article-details">
            <h2 class="article-title">Types of dependencies</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/post/2023-12-27-call-graph-acyclicity/">
        
        

        <div class="article-details">
            <h2 class="article-title">Call Graph Acyclicity</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/post/2023-12-09-authoritative-technical-design/">
        
        

        <div class="article-details">
            <h2 class="article-title">Towards Authoritative Software Design</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/post/2023-01-14-mocking/">
        
        

        <div class="article-details">
            <h2 class="article-title">If you are using mock objects you are doing it wrong</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 2001 - 2025 Michael Belivanakis (a.k.a. Mike Nakis)
    </section>
    
    <section class="powerby">
        Made using <b><a href="https://obsidian.md" target="_blank">Obsidian</a></b> and <b><a href="https://gohugo.io/" target="_blank">Hugo</a></b><br />
        Theme based on <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" data-version="%s">hugo-theme-stack</a></b> by <a href="https://jimmycai.com" target="_blank">Jimmy Cai</a><br />
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.f2c01864f0b68886d640021e561a9182ddc2c60846b5b64ea7a6069cbe8a17ed.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
