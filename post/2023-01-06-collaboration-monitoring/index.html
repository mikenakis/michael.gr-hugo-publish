<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="\rAbstract An automated software testing technique is presented which solves the fragile test problem of white-box testing by allowing us to ensure that the component-under-test interacts with its collaborators according to our expectations without having to stipulate our expectations as test code, without having the tests fail each time our expectations change, and without having to go fixing test code each time this happens.\n"><title>Collaboration Monitoring</title><link rel=canonical href=https://blog.michael.gr/post/2023-01-06-collaboration-monitoring/><link rel=stylesheet href=/scss/style.min.32a512555d79ccc2867a9b2e645843323dfbe8892f99ff86e4dbb5b7316dbb25.css><meta property='og:title' content="Collaboration Monitoring"><meta property='og:description' content="\rAbstract An automated software testing technique is presented which solves the fragile test problem of white-box testing by allowing us to ensure that the component-under-test interacts with its collaborators according to our expectations without having to stipulate our expectations as test code, without having the tests fail each time our expectations change, and without having to go fixing test code each time this happens.\n"><meta property='og:url' content='https://blog.michael.gr/post/2023-01-06-collaboration-monitoring/'><meta property='og:site_name' content="Michael's Blog"><meta property='og:type' content='article'><meta property='article:section' content='post'><meta property='article:tag' content='software-architecture'><meta property='article:tag' content='testing'><meta property='article:tag' content='software-engineering'><meta property='article:published_time' content='2023-01-06T13:03:22+00:00'><meta property='article:modified_time' content='2025-10-23T19:30:57+02:00'><meta name=twitter:title content="Collaboration Monitoring"><meta name=twitter:description content="\rAbstract An automated software testing technique is presented which solves the fragile test problem of white-box testing by allowing us to ensure that the component-under-test interacts with its collaborators according to our expectations without having to stipulate our expectations as test code, without having the tests fail each time our expectations change, and without having to go fixing test code each time this happens.\n"><link rel="shortcut icon" href=/favicon.svg><script async src="https://www.googletagmanager.com/gtag/js?id=TODO"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","TODO")}</script></head><body class="article-page
article-page"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><ol class=menu id=main-menu><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol><a href=/><img src=/logo.svg width=210 loading=lazy alt=Logo></a><figure class=site-avatar><a href=/><img src="https://gravatar.com/avatar/8d1c5b5578843f958430afe30e0cbb2fb5092b1712d1933ea37d7bf5cb4305ed?size=400" width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure></header><ul class=menu-social><li><a href=/contact-via-e-mail/ title=e-Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z"/><path d="M3 7l9 6 9-6"/></svg></a></li><li><a href=/contact-via-whatsapp/ title=WhatsApp rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 21l1.65-3.8a9 9 0 113.4 2.9L3 21"/><path d="M9 10a.5.5.0 001 0V9A.5.5.0 009 9v1a5 5 0 005 5h1a.5.5.0 000-1h-1a.5.5.0 000 1"/></svg></a></li><li><a href=https://github.com/mikenakis target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/mikenakis target=_blank title=LinkedIn rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 11v5"/><path d="M8 8v.01"/><path d="M12 16v-5"/><path d="M16 16v-3a2 2 0 10-4 0"/><path d="M3 7a4 4 0 014-4h10a4 4 0 014 4v10a4 4 0 01-4 4H7a4 4 0 01-4-4z"/></svg></a></li><li><a href=https://stackoverflow.com/users/773113/mike-nakis target=_blank title="Stack Overflow" rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 17v1a2 2 0 002 2h12a2 2 0 002-2v-1"/><path d="M8 16h8"/><path d="M8.322 12.582l7.956.836"/><path d="M8.787 9.168l7.826 1.664"/><path d="M10.096 5.764l7.608 2.472"/></svg></a></li><li><a href=https://twitter.com/mikenakis target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ul><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/portfolio/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Portfolio</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#abstract>Abstract</a></li><li><a href=#summary>Summary</a></li><li><a href=#the-problem>The problem</a></li><li><a href=#the-solution>The Solution</a></li><li><a href=#what-about-code-review>What about code review?</a></li><li><a href=#requirements>Requirements</a></li><li><a href=#automation>Automation</a><ol><li><a href=#comparison-of-workflows>Comparison of Workflows</a></li><li><a href=#conclusion>Conclusion</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/post/2023-01-06-collaboration-monitoring/>Collaboration Monitoring</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2023-01-06 Fri 13:03:22 UTC</time></div><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
<time class=article-time--reading>11 minute read</time></div></footer></div></header><section class=article-content><p><img src=/post/2023-01-06-collaboration-monitoring/media/collaboration-monitoring.png width=1024 height=512 loading=lazy class=gallery-image data-flex-grow=200 data-flex-basis=480px></p><h3 id=abstract>Abstract</h3><p>An automated software testing technique is presented which solves the fragile test problem of white-box testing by allowing us to ensure that the component-under-test interacts with its collaborators according to our expectations without having to stipulate our expectations as test code, without having the tests fail each time our expectations change, and without having to go fixing test code each time this happens.</p><p>(Useful pre-reading: <a href=/post/2022-11-about-these-papers/>About these papers</a>)</p><h3 id=summary>Summary</h3><p>In automated software testing it is sometimes necessary to ensure not only that given specific input, the component-under-test produces correct output, (<a class=external href=https://en.wikipedia.org/wiki/Black-box_testing target=_blank>Black-Box Testing</a>,) but also that while doing so, it interacts with its collaborators in certain expected ways. (<a class=external href=https://en.wikipedia.org/wiki/White-box_testing target=_blank>White-Box Testing</a>.) The prevailing technique for achieving white-box testing (<a class=external href=https://en.wikipedia.org/wiki/Mock_object target=_blank>Mock Objects</a>) requires copious amounts of additional code in the tests to describe the interaction that are expected to happen, and fails the tests if the actual interactions deviate from the expected ones.</p><p>Unfortunately, the interactions often change due to various reasons, for example applying a bug fix, performing refactoring, or modifying existing code in order to accommodate the addition of new code intended to introduce new functionality; so, tests keep breaking all the time, (the <a class=external href=https://xunitpatterns.com/Fragile%20Test.html target=_blank>Fragile Test</a> problem,) requiring constant maintenance, which imposes a heavy burden on the Software Development process.</p><p><em><strong>Collaboration Monitoring</strong></em> is a technique for white-box testing where during a test run we record detailed information about the interactions between collaborators, we compare the recording against that of a previous test run, and we visually examine the differences to determine whether the changes observed in the interactions are as expected according to the changes that were made in the code. Thus, no code has to be written to describe in advance how collaborators are expected to interact, and no tests have to be fixed each time the expectations change.</p><h3 id=the-problem>The problem</h3><p>Most software testing as conventionally practiced all over the world today consists of two parts:</p><ul><li><em><strong>Result Validation:</strong></em> ascertaining that given specific input, the component-under-test produces specific expected output.</li><li><em><strong>Collaboration Validation:</strong></em> ensuring that while performing a certain computation, the component-under-test interacts with its collaborators in specific expected ways.</li></ul><p>As I argue elsewhere, in the vast majority of cases, Collaboration Validation is ill-advised, because it constitutes white-box testing; however, there are some cases where it is necessary, for example:</p><ul><li>In high-criticality software, which is all about safety, not only the requirements must be met, but also nothing must be left to chance. Thus, the cost of white-box testing is justified, and the goal is in fact to ensure that the component-under-test not only produces correct results, but also that while doing so, it interacts with its collaborators as expected.</li><li>In reactive programming, the component-under-test does not produce output by returning results from function calls; instead, it produces output by forwarding results to collaborators. Thus, even if all we want to do is to ascertain the correctness of the component's output, we have to examine how it interacts with its collaborators, because that is the only way to observe its output.</li></ul><p>The prevalent mechanism by which the Software Industry achieves Collaboration Validation today is Mock Objects. As I argue elsewhere, (see <a href=/post/2023-01-14-mocking/>If you are using mock objects you are doing it wrong</a>) the use of mocks is generally ill-advised due to various reasons, but with respect to Collaboration Validation in specific, the problem with mocks is that their use is extremely laborious:</p><ul><li>When we write a test for a certain component, it is counter-productive to have to stipulate in code exactly how we expect it to interact with its collaborators.</li><li>When we revise the implementation of a component, the component may now legitimately start interacting with its collaborators in a different way; when this happens, it is counter-productive to have the tests fail, and to have to go fix them so that they stop expecting the old interactions and start expecting the new interactions.</li></ul><p>The original promise of automated software testing was to allow us to modify code without the fear of breaking it, but with the use of mocks the slightest modification to the code causes the tests to fail, so the code always looks broken, and the tests always require fixing.</p><p>This is particularly problematic in light of the fact that there is nothing about the concept of Collaboration Validation which requires that the interactions between collaborators must be stipulated in advance, nor that the tests must fail each time the interactions change; all that is required is that we must be able to tell whether the interactions between collaborators are as expected or not. Thus, Collaboration Validation does not necessitate the use of mocks; it could conceivably be achieved by some entirely different means.</p><h3 id=the-solution>The Solution</h3><p>If we want to ensure that given specific input, a component produces expected results, we do of course have to write some test code to exercise the component as a black-box. If we also want to ensure that the component-under-test interacts with its collaborators in specific ways while it is being exercised, this would be white-box testing, so it would be best if it does not have to also be written in code. To achieve this without code, all we need is the ability to somehow capture the interactions so that we can visually examine them and decide whether they are in agreement with our expectations:</p><ul><li>If they are not as expected, then we have to keep working on the production code and/or the black-box testing code.</li><li>If they are as expected, then we are done: we can commit our code, and call it a day, without having to modify any white-box tests!</li></ul><p>The trick is to do so in a convenient, iterative, and fail-safe way, meaning that the following must hold true:</p><ul><li>When a change in the code causes a change in the interactions, there should be some kind of indication telling us that the interactions have now changed, and this indication should be so clear that we cannot possibly miss it.</li><li>Each time we modify some code and run the tests, we want to be able to see what has changed in the interactions as a result of only those modifications, so that we do not have to pore through long lists of irrelevant interactions, and so that no information gets lost in the noise.</li></ul><p>To achieve this, I use a technique that I call Collaboration Monitoring.</p><p>Collaboration Monitoring is based on another testing technique that I call Audit Testing, so it might be a good idea to read the related paper before proceeding: <a href=/post/2024-04-audit-testing/>Audit Testing</a>.</p><p>Let us assume that we have a component that we want to test, which invokes interface T as part of its job. In order to test the component, we have to wire it with a collaborator that implements T. For this, we can use either the real collaborator that would be wired in the production environment, or a Fake thereof. Regardless of what we choose, we have a very simple picture which looks like this:</p><p><img src=/post/2023-01-06-collaboration-monitoring/media/collaboration-monitor-1.png width=422 height=74 loading=lazy class=gallery-image data-flex-grow=570 data-flex-basis=1368px></p><p>Note that with this setup we can exercise the component-under-test as a black-box, but we cannot yet observe how it interacts with its collaborator.</p><p>In order to observe how the component-under-test interacts with its collaborator, we interject between the two of them a new component, called a <em><strong>Collaboration Monitor</strong></em>, which is a decorator of T. The purpose of this Collaboration Monitor is to record into a text file information about each function call that passes through it. The text file is called a <em><strong>Snoop File</strong></em>, and it is a special form of <em><strong>Audit File</strong></em>. (See <a href=/post/2024-04-audit-testing/>Audit Testing</a>.)</p><p>Thus, we now have the following picture:</p><p><img src=/post/2023-01-06-collaboration-monitoring/media/collaboration-monitor-2.png width=568 height=193 loading=lazy class=gallery-image data-flex-grow=294 data-flex-basis=706px></p><p>The information that the Collaboration Monitor saves for each function call includes:</p><ul><li>The name of the function.</li><li>A serialization of the value of each parameter that was passed to the function.</li><li>A serialization of the return value of the function.</li></ul><p>As per Audit Testing, the Snoop File is saved in the source code tree, right next to the source code file of the test that generated it, and gets committed into the Source Code Repository / Version Control System along with the source code. For example, if we have <code>SuchAndSuchTest.java</code>, then after running the tests for the first time we will find a <code>SuchAndSuchTest.snoop</code> file right next to it. We can examine this file to ensure that the component-under-test interacted with the collaborator exactly as expected.</p><p>As we continue developing our system, the modifications that we make to the code will sometimes have no effect on how collaborators interact with each other, and sometimes will cause the collaborators to start interacting differently. Thus, as we continue running our tests while developing our system, we will be observing the following:</p><ul><li>For as long as the collaborations continue in exactly the same way, the contents of the Snoop Files remain unchanged, despite the fact that the files are re-generated on each test run.</li><li>As soon as some collaborations change, the contents of some Snoop Files will change.</li></ul><p>As per Audit Testing, we can then leverage our Version Control System and our Integrated Development Environment to take care of the rest of the workflow, as follows:</p><ul><li>When we make a revision in the production code or in the testing code, and as a result of this revision the interactions between the component-under-test and its collaborators are now even slightly different, we will not fail to take notice because our Version Control System will show the corresponding Snoop File as modified and in need of committing.</li><li>By asking our Integrated Development Environment to show us a "diff" between the current snoop file and the unmodified version, we can see precisely what has changed without having to pore through the entire snoop file.</li><li>If the observed interactions are not exactly what we expected them to be according to the revisions we just made, we keep working on our revision.</li><li>When we are confident that the differences in the interactions are exactly as expected according to the changes that we made to the code, we commit our revision, along with the Snoop Files.</li></ul><h3 id=what-about-code-review>What about code review?</h3><p>As per Audit Testing, the reviewer is able to see both the changes in the code, and the corresponding changes in the Snoop Files, and vouch for them, or not, as the case might be.</p><h3 id=requirements>Requirements</h3><p>For Collaboration Monitoring to work, snoop files must be free from non-deterministic noise, and it is best if they are also free from deterministic noise. For more information about these types of noise and what you can do about them, see <a href=/post/2024-04-audit-testing/>Audit Testing</a>.</p><h3 id=automation>Automation</h3><p>When using languages like Java and C# which support reflection and intermediate code generation, we do not have to write Collaboration Monitors by hand; we can instead create a facility which will be automatically generating them for us on demand, at runtime. Such a facility can be very easily written with the help of Intertwine (see <a href=/post/2022-12-intertwine/>Intertwine</a>.)</p><p>Using Intertwine, we can create a Collaboration Monitor for any interface T. Such a Collaboration Monitor works as follows:</p><ul><li>Contains an Entwiner of T so that it can expose interface T without any hand-written code implementing interface T. The Entwiner delegates to an instance of <code>AnyCall</code>, which expresses each invocation in a general-purpose form.</li><li>Contains an implementation of <code>AnyCall</code> which serializes all necessary information about the invocation into the Snoop File.</li><li>Contains an untwiner of T, so that it can convert each invocation from <code>AnyCall</code> back to an instance of T, without any hand-written code for invoking interface T.</li></ul><h4 id=comparison-of-workflows>Comparison of Workflows</h4><p>Here is a step-by-step comparison of the software development process when using mocks, and when using collaboration monitoring.</p><p><strong>Workflow using Mock Objects:</strong></p><ol><li>Modify the production code and/or the black-box part of the tests.</li><li>Run the tests.<ul><li>If the tests pass:<ul><li>Done.</li></ul></li><li>If the tests fail:<ul><li>Troubleshoot why this is happening.<ul><li>If either the production code or the black-box part of the tests is
wrong:<ul><li>Go to step 1.</li></ul></li><li>If the white-box part of the tests is wrong:<ul><li>Modify the white-box part of the tests (the mocking code) to stop expecting the old interactions and start expecting the new interactions.</li><li>Go to step 2.</li></ul></li></ul></li></ul></li></ul></li></ol><p><strong>Workflow using Collaboration Monitoring:</strong></p><ol><li>Modify the production code and/or the tests.</li><li>Run the tests.<ul><li>If the tests pass:<ul><li>If the interactions have remained unchanged:<ul><li>Done.</li></ul></li><li>If the interactions have changed:<ul><li>Visually inspect the changes.<ul><li>If the interactions agree with our expectations:<ul><li>Done.</li></ul></li><li>If the interactions differ from our expectations:<ul><li>Go to step 1.</li></ul></li></ul></li></ul></li></ul></li><li>If the tests fail:<ul><li>Go to step 1.</li></ul></li></ul></li></ol><h4 id=conclusion>Conclusion</h4><p>Collaboration Monitoring is an adaptation of Audit Testing which allows the developer to write black-box tests which only exercise the public interface of the component-under-test, while remaining confident that the component interacts with its collaborators inside the black box according to their expectations, without having to write white-box testing code to stipulate the expectations, and without having to modify white-box testing code each time the expectations change.</p><hr><p>Cover image: "Collaboration Monitoring" by michael.gr based on original work <a class=external href=https://thenounproject.com/icon/monitoring-4861371/ target=_blank>'monitoring' by Arif Arisandi</a> and <a class=external href=https://thenounproject.com/icon/gears-1705750/ target=_blank>'Gears' by Free Fair & Healthy</a> from the Noun Project.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/software-architecture/>Software Architecture</a>
<a href=/tags/testing/>Testing</a>
<a href=/tags/software-engineering/>Software Engineering</a></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on 2025-10-23 Thu 19:30:57 CEST</span></section></footer></article><script>var idcomments_post_id,idcomments_post_url,idcomments_acct="131c02e0ef20d1a4606aa4e3490711ba"</script><span id=IDCommentsPostTitle style=display:none></span>
<script type=text/javascript src=https://www.intensedebate.com/js/genericCommentWrapperV2.js></script><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/2025-04-the-confusion-about-term-unit-testing/><div class=article-details><h2 class=article-title>The confusion about the term Unit Testing</h2></div></a></article><article><a href=/post/2024-03-codecoverage/><div class=article-details><h2 class=article-title>Artificial Code Coverage</h2></div></a></article><article><a href=/post/2023-01-14-mocking/><div class=article-details><h2 class=article-title>If you are using mock objects you are doing it wrong</h2></div></a></article><article><a href=/post/2022-10-testing-with-fakes/><div class=article-details><h2 class=article-title>Testing with Fakes instead of Mocks</h2></div></a></article><article><a href=/post/2022-10-incremental-integration-testing/><div class=article-details><h2 class=article-title>Incremental Integration Testing</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy; 2001 - 2026 Michael Belivanakis (a.k.a. Mike Nakis)</section><section class=powerby>Made using <b><a href=https://obsidian.md target=_blank>Obsidian</a></b> and <b><a href=https://gohugo.io/ target=_blank>Hugo</a></b><br>Theme based on <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank data-version=%s>hugo-theme-stack</a></b> by <a href=https://jimmycai.com target=_blank>Jimmy Cai</a><br></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>