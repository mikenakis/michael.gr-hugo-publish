<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content=" Foreword Historically, the difference between scripting languages and real programming languages has been understood as the presence or absence of a compilation step. However, in recent decades the distinction has blurred; from time to time we have seen:\nInterpreters for languages that were originally meant to be compiled. Compilers for languages that were originally meant to be interpreted. Scripting engines internally converting source code to bytecode before interpreting it. Real languages compiling to bytecode which is then mostly interpreted and rarely converted to machine code. So, compiled vs. interpreted does not seem to be the real differentiating factor; nonetheless, we can usually tell a scripting language when we see one. So, what is it that we see?\n"><title>On Scripting Languages</title><link rel=canonical href=http://blog2.michael.gr/post/2017-05-on-scripting-languages/><link rel=stylesheet href=/scss/style.min.3994e2c47c62da77b2a9fe33e39ea957c2a998fa0dd8b3970a61493bb07dac2c.css><meta property='og:title' content="On Scripting Languages"><meta property='og:description' content=" Foreword Historically, the difference between scripting languages and real programming languages has been understood as the presence or absence of a compilation step. However, in recent decades the distinction has blurred; from time to time we have seen:\nInterpreters for languages that were originally meant to be compiled. Compilers for languages that were originally meant to be interpreted. Scripting engines internally converting source code to bytecode before interpreting it. Real languages compiling to bytecode which is then mostly interpreted and rarely converted to machine code. So, compiled vs. interpreted does not seem to be the real differentiating factor; nonetheless, we can usually tell a scripting language when we see one. So, what is it that we see?\n"><meta property='og:url' content='http://blog2.michael.gr/post/2017-05-on-scripting-languages/'><meta property='og:site_name' content="Michael's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='software-engineering'><meta property='article:tag' content='grumpy'><meta property='article:tag' content='papers'><meta property='article:published_time' content='2017-05-19T19:46:34+00:00'><meta property='article:modified_time' content='2025-10-23T01:04:50+02:00'><meta name=twitter:title content="On Scripting Languages"><meta name=twitter:description content=" Foreword Historically, the difference between scripting languages and real programming languages has been understood as the presence or absence of a compilation step. However, in recent decades the distinction has blurred; from time to time we have seen:\nInterpreters for languages that were originally meant to be compiled. Compilers for languages that were originally meant to be interpreted. Scripting engines internally converting source code to bytecode before interpreting it. Real languages compiling to bytecode which is then mostly interpreted and rarely converted to machine code. So, compiled vs. interpreted does not seem to be the real differentiating factor; nonetheless, we can usually tell a scripting language when we see one. So, what is it that we see?\n"><link rel="shortcut icon" href=/favicon.svg><script async src="https://www.googletagmanager.com/gtag/js?id=TODO"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","TODO")}</script></head><body class="article-page
article-page"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><ol class=menu id=main-menu><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol><a href=/><img src=/logo.svg width=210 loading=lazy alt=Logo></a><figure class=site-avatar><a href=/><img src="https://gravatar.com/avatar/8d1c5b5578843f958430afe30e0cbb2fb5092b1712d1933ea37d7bf5cb4305ed?size=400" width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Michael's Blog</a></h1><h2 class=site-description>If it's worth doing, it's worth doing right.</h2></div></header><ul class=menu-social><li><a href=/contact-via-e-mail/ title=e-Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z"/><path d="M3 7l9 6 9-6"/></svg></a></li><li><a href=/contact-via-whatsapp/ title=WhatsApp rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 21l1.65-3.8a9 9 0 113.4 2.9L3 21"/><path d="M9 10a.5.5.0 001 0V9A.5.5.0 009 9v1a5 5 0 005 5h1a.5.5.0 000-1h-1a.5.5.0 000 1"/></svg></a></li><li><a href=https://github.com/mikenakis target=_blank title=GitHub rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/mikenakis target=_blank title=LinkedIn rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 11v5"/><path d="M8 8v.01"/><path d="M12 16v-5"/><path d="M16 16v-3a2 2 0 10-4 0"/><path d="M3 7a4 4 0 014-4h10a4 4 0 014 4v10a4 4 0 01-4 4H7a4 4 0 01-4-4z"/></svg></a></li><li><a href=https://stackoverflow.com/users/773113/mike-nakis target=_blank title="Stack Overflow" rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 17v1a2 2 0 002 2h12a2 2 0 002-2v-1"/><path d="M8 16h8"/><path d="M8.322 12.582l7.956.836"/><path d="M8.787 9.168l7.826 1.664"/><path d="M10.096 5.764l7.608 2.472"/></svg></a></li><li><a href=https://twitter.com/mikenakis target=_blank title=Twitter rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753c0-.249 1.51-2.772 1.818-4.013z"/></svg></a></li></ul><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#foreword>Foreword</a></li><li><a href=#arguments-in-favor-of-scripting-languages>Arguments in favor of scripting languages</a></li><li><a href=#the-problems-with-scripting-languages>The problems with scripting languages</a><ol><li><a href=#the-nonsense>The nonsense</a></li><li><a href=#the-errors>The errors</a></li><li><a href=#the-crippled-ide>The crippled IDE</a></li><li><a href=#that-little-performance-issue>That little performance issue</a></li><li><a href=#the-horrendous-syntax>The horrendous syntax</a></li><li><a href=#the-cheapness>The cheapness</a></li></ol></li><li><a href=#what-scripting-languages-are-good-for>What scripting languages are good for</a></li><li><a href=#conclusion>Conclusion</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header></header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/post/2017-05-on-scripting-languages/>On Scripting Languages</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2017-05-19 Fri 19:46:34 UTC</time></div><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
<time class=article-time--reading>24 minute read</time></div></footer></div><section class=article-content><p><img src=/post/2017-05-on-scripting-languages/images/pacifiers.jpg width=1023 height=575 srcset="/post/2017-05-on-scripting-languages/images/pacifiers_hu_6f30f1f417e0fba0.jpg 480w, /post/2017-05-on-scripting-languages/images/pacifiers_hu_ac31a6389070d9d4.jpg 1024w" loading=lazy alt="Teething rings (pacifiers) found on the great interwebz." class=gallery-image data-flex-grow=177 data-flex-basis=426px></p><h3 id=foreword>Foreword</h3><p>Historically, the difference between scripting languages and real programming languages has been understood as the presence or absence of a compilation step. However, in recent decades the distinction has blurred; from time to time we have seen:</p><ul><li>Interpreters for languages that were originally meant to be compiled.</li><li>Compilers for languages that were originally meant to be interpreted.</li><li>Scripting engines internally converting source code to bytecode before
interpreting it.</li><li>Real languages compiling to bytecode which is then mostly interpreted and
rarely converted to machine code.</li></ul><p>So, compiled vs. interpreted does not seem to be the real differentiating factor; nonetheless, we can usually tell a scripting language when we see one. So, what is it that we see?</p><p>(Useful pre-reading: <a href=/post/2022-11-about-these-papers/>About these papers</a>)</p><p>First, let us identify the three different kinds of error that can potentially occur in program code:</p><ul><li><strong>Syntax Error:</strong> this represents a violation of fundamental rules governing the <em>form</em> of the language; for example, in most programming languages the statement <code>a = ;</code> is a syntax error, because something is obviously missing between the equals sign and the semicolon.</li><li><strong>Semantic Error:</strong> this represents failure to respect the <em>meaning</em> of things; for example, in most languages the statement <code>a = "x" / 5;</code> is syntactically correct but semantically incorrect, because dividing a string by a number does not make sense. As another example, the statement <code>a.increment();</code> may represent a semantic error if object <code>a</code> has no method called <code>increment</code>.</li><li><strong>Logic Error:</strong> this corresponds to a mistake in our <em>reasoning</em>. For example, the statement <code>circumference = radius * Ï€</code> can be correct both syntactically and semantically, but it is nonetheless flawed, because this is not how you calculate a circumference given a radius; the correct formula also involves a multiplication by 2.</li></ul><p>From the three types of error that we have identified, the first and the last are unaffected by our choice of programming language:</p><ul><li>Syntax error will be detected by any halfway decent IDE regardless of whether we are using a scripting language or a real programming language.</li><li>Logic error is just as easy to make in any programming language, and the way we protect ourselves against it is by writing copious amounts of automated software tests.</li></ul><p>Semantic Error is where different kinds of languages take vastly different approaches. This type of error is closely associated with the concept of data types:</p><ul><li><p>The expression <code>"x" / 5</code> is flawed because the left operand is of type string, while the right operand is of a numeric type.</p></li><li><p>The validity of the statement <code>a.increment()</code> depends upon the type of <code>a</code>, and whether that type defines an <code>increment()</code> method or not.</p></li></ul><p>If the programming language is strongly typed, then semantic error will always be detected during compilation, so there is never any danger of attempting to run (or ship to the customer) a program containing this kind of error; however, if the programming language is weakly typed, then all semantic error will go undetected until an attempt is made to execute code containing such error, at which point the software will severely malfunction.</p><p>In light of the above, I would suggest that the actual differentiating factor between real programming and scripting languages is nothing but the presence or absence of semantic checking, in other words the use of strong vs. weak typing.</p><p>TypeScript is the odd exception to the rule, and this is to be expected, because the impetus for the creation of TypeScript was vastly different from that of other scripting languages, which tend to be one-man efforts, and usually come into existence as nothing more than toy projects. In contrast, TypeScript was the result of a deliberate group effort backed by a big company (Microsoft) starting with the realization that JavaScript is unfortunately here to stay, and setting out specifically to correct one of its major deficiencies, namely the lack of strong typing.</p><p>The trend of real programming languages to be compiled and of scripting languages to be interpreted can be explained <em>in full</em> as a consequence of the primary choice of strong vs. weak typing:</p><ul><li><p>If a language is strongly typed, then a compilation step is very useful to
have, because it will unfailingly locate all errors that are detectable via
static semantic analysis before attempting to run.</p></li><li><p>If a language is weakly typed, then semantic errors are undetectable, so
there is no need to parse code in advance. A compilation step would only
reveal syntactic errors, which can also be detected by any halfway decent
IDE.</p></li></ul><p>So, allowing for the exception of TypeScript, this leaves us with the following soft rule:</p><blockquote><p>Real languages are strongly typed, employ semantic checking, and are therefore usually compiled.</p></blockquote><blockquote><p>Scripting languages are weakly typed, lack semantic checking, and are therefore usually interpreted.</p></blockquote><p>And yet, many people like scripting languages, and write lots of code in them, supposedly because they are "easier". This brings to mind the famous quote by Edsger W. Dijkstra:</p><blockquote><p>{...} some people found error messages they couldn't ignore more annoying than wrong results, and, when judging the relative merits of programming languages, some still seem to equate "the ease of programming" with the ease of making undetected mistakes.</p><p>(Edsger W. Dijkstra, <em><a class=external href=https://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD667.html target=_blank>On the foolishness of "natural language programming"</a>.</em>)</p></blockquote><p>Note that the above quote is from a paper about Natural Language Programming (NLP) but the particular passage containing the quote pertains to programming languages in general. Dijkstra wrote against NLP back in the 1980s because at that time it was being considered by some fools as a viable prospect; luckily, it failed to catch on, (or <em>naturally</em>, if you would permit the pun,) but little did ol' Edsger know that in the decades that would follow his nightmares would come true, because scripting languages <em>did</em> catch on. Apparently, people <em>love</em> making undetected mistakes.</p><h3 id=arguments-in-favor-of-scripting-languages>Arguments in favor of scripting languages</h3><p><strong>Argument:</strong> It is easy to write code in it; look, the "hello, world!" program is a one-liner.</p><p><strong>Rebuttal:</strong> What this means is that this scripting language is a very good choice, possibly even the ideal choice, for writing the "hello, world!" program.</p><p>The ease with which you may write "hello, world!" is no indication whatsoever about the ease with which a non-trivial system may be collaboratively developed, tested, debugged, maintained, and extended.</p><p><strong>Argument:</strong> No, I mean it is really terse. There are many things besides "hello, world!" that I can write in one line.</p><p><strong>Rebuttal:</strong> Sure, you can write them in one line; but can you read them?</p><p>One of the most important aspects of code is readability, (second only to correctness,) but terse code is not necessarily easy to read; if that was the case, then Perl would be the most readable language ever, but instead it enjoys the dubious distinction of being the least readable among all programming languages in general use.</p><p>Terseness usually represents a tradeoff between verbosity and understandability: the more terse the code, the less of it you have to read, but also the harder it is to untangle its complexity. Thus, it is debatable whether terseness correlates with readability. Terseness appears to be the modern trend, so as real programming languages keep evolving they are also receiving features that make them more and more terse, for example tuples, lambdas, the fluent style of invocations, etc. So, terseness is not the exclusive domain of scripting languages, and to the extent that scripting languages go further in this regard it is debatable whether it is an advantage or a disadvantage.</p><p><strong>Argument:</strong> There are lots of libraries for it.</p><p><strong>Rebuttal:</strong> Seriously? There are more libraries for your scripting language than there are for Java?</p><p><strong>Argument:</strong> I don't have to compile it; I just write my code and run it.</p><p><strong>Rebuttal:</strong> I also just write my code and run it. When I hit the "launch" button, my IDE compiles my code in the blink of an eye and runs it. The difference between you and me is that if I have made any semantic mistakes in my code, I will be told so before wasting my time trying to run it. But what am I saying, being told that there are semantic mistakes in your code probably counts as a disadvantage for you, right?</p><p>The ability to just write your code and run it without any semantic checking is causing real harm in scripting languages because it prevents them from evolving. This is, for example, a reason why Python version 2.x is still enjoying widespread use despite the language having moved on to version 3.x by now: people are afraid to make the transition to version 3.x in existing projects, even though it is mostly backwards compatible with version 2.x, because it is not 100% compatible, and lack of semantic checking means that there is no way of knowing which lines of code will break unless these lines get executed.</p><p><strong>Argument:</strong> I can modify my program as it runs.</p><p><strong>Rebuttal:</strong> I can also modify my program as it runs; the ability to do this is available in most real programming languages, and it is called "edit and continue" or "hot reload" depending on the language; look it up.</p><p>Modification of running code is not always applicable in real programming languages, and it does not always work, but then again nor does it always work when you modify running code in a scripting language, because usually, you already have data structures in memory that were created by the code before it was modified. In real programming languages, you are prevented from making edits to running code that would seriously foul things up; in scripting languages, you are allowed to do whatever you please, and the catastrophic consequences of doing so are your own problem.</p><p><strong>Argument:</strong> I do not like to have to declare the type of every single variable because it is a pain.</p><p><strong>Rebuttal:</strong> This is akin to arguing against seat belts because putting them on and taking them off is a pain. Do you have any idea of what kind of pain you are looking at if you get in a traffic accident without a seat belt?</p><p>Furthermore, the ability to not have to declare the type of every single variable is not the exclusive privilege of scripting languages, because in recent years type inference has been gaining ground in real programming languages, allowing us to omit declaring the type of many of the variables that we use. The difference is that in real programming languages this is done right, by means of type inference instead of type ostrichism:</p><ul><li><p>Type inference is deterministic extra work that the compiler does for us,
and it relies on having already assigned specific types to other variables,
so that we do not have to repeat things that are already known to, or can be
inferred by, the compiler.</p></li><li><p>Type ostrichism is scripting language programmers preferring to not see
types and to not deal with types, as if that will make the types go away.</p></li></ul><p>It might be worth taking a look at PEP 483 (<a class=external href=https://peps.python.org/pep-0483/ target=_blank>https://peps.python.org/pep-0483/</a>) where the people responsible for the advancement of Python are acknowledging that behind the scenes every variable is of course of a specific type, and discussing the potential benefits of adding a type annotation system to the language which will allow programmers to make their intentions about types explicit, so as to be able to at least partially, and at least as an afterthought, enjoy some of the benefits of strong typing. I quote:</p><blockquote><p>These annotations can be used to avoid many kind of bugs, for documentation purposes, or maybe even to increase speed of program execution.</p></blockquote><p><strong>Argument:</strong> I am not worried about errors, because I use testing.</p><p><strong>Rebuttal:</strong> Oh really? Are your tests achieving even a mere 60% code coverage as we speak? And supposing that they do, how do you feel about the fact that in the remaining 40%, every single line is liable to break due to reasons as trivial and yet as common as a typo?</p><p>Testing is an indispensable quality assurance mechanism for software, but it does not, in and by itself, guarantee correctness. You can easily forget to test something, and you can easily test "around" a bug, essentially creating tests that pretty much require the bug to be in place in order to pass. Despite these deficiencies, testing is still very important, but it is nothing more than a weapon in our arsenal against bugs. This arsenal also happens to include another weapon, which is closer to the forefront in the battle against bugs, and it is 100% objective, and <em>definitive</em>. This weapon is called <em>strong typing</em>.</p><p><strong>Argument:</strong> It has lots and lots of built-in features.</p><p><strong>Rebuttal:</strong> Sure, and that's why scripting languages are not entirely useless. If the only thing that matters is to accomplish a certain highly self-contained goal of severely limited scope in as little time as possible, then please, by all means, do go ahead and use your favorite scripting language with its awesome built-in features. However, if the project is bound to take a life of its own, you are far better off investing a couple of minutes to create a project in a real programming language, and to include the external libraries that will give you any extra features that you might need.</p><p>Built-in features do not only come with benefits; in contrast to libraries, they are much more difficult to evolve, because even a minute change in them may break existing code, resulting in people being reluctant to migrate to the latest version of the language. (Take the Python 2.x vs. 3.x conundrum for example.)</p><p>Furthermore, built-in features usually have to be supported forever, even after better alternatives have been invented, or after they simply go out of style and fall out of grace, so over time scripting languages tend to gather lots of unnecessary baggage. We have tried feature-bloated programming languages before, (with ADA for example,) and the consensus is that they are not the way to go.</p><p><strong>Argument:</strong> But really, it is so much easier! Look here, in one statement I obtain a list and assign its elements to individual variables!</p><p><strong>Rebuttal:</strong> That's great, I bet this has slashed your time-to-market by half. What happens if the number of elements in the list differs from the number of variables that you decompose it into? I bet there is no error, because you do not like being bothered with errors, right?</p><p>In any case, my compiled language of choice has its own unique, arcane syntax quirks that I could, if I wanted to, claim that they make things so much easier for me.</p><p>Some of them are not even that arcane; for example, instead of using clunky annotations to hint to the IDE the types of my variables, so that it can then provide me with some rudimentary type checking, I get to simply declare the type of each variable as part of the actual syntax of the language! Imagine that!</p><p><strong>Argument:</strong> I like dynamic typing. It gives me freedom.</p><p><strong>Rebuttal:</strong> Yes, freedom to shoot yourself in the foot. Also please note that there is no such thing as "dynamic" typing; this term is just a euphemism invented by scripting language aficionados to down-play the detrimental nature of this practice. The proper term is <em><strong>weak</strong></em> typing.</p><p><strong>Argument:</strong> I do not need type safety. I am better off without it.</p><p><strong>Rebuttal:</strong> Right. So, you are the technological equivalent of an anti-vaxxer. (Credit: <a class=external href=https://danluu.com/empirical-pl/ target=_blank>danluu</a>)</p><p><strong>Argument:</strong> I do not have to use an IDE, I can just use my favorite text editor.</p><p><strong>Rebuttal:</strong> Oh sure. You are also the technological equivalent of an Amish farmer.</p><p><strong>Argument:</strong> My scripting language is trendy. It is hip.</p><p>No contest here. I can't argue with hipsters.</p><h3 id=the-problems-with-scripting-languages>The problems with scripting languages</h3><h4 id=the-nonsense>The nonsense</h4><p>I don't need to say much here, just watch the legendary "Wat" video by Gary Bernhardt from CodeMash 2012, it is only 4 minutes long:</p><video width=97% poster=https://www.destroyallsoftware.com/assets/posters/talks/wat.poster-4f5425901c10ffeaceb61f82e25dc40b9212aadf078cead0dc6ffe40696e2bec.png preload=none>
<source src="https://destroyallsoftware-talks.s3.amazonaws.com/wat.mp4?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIKRVCECXBC4ZGHIQ%2F20241128%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20241128T124514Z&amp;X-Amz-Expires=14400&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=866f87a9e2a988029db034ad51f846818c5a2e4415da80559bb334e602fd6bad"><track label=English kind=captions srclang=en src=/captions/talks/wat.vtt></track></video><p>Source: <a class=external href=https://www.destroyallsoftware.com/talks/wat target=_blank>https://www.destroyallsoftware.com/talks/wat</a></p><p>The reason for all this nonsense is that all these languages are hacks.</p><p>When the foundation that you are working on is a hack, then either anything you will build on top of it will in turn be a hack, or you are going to be putting an enormous effort to circumvent the hackiness of the foundation and build something reasonable over it. Why handicap yourself?</p><h4 id=the-errors>The errors</h4><p>Lack of semantic checking means that the mistakes that will inevitably be made will not be caught by a compilation step. Therefore, lack of semantic checking necessarily means that there will be more errors.</p><p>It is an established fact that a certain percentage of errors will always pass testing and make it to production, which in turn inescapably means that there will be a somewhat increased number of bugs in production.</p><p>This alone is enough to classify scripting languages as unsuitable for anything but tinkering, and the debate should be over right there.</p><h4 id=the-crippled-ide>The crippled IDE</h4><p>Lack of semantic checking means that your IDE cannot provide you with many useful features that you get with strongly typed languages. Specifically, you either have limited functionality, or you do not have at all, some or all of the following features:</p><ol><li><strong>Context-sensitive argument auto-completion.</strong> Since any parameter to any function can be of any type, the IDE usually has no clue as to which of the variables in scope may be passed to a certain parameter of a certain function. Therefore, it has to suggest everything that happens to be in scope. Most of these suggestions are preposterous, some are even treacherous.</li><li><strong>Member Auto-completion.</strong> Since a variable does not have a specific type, the IDE usually has no clue as to what member fields and functions are exposed by that variable. Therefore, either it cannot give any suggestions, or it has to suggest every single member of every single known type and the kitchen sink.</li><li><strong>Listing all usages of a type.</strong> Since any variable can be of any type, the IDE usually has no clue as to where a given type is used, or if it is used at all. Contrast this with strongly typed languages where the IDE can very accurately list all usages of any given type and even provide you with visual clues about unused types.</li><li><strong>Type sensitive search.</strong> If you have multiple different types where each one of them contains, say, a <code>Name</code> member, you cannot search for all references of the <code>Name</code> member of only one of those types. You have to use text search, which will yield all irrelevant synonyms in the results. This can be okay in tiny projects, but it very quickly becomes non-viable as the project size increases.</li><li><strong>Refactoring.</strong> When the IDE has no knowledge of the semantics of your code, it is incapable of performing various useful refactoring operations on it. IDEs that nonetheless offer some limited set of refactoring features on untyped languages are actually faking it; they should not be calling it refactoring, they should be calling it <em>Cunning Search and Replace</em>. Needless to say, it does not always work as intended, and it does sometimes severely mess up the code. (When this happens, it is called <em><a class=external href=https://www.catb.org/jargon/html/S/search-and-destroy-mode.html target=_blank>Search and Destroy</a>.</em>) Furthermore, since there is no compiler, you have no way of knowing that a line of code has been messed up until that line of code gets executed, which is something that may happen very rarely for some lines of code.</li></ol><h4 id=that-little-performance-issue>That little performance issue</h4><p>Performance is generally not an issue for scripting languages, because they tend to be used in situations where performance is not required.</p><p>(There are of course some situations where people opt to use a scripting language despite the fact that performance matters, and in those situations people do in fact suffer the consequences of poor performance, take web servers written in node.js for example.)</p><p>In today's world where the majority of personal computers are running on precious battery power, it can be argued that even the tiniest bit of performance matters, but we can let that one slide, since battery technology is constantly improving.</p><p>In cases where performance matters but the task at hand is well-defined and relatively isolated, performance is again not an issue for scripting languages because external libraries tend to be quickly developed to handle those tasks. (These external libraries are written in guess what: <em>real</em> programming languages.)</p><p>Having explained that performance is usually not an issue, let us also quickly mention before moving on that on computationally expensive tasks, such as iterating over all pixels of an image to manipulate each one of them, and assuming a competent programmer in each language, the following statements hold true:</p><ul><li>there is no way that a scripting language will perform as well as Java, just as:</li><li>there is no way that Java will perform as well as C++, just as:</li><li>there is no way that C++ will perform as well as Assembly.</li></ul><p>Stop arguing about this.</p><h4 id=the-horrendous-syntax>The horrendous syntax</h4><p>Most scripting languages suffer from a severe case of capriciously arcane and miserably grotesque syntax. No, beauty is not in the eye of the beholder, and there is only a certain extent up to which aesthetics are subjective.</p><p>The syntax of scripting languages tends to suffer due to various reasons, the most common being:</p><ul><li>Their priorities are all wrong to begin with.</li><li>They were hastily hacked together in a very short amount of time.</li><li>Plain incompetence on behalf of their creators.</li></ul><p>Scripting languages that have their priorities wrong are, for example, all the shell scripting languages. These languages aim to make strings (filenames) look and feel as if they are identifiers, so that you can type commands without having to enclose them in quotes, as if the convenience of not having to use quotes was the most important thing ever. If all we want to do in a shell script is to list a sequence of commands to execute, then this convenience is perhaps all we care for, but the moment we try to use any actual programming construct, like variables and flow control statements, what we have in our hands is a string-escaping nightmare of epic proportions.</p><p>Obligatory XKCD comic:</p><p><img src=/post/2017-05-on-scripting-languages/images/xkcd-backslash.png width=571 height=207 srcset="/post/2017-05-on-scripting-languages/images/xkcd-backslash_hu_a3b55ba8a827aa03.png 480w, /post/2017-05-on-scripting-languages/images/xkcd-backslash_hu_1eec207eb5351c55.png 1024w" loading=lazy alt=Backslashes class=gallery-image data-flex-grow=275 data-flex-basis=662px></p><p>(Source: "Backslashes" <a class=external href=https://www.xkcd.com/1638/ target=_blank>https://www.xkcd.com/1638/</a>)</p><p>This totally ill-conceived prioritization extends to other scripting languages that try to pull similar tricks, for example YAML, where:</p><ol><li>For the sake of convenience, tokens like <code>yes</code> and <code>no</code> are (case-insensitively) recognized as Boolean literals besides <code>true</code> and <code>false</code></li><li>Also for the sake of convenience, strings <em>do not have to</em> be enclosed in quotes
...which famously leads to the infamous <a class=external href=https://langdev.stackexchange.com/questions/1123/what-design-trade-offs-led-to-the-norway-problem-in-yaml-and-when-are-they-wo target=_blank>Norway Problem</a>, where the two-letter country code for Norway is interpreted as the Boolean value <code>false</code>.</li></ol><p>A scripting language that owes its bad syntax to being hastily hacked together is JavaScript. Brendan Eich, its creator, has admitted that JavaScript was developed within a couple of weeks, and that the language was not meant for anything but short isolated snippets of code. He is honest enough to speak of his own creation in derogatory terms, and to accept blame. (See <a class=external href="https://www.youtube.com/watch?v=zlcnOr81lPc" target=_blank>TEDxVienna 2016</a>, opening statement, "Hello, I am to blame for JavaScript".) Also, pretty much anyone deeply involved with JavaScript will admit that it has serious problems. One of the most highly acclaimed books on the language is <em>JavaScript: The Good Parts</em>, authored by Douglas Crockford and published by O'Reilly; you can take the title of the book as a hint.</p><p>A scripting language that owes its horrific syntax to lack of competence is PHP. Its creator, Rasmus Lerdorf, is quoted <a class=external href=https://en.wikipedia.org/wiki/PHP#Early_history target=_blank>on the Wikipedia article about PHP</a> as saying "I don't know how to stop it, there was never any intent to write a programming language {...} I have absolutely no idea how to write a programming language, I just kept adding the next logical step on the way."</p><p>So, from the above it should be obvious that most scripting languages are little toy projects that were created by individuals who simply wanted to prove that they could build something like that, without actually intending it to be used outside of their own workbench.</p><h4 id=the-cheapness>The cheapness</h4><p>The lack of semantic checking in scripting languages is usually not a deliberate design choice, but instead a consequence of the very limited effort that has gone into creating them. In many cases the creators of scripting languages would not know how to add semantic checking to the language even if they wanted to. In all cases, the amount of work required to add semantic checking would have been several orders of magnitude greater than the total amount of work that went into the creation of the language in the first place.</p><p>In this sense, the comparison between scripting languages and real programming languages is a lot like comparing children's tinker toy tools with tools for professionals: sure, a plastic screwdriver is inexpensive, lightweight and easy to use, but try screwing anything but plastic screws with it.</p><p>(I was going to also add "you cannot hurt yourself with it", but this analogy does not transfer to programming: you can very easily hurt yourself with a scripting language.)</p><h3 id=what-scripting-languages-are-good-for>What scripting languages are good for</h3><ul><li>Scripting languages used to be an easy way to write cross-platform software. This does not hold true anymore, since most major real programming languages are pretty much cross-platform nowadays.</li><li>Scripting languages are useful when embedded within applications, (applications written in <em>real</em> programming languages,) as evaluators of user-supplied expressions. (E.g. spreadsheet cell formulas.)</li><li>Scripting languages are useful when shortening the time from the moment you fire up the code editor to the moment you first run your program is more important than everything else. By "everything else" we really mean everything: understandability, maintainability, performance, even correctness.</li><li>Scripting languages are useful when the program to be written is so trivial, and its expected lifetime is so short, that it is hardly worth the effort of creating a new folder with a new project file in it. The corollary to this is that if it is worth creating a project for it, then it is worth using a real programming language.</li><li>Scripting languages are useful when the code to be written is so small and simple that bugs can be detected by simply skimming through the code. The corollary to this is that if the program is to be even slightly complex, it should be written in a real programming language. (Adding insult to injury, many scripting languages tend to have such a cryptic write-only syntax that it is very hard to grasp what any piece of code does, let alone skim through it and vouch for it being bug-free.)</li><li>The most important thing about scripting languages (and the main reason why they have become so wildly popular in recent years) is that they are useful in getting non-programmers into programming as quickly as possible.</li></ul><p>Most of us programmers have had a friend, who was not a programmer, and who one day asked us how to get into programming. The thought process should be familiar: you think about it for a moment, you start making a mental list of things they would need in order to get started with a real programming language, and you quickly change your mind and suggest that they try Python, because this answer stands some chance of fitting within our friend's attention span. However, the truth of the matter is that this recommendation will only save our friend from maybe a few hours of preparatory work, and it would be a crime if it condemns them to thousands of hours wasted over the course of a several year long career due to the use of an inferior programming language. This brings us to the following realization:</p><blockquote><p>Scripting languages are a lot like teething rings (pacifiers):</p><p>It is okay to start with one; you must get rid of it as soon as you grow some teeth.</p></blockquote><h3 id=conclusion>Conclusion</h3><p>The fact that some scripting languages catch on and spread like wildfire simply shows how eager the industry is to adopt any contemptible piece of nonsense without any critical thinking whatsoever, as long as it helps optimize some short-sighted concern, such as how to get non-programmers into programming as quickly as possible. It is a truly deplorable situation that kids nowadays learn JavaScript as their first programming language due to it being so accessible to them: all you need is a web browser, and one day instead of F11 for full-screen you accidentally hit F12 which opens up the developer tools, and you realize that you have an entire integrated development environment for JavaScript sitting right there, ready to use. The availability of JavaScript to small children is frightening.</p><p>Usually, once a language becomes extremely popular, tools are created to lessen the impact of its deficiencies. Thanks to the herculean efforts of teams that develop scripting engines, and through all kinds of sorcery being done under the hood in these engines, the most popular scripting languages are considerably faster today than they used to be. However, the sorcery is not always applicable, even when it is applicable it is imperfect, and besides, it incurs a penalty of its own, so scripting languages will never match the performance of real programming languages. Also, modern IDEs have evolved to provide some resemblance of semantic checking in some scripting languages, but since this checking has been added as an afterthought, it is always partial, unreliable, hacky, and generally an uphill battle.</p><p>So, you might ask, what about the hundreds of thousands of successful projects written in scripting languages? Are they all junk? And what about the hundreds of thousands of programmers all over the world who are making extensive use of scripting languages every day and are happy with them? Are they all misguided? Can't they see all these problems? Are they all ensnared in a monstrous collective delusion?</p><p>Yep, that's exactly it. You took the words from my mouth.</p><div class=table-wrapper><table><thead><tr><th style=text-align:center><img src=/post/2017-05-on-scripting-languages/images/grumpy-cat-scripting-languages.jpg width=600 height=400 srcset="/post/2017-05-on-scripting-languages/images/grumpy-cat-scripting-languages_hu_5be306c65a008b9c.jpg 480w, /post/2017-05-on-scripting-languages/images/grumpy-cat-scripting-languages_hu_8081d0eb266ea027.jpg 1024w" loading=lazy class=gallery-image data-flex-grow=150 data-flex-basis=360px></th></tr></thead><tbody><tr><td style=text-align:center>mandatory grumpy cat meme: "Scripting Languages - I Hate Them."</td></tr></tbody></table></div><p>Also read: <a href=/post/2018-01-tablecloth/>Tablecloth</a> (A high-tech, sci-fi horror short-story)</p><p>Note: This is a draft. It may contain inaccuracies or mistakes. There are bound to be corrections after I receive some feedback.</p><hr><p>Scratch</p><p>See:</p><p><a class=external href=http://stackoverflow.com/questions/397418/when-to-use-a-scripting-language target=_blank>http://stackoverflow.com/questions/397418/when-to-use-a-scripting-language</a></p><p>From <a class=external href=http://wiki.c2.com/?SeriousVersusScriptingLanguages target=_blank>http://wiki.c2.com/?SeriousVersusScriptingLanguages</a></p><p>Scripting Languages emphasize quickly writing one-off programs</p><p>Serious languages emphasize writing long-lived, maintainable, fast-running programs.</p><p>light-duty "gluing" of components and languages.</p><p>From <a class=external href=https://danluu.com/empirical-pl/ target=_blank>https://danluu.com/empirical-pl/</a></p><p>"I think programmers who doubt that type systems help are basically the tech equivalent of an anti-vaxxer"</p><p>The effect isn't quantifiable by a controlled experiment.</p><p>Misinformation people want to believe spreads faster than information people don't want to believe.</p><p><a class=external href=https://stackoverflow.blog/2023/01/19/adding-structure-to-dynamic-languages target=_blank>The Stack Overflow Blog: Minimizing the downsides of dynamic programming languages</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/software-engineering/>Software Engineering</a>
<a href=/tags/grumpy/>Grumpy</a>
<a href=/tags/papers/>Papers</a></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on 2025-10-23 Thu 01:04:50 CEST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/2023-01-14-mocking/><div class=article-details><h2 class=article-title>If you are using mock objects you are doing it wrong</h2></div></a></article><article><a href=/post/2022-12-messages-and-message-passing/><div class=article-details><h2 class=article-title>On messages and message-passing</h2></div></a></article><article><a href=/post/2022-12-master-branch-not-kosher/><div class=article-details><h2 class=article-title>So the "master" branch is not kosher anymore</h2></div></a></article><article><a href=/post/2017-06-on-uuids-and-guids/><div class=article-details><h2 class=article-title>What is wrong with UUIDs and GUIDs</h2></div></a></article><article><a href=/post/2025-09-refactoring/><div class=article-details><h2 class=article-title>Refactoring: strong vs weak</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy; 2001 - 2026 Michael Belivanakis (a.k.a. Mike Nakis)</section><section class=powerby>Made using <b><a href=https://obsidian.md target=_blank>Obsidian</a></b> and <b><a href=https://gohugo.io/ target=_blank>Hugo</a></b><br>Theme based on <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank data-version=%s>hugo-theme-stack</a></b> by <a href=https://jimmycai.com target=_blank>Jimmy Cai</a><br></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>