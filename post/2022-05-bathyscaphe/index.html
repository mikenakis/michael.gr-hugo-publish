<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="\rAbstract This article introduces Bathyscaphe, an open-source java library that you can use to assert that your objects are immutable and/or thread-safe.\nThe problem Programmers all over the world are embracing immutability more and more; however, mutation is still a thing, and in all likelihood will continue being a thing for as long as there will be programmers. In a world where both mutable and immutable objects exist side by side, there is often a need to ascertain that an object is of the immutable variety before proceeding to use it for certain purposes. For example, when an object is used as a key in a hash map, it better be immutable, or else the hash code of the key may change, causing the map to severely malfunction.\nFurthermore, even when an object is mutable, there is often the need to ascertain that it is at least thread-safe before sharing it between threads, otherwise there will be race conditions, with catastrophic results.\nNote that when any of the above goes wrong, it tends to be a bug which is very difficult to troubleshoot.\n"><title>Bathyscaphe</title><link rel=canonical href=https://blog.michael.gr/post/2022-05-bathyscaphe/><link rel=stylesheet href=/scss/style.min.32a512555d79ccc2867a9b2e645843323dfbe8892f99ff86e4dbb5b7316dbb25.css><meta property='og:title' content="Bathyscaphe"><meta property='og:description' content="\rAbstract This article introduces Bathyscaphe, an open-source java library that you can use to assert that your objects are immutable and/or thread-safe.\nThe problem Programmers all over the world are embracing immutability more and more; however, mutation is still a thing, and in all likelihood will continue being a thing for as long as there will be programmers. In a world where both mutable and immutable objects exist side by side, there is often a need to ascertain that an object is of the immutable variety before proceeding to use it for certain purposes. For example, when an object is used as a key in a hash map, it better be immutable, or else the hash code of the key may change, causing the map to severely malfunction.\nFurthermore, even when an object is mutable, there is often the need to ascertain that it is at least thread-safe before sharing it between threads, otherwise there will be race conditions, with catastrophic results.\nNote that when any of the above goes wrong, it tends to be a bug which is very difficult to troubleshoot.\n"><meta property='og:url' content='https://blog.michael.gr/post/2022-05-bathyscaphe/'><meta property='og:site_name' content="Michael's Blog"><meta property='og:type' content='article'><meta property='article:section' content='post'><meta property='article:tag' content='java'><meta property='article:tag' content='software-engineering'><meta property='article:tag' content='github-projects'><meta property='article:published_time' content='2022-04-19T10:54:08+00:00'><meta property='article:modified_time' content='2026-02-25T18:56:46+01:00'><meta name=twitter:title content="Bathyscaphe"><meta name=twitter:description content="\rAbstract This article introduces Bathyscaphe, an open-source java library that you can use to assert that your objects are immutable and/or thread-safe.\nThe problem Programmers all over the world are embracing immutability more and more; however, mutation is still a thing, and in all likelihood will continue being a thing for as long as there will be programmers. In a world where both mutable and immutable objects exist side by side, there is often a need to ascertain that an object is of the immutable variety before proceeding to use it for certain purposes. For example, when an object is used as a key in a hash map, it better be immutable, or else the hash code of the key may change, causing the map to severely malfunction.\nFurthermore, even when an object is mutable, there is often the need to ascertain that it is at least thread-safe before sharing it between threads, otherwise there will be race conditions, with catastrophic results.\nNote that when any of the above goes wrong, it tends to be a bug which is very difficult to troubleshoot.\n"><link rel="shortcut icon" href=/favicon.svg><script async src="https://www.googletagmanager.com/gtag/js?id=TODO"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","TODO")}</script></head><body class="article-page
article-page"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><ol class=menu id=main-menu><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol><a href=/><img src=/logo.svg width=210 loading=lazy alt=Logo></a><figure class=site-avatar><a href=/><img src="https://gravatar.com/avatar/8d1c5b5578843f958430afe30e0cbb2fb5092b1712d1933ea37d7bf5cb4305ed?size=400" width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure></header><ul class=menu-social><li><a href=/contact-via-e-mail/ title=e-Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z"/><path d="M3 7l9 6 9-6"/></svg></a></li><li><a href=/contact-via-whatsapp/ title=WhatsApp rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 21l1.65-3.8a9 9 0 113.4 2.9L3 21"/><path d="M9 10a.5.5.0 001 0V9A.5.5.0 009 9v1a5 5 0 005 5h1a.5.5.0 000-1h-1a.5.5.0 000 1"/></svg></a></li><li><a href=https://github.com/mikenakis target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/mikenakis target=_blank title=LinkedIn rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 11v5"/><path d="M8 8v.01"/><path d="M12 16v-5"/><path d="M16 16v-3a2 2 0 10-4 0"/><path d="M3 7a4 4 0 014-4h10a4 4 0 014 4v10a4 4 0 01-4 4H7a4 4 0 01-4-4z"/></svg></a></li><li><a href=https://stackoverflow.com/users/773113/mike-nakis target=_blank title="Stack Overflow" rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 17v1a2 2 0 002 2h12a2 2 0 002-2v-1"/><path d="M8 16h8"/><path d="M8.322 12.582l7.956.836"/><path d="M8.787 9.168l7.826 1.664"/><path d="M10.096 5.764l7.608 2.472"/></svg></a></li><li><a href=https://twitter.com/mikenakis target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ul><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/portfolio/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Portfolio</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#appendix-a-note-on-reference-types>Appendix: A note on reference types</a></li><li><a href=#appendix-a-note-on-so-called-immutable-collections>Appendix: A note on so-called immutable collections</a></li><li><a href=#appendix-a-note-on-assessment-overrides>Appendix: A note on assessment overrides</a></li><li><a href=#appendix-freezable-classes>Appendix: Freezable classes</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/post/2022-05-bathyscaphe/>Bathyscaphe</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2022-04-19 Tue 10:54:08 UTC</time></div><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
<time class=article-time--reading>14 minute read</time></div></footer></div></header><section class=article-content><p><img src=/post/2022-05-bathyscaphe/media/bathyscaphe-logo.svg loading=lazy alt="Bathyscaphe logo"></p><h2 id=abstract>Abstract</h2><p>This article introduces Bathyscaphe, an open-source java library that you can use to assert that your objects are immutable and/or thread-safe.</p><h2 id=the-problem>The problem</h2><p>Programmers all over the world are embracing immutability more and more; however, mutation is still a thing, and in all likelihood will continue being a thing for as long as there will be programmers. In a world where both mutable and immutable objects exist side by side, there is often a need to ascertain that an object is of the immutable variety before proceeding to use it for certain purposes. For example, when an object is used as a key in a hash map, it better be immutable, or else the hash code of the key may change, causing the map to severely malfunction.</p><p>Furthermore, even when an object is mutable, there is often the need to ascertain that it is at least thread-safe before sharing it between threads, otherwise there will be race conditions, with catastrophic results.</p><p>Note that when any of the above goes wrong, it tends to be a bug which is very difficult to troubleshoot.</p><p>Unfortunately, assessment of thread safety and immutability is not an easy task. Most don't even consider it, few talk about it, even fewer attempt it. Programmers all over the world are accustomed to routinely using objects in situations where thread-safety and/or immutability are absolute requirements, but without ever ascertaining them, essentially <em>praying</em> that the objects be thread-safe and/or immutable.</p><p>As far as I can tell, in the world of the JVM there exist no libraries that will ascertain thread-safety. As for immutability, there are some that purport to do so, but Judging by how marginal status these libraries have in the greater technology landscape, they are not being put into much use. This is not surprising, because they rely exclusively on static analysis, which does not really solve the problem, as I will show.</p><h2 id=introducing-bathyscaphe>Introducing Bathyscaphe</h2><p>Bathyscaphe aims to give the Java world another chance at addressing the problem of thread-safety and immutability assessment instead of letting it linger on like a chronic ailment. Bathyscaphe is really easy to use, and produces correct and useful results. It is also very small:</p><ul><li>The JAR file is only about 100 kilobytes.</li><li>Setting aside the test module, which necessarily depends on JUnit, Bathyscaphe does not have any dependencies outside the Java Runtime Environment. Let me repeat this: Bathyscaphe. Has. No. Dependencies. It depends on nothing. When you include Bathyscaphe in a project, you are including its tiny JAR file and nothing else.</li></ul><h2 id=why-existing-solutions-do-not-work>Why existing solutions do not work</h2><p>Oftentimes we can tell whether an object is mutable or immutable just by looking at its class, and indeed there exist static analysis tools that examine classes and classify them as either mutable or immutable. The widespread understanding is that once a class has been classified, all instances of that class can receive the same classification. However, in many cases it is not enough to just look at the class to determine immutability; instead, it is necessary to examine each and every instance of the class at runtime. When static analysis tools assess such classes, they yield results that are erroneous, or in the best case useless.</p><p>Examples where static analysis <em><strong>does not</strong></em> work and <strong>cannot</strong> work:</p><ul><li>Static analysis does not work when a class contains a field which is final, receives its value from a constructor parameter, and the type of the field is an interface or a non-final class. Static analysis can determine that the field itself will not mutate, but has no way of knowing whether the value referenced by the field can mutate.<ul><li>In order to err on the safe side, static analysis tools tend to assess classes containing such fields as mutable, but this is arbitrary, and it constitutes a false negative when the field is in fact initialized with an immutable value.</li></ul></li><li>Static analysis does not work when a class is an unmodifiable collection of elements, where the elements can be of any type. The most famous examples in this category are the JDK-internal classes <code>java.util.ListN</code> and <code>java.util.List12</code>, instances of which are returned by <code>java.util.List.of()</code> and its overloads.<ul><li>Some static analysis tools assess such classes as immutable, which can be a false positive, e.g. in the case of <code>List.of( new StringBuilder() )</code>.</li><li>Some static analysis tools assess such classes as mutable, which can be a false negative, e.g. in the case of <code>List.of( 1 )</code>.</li></ul></li><li>Static analysis does not work when a class is <em><strong>freezable</strong></em>. By this we mean a class whose instances begin life as mutable, and are at some point instructed to transition from being mutable to being immutable. For an explanation as to why freezable classes are important, see related appendix.</li></ul><p>From the above it follows that in many cases, examining a class is not enough; in these cases, we need to examine each and every instance of the class at runtime. Furthermore, we need to examine not only the instance at hand, but the entire object graph referenced by that instance. In other words, we must not just assess shallow (superficial) immutability, we must assess deep immutability. That's what Bathyscaphe does. And that's why it is called Bathyscaphe.</p><h2 id=how-bathyscaphe-works>How Bathyscaphe Works</h2><p>In a nutshell, Bathyscaphe uses reflection to examine each field of a class, and recursively the type of each field. If all fields of a class can be conclusively assessed as immutable, then all instances of that class will be assessed as immutable. However, if the actual type of the runtime value of a certain field cannot be known by a static examination of the class, then for each instance of the class at runtime, Bathyscaphe will read the value of the field, obtain the actual type of the value, and recursively assess the type of that value.</p><p>In most cases Bathyscaphe can determine by itself whether a field is immutable or not; however, in some cases, things are not what they seem to be. For example, lazily initialized fields look mutable, but they are effectively immutable. Bathyscaphe does not attempt to analyze bytecode and detect how a certain field is used; that kind of detective work belongs to the realm of static analysis tools. In such cases, it is necessary to guide Bathyscaphe by using annotations to mark fields that might look mutable but should be considered as immutable.</p><p>These annotations are essentially claims made by the programmer: Bathyscaphe does not, and cannot, verify the truthfulness of these claims. In this sense, Bathyscaphe does not provide a 100% fool-proof solution, because the programmer may code these annotations wrongly. In the future some synergy between Bathyscaphe and static analysis tools might be achieved, so as to provide 100% fool-proof results, but the benefit of using Bathyscaphe <em><strong>now</strong></em> lies in the fact that given correct annotations, Bathyscaphe will yield correct and usable results in all cases, whereas static analysis <em>does not</em> work in all cases and by its nature <em>cannot</em> work in all cases.</p><h2 id=where-to-find-bathyscaphe>Where to find Bathyscaphe</h2><p>Bathyscaphe is hosted on GitHub; see <a class=external href=https://github.com/mikenakis/Bathyscaphe target=_blank>https://github.com/mikenakis/Bathyscaphe</a></p><hr><h2 id=appendix-goals-of-bathyscaphe>Appendix: Goals of Bathyscaphe</h2><p>I decided to write my own immutability assessment facility with the following goals in mind:</p><ul><li>I want to be able to write framework-level code such as the following:<ul><li>A hash-map which asserts that any and all keys added to it are immutable.</li><li>A message-passing framework which asserts that every single message that it is asked to deliver is either immutable or at the very least thread-safe.</li></ul></li><li>I want results that are always accurate, meaning that there must be no false positives or false negatives, no compromises, no "aiming to cover the majority of use cases". All use cases should be covered, and they should be covered correctly.</li><li>I want to assess the immutability of objects, not classes, because I have observed that from a certain class we can sometimes construct instances that are mutable, and sometimes construct instances that are immutable. For example, both of the following method calls yield instances of the exact same class, and yet one instance is mutable, while the other instance is immutable:<ul><li><code>List.of( 1 )</code> (immutable)</li><li><code>List.of( new StringBuilder() )</code> (mutable)</li></ul></li><li>I want to assess the immutability of the entire graph of objects referenced by a certain object, not the immutability of that object alone. In other words, I want deep immutability assessment, as opposed to shallow or superficial immutability assessment.</li><li>When assessment cannot be achieved in an entirely automatic fashion, (as the case is, for example, with classes that perform lazy initialization,) I want to be able to achieve it by either:<ul><li>adding special annotations to certain fields, or</li><li>adding a manual preassessment (assessment override) for that specific class.</li></ul></li><li>I want the immutability assessment facility to account for freezable classes. This necessitates the introduction of a special self-assessment interface, so that instances can be asked whether they are immutable or not.</li><li>When an immutability assertion fails, meaning that an object which I had intended to be immutable has been found to actually be mutable, I want to receive extensive diagnostics in human-readable form, explaining precisely why this happened.</li><li>I want the immutability assessment library which achieves all this to be attractive to programmers, by being:<ul><li>very easy to integrate</li><li>very easy to use</li><li>very small</li><li>having no dependencies.</li></ul></li></ul><h2 id=appendix-non-goals-of-bathyscaphe>Appendix: Non-goals of Bathyscaphe</h2><ul><li>Predicting what code will do.<ul><li>That is the job of static analysis tools. Bathyscaphe is meant to issue accurate and useful assessments assuming correctly annotated classes. The correctness of the annotations is a lesser, and largely different problem, which is suitable as the focus of static analysis tools.</li></ul></li><li>Dealing with untrustworthy classes.<ul><li>Immutability can always be compromised via reflection, so trying to assess immutability in an environment which is not completely trustworthy is a hopeless endeavor.</li><li>Therefore, assessment is to be done on a full-trust basis.</li></ul></li><li>Dealing with buggy classes.<ul><li>If a class promises, either by means of annotations or the self-assessment interface, that it will behave immutably, but in fact it does not, the fault is with that class, not with the immutability assessment facility.</li></ul></li><li>Dealing with inaccessible classes.<ul><li>Due to security restrictions, the inner workings of certain JDK classes are inaccessible.</li><li>Since every single one of those classes can receive a manual preassessment, this is not an issue.</li></ul></li><li>Dealing with farce.<ul><li>If we create a subclass of a mutable class and override each mutation method to always throw an exception, do we have a mutable or immutable class in our hands?</li><li>Some say it is mutable;</li><li>others say it is immutable;</li><li>I say it is a farce, and not worth considering.</li></ul></li><li>Performance.<ul><li>Immutability assessment can be computationally expensive, but it is only meant to be performed through assertions, so its overhead is to be suffered only on development runs.</li><li>On production runs, where assertions are supposed to be disabled, the performance penalty of using Bathyscaphe is to be zero.</li><li>Therefore, performance is not an issue.</li></ul></li><li>Non-assertive assessment.<ul><li>Non-assertive assessment means yielding an assessment result object which can then be further examined, as opposed to assertive assessment which means either passing the immutability check or throwing an exception.</li><li>Non-assertive assessment would require publicly exposing the entire assessment hierarchy of Bathyscaphe. One that is done, people would inevitably start writing code that makes use of it, and from that moment on it would be impossible for me to continue refactoring and evolving Bathyscaphe without breaking all that code.</li><li>Therefore, non-assertive assessment is not a goal.</li></ul></li><li>Static analysis.<ul><li>While it is indeed possible in many cases to conclusively assess a class as mutable or immutable by just looking at the class, in many other cases (and certainly in all <em>interesting</em> cases) examining the class is not enough, as the example of <code>List.of( 1 )</code> vs. <code>List.of( new StringBuilder())</code> demonstrates.</li><li>Thus, the use of Bathyscaphe as a static analysis tool is not a goal.</li><li>If you need a static immutability analysis tool for Java, please see <code>MutabilityDetector</code> on GitHub: <a class=external href=https://github.com/MutabilityDetector target=_blank>https://github.com/MutabilityDetector</a></li></ul></li></ul><h3 id=appendix-a-note-on-reference-types>Appendix: A note on reference types</h3><p>If you decide to incorporate Bathyscaphe in a project, the first thing you are likely to do is what I did: introduce your own HashMap class which asserts that every key added to it is immutable. In doing so you might discover some bugs in your code, but you will also notice something seemingly strange: Bathyscaphe is preventing you from using reference types as keys, which kind of makes sense because they are in fact mutable, but you have never had any issues with that before, so why is it becoming a problem now?</p><p>What is happening is that your reference types refrain from overriding <code>equals()</code> and <code>hashCode()</code>, so they inherit the reference-equals function and the identity hash-code function from <code>Object</code>. A reference to an object remains the same regardless of mutations that the object undergoes during its lifetime, and the same holds true for its identity hash-code. This has been allowing you to use reference types as keys in in hash maps, despite the fact that they undergo mutations, but it has only been working by coincidence.</p><p>Another word for "coincidence" is "accident", and Bathyscaphe is meant to be used precisely in order to avoid accidents, so you cannot keep doing this anymore. From now on, you will have to be using <code>IdentityHashMap</code> for reference types, and <code>HashMap</code> for value types.</p><h3 id=appendix-a-note-on-so-called-immutable-collections>Appendix: A note on so-called immutable collections</h3><p>When Java 9 introduced the new <code>java.util.List.of()</code> method and its various overloads, the documentation referred to the objects returned by that method as immutable lists. Specifically, in the Java 9 API docs we read "Returns an <em><strong>immutable</strong></em> list containing one element." Later, the Java people realized that this is inaccurate, so in JDK issue 8191517 they decided among other things to "Adjust terminology to prefer 'unmodifiable' over 'immutable'." Thus, if we look at the documentation today, (for example, in the Java 18 API documentation,) it reads "Returns an <em><strong>unmodifiable</strong></em> list containing one element."</p><ul><li>Java 9 API docs: <a class=external href=https://docs.oracle.com/javase/9/docs/api/java/util/List.html target=_blank>https://docs.oracle.com/javase/9/docs/api/java/util/List.html</a></li><li>JDK issue 8191517: <a class=external href=https://bugs.openjdk.java.net/browse/JDK-8191517 target=_blank>https://bugs.openjdk.java.net/browse/JDK-8191517</a></li><li>Java 18 API docs: <a class=external href=https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/List.html target=_blank>https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/List.html</a></li></ul><p>Dropping the word "immutable" was the right thing to do, because there is no such thing as an immutable collection, at least when type erasure is involved. That's because a collection contains elements, the immutability of which it is in no position to vouch for.</p><p>Unfortunately, the term "unmodifiable" is also problematic for describing these collections, because that term already had a meaning before <code>List.of()</code> was introduced, and the meaning was "an unmodifiable-<em><strong>to-you</strong></em> view of <strong>my</strong> collection, which is still <em><strong>very mutable</strong></em>, and any mutations I make <em><strong>will be visible to you</strong></em>."</p><p>Luckily, <code>List.of()</code> does better than that: it returns a list that cannot be modified by anyone. So, I would rather call it "unchangeable" or "superficially immutable" to indicate that it falls short of achieving true immutability only in the sense that it cannot guarantee deep immutability.</p><h3 id=appendix-a-note-on-assessment-overrides>Appendix: A note on assessment overrides</h3><p>An assessment override on an effectively immutable class (for example, on a class which contains a lazily initialized field) is a drastic measure which should be used as seldom as possible. That's because an assessment override is also a blanket measure: it will prevent the immutability assessment facility from ascertaining the immutability of not only the lazily initialized field, but also of all other fields in the class, and in so doing it may hide errors. Assessment overrides should only be used on classes whose source code we do not control, and therefore we cannot annotate on a field-per-field basis.</p><h3 id=appendix-freezable-classes>Appendix: Freezable classes</h3><p>As a rule, immutable objects tend to be immutable-upon-construction, meaning that any and all objects that they reference must be supplied as constructor parameters. There is, however, an exception: there is a category of objects called "freezable" which begin their life as mutable, (so that they can undergo complex initialization,) and are at some later moment instructed to transition to being immutable, that is, to "freeze".</p><p>Freezing happens in-place, it is permanent from the moment it is applied, and it is trivial to implement: all it takes is to set a <code>frozen</code> field to <code>true</code>. (A few more things are nice to have, for example assertions ensuring that no mutation methods are invoked once frozen, and splitting the interface of the object in two separate interfaces for mutable and immutable functionality respectively, so that once the object has been frozen, we can forget our reference to the mutable interface and only retain the immutable one.)</p><ul><li>Freezing is useful for performance:<ul><li>Creating a mutable object, initializing it, and then freezing it performs much better than creating a mutable object, initializing it, and then copying its contents into a freshly allocated immutable object.</li></ul></li><li>Freezing can achieve things that are otherwise hard, or impossible:<ul><li>The creation of immutable cyclic graphs requires objects to be mutable while the graph is being constructed, and to become immutable in-place once construction is complete. This problem cannot be solved using the builder pattern, because the builder is bound to run into the same problem: how to construct A with a reference to B when B must be constructed with a reference to A.</li></ul></li></ul><p>To accommodate freezable classes, Bathyscaphe introduces the <code>ImmutabilitySelfAssessable</code> interface. If a class implements this interface, then Bathyscaphe will be invoking instances of this class to ask them whether they are immutable or not.</p><hr><p>Cover image: the Bathyscaphe logo, a line drawing of <em><strong>bathyscaphe Trieste</strong></em> by michael.gr, based on art found at <a class=external href=https://bertrandpiccard.com/3-generations/jacques-piccard target=_blank>bertrandpiccard.com</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/java/>Java</a>
<a href=/tags/software-engineering/>Software Engineering</a>
<a href=/tags/github-projects/>GitHub projects</a></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on 2026-02-25 Wed 18:56:46 CET</span></section></footer></article><script>var idcomments_post_id,idcomments_post_url,idcomments_acct="131c02e0ef20d1a4606aa4e3490711ba"</script><span id=IDCommentsPostTitle style=display:none></span>
<script type=text/javascript src=https://www.intensedebate.com/js/genericCommentWrapperV2.js></script><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/2024-10-testana/><div class=article-details><h2 class=article-title>Testana: A better way of running tests</h2></div></a></article><article><a href=/post/2022-12-intertwine/><div class=article-details><h2 class=article-title>Intertwine</h2></div></a></article><article><a href=/post/2018-04-github-project-classdump/><div class=article-details><h2 class=article-title>GitHub project: mikenakis-classdump</h2></div></a></article><article><a href=/post/2025-06-immutability-assessment/><div class=article-details><h2 class=article-title>Immutability Assessment</h2></div></a></article><article><a href=/post/2023-07-06-solved-maven-deploy-fails-with-status/><div class=article-details><h2 class=article-title>[SOLVED] Maven deploy fails with status 422 unprocessable entity</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy; 2001 - 2026 Michael Belivanakis (a.k.a. Mike Nakis)</section><section class=powerby>Made using <b><a href=https://obsidian.md target=_blank>Obsidian</a></b> and <b><a href=https://gohugo.io/ target=_blank>Hugo</a></b><br>Theme based on <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank data-version=%s>hugo-theme-stack</a></b> by <a href=https://jimmycai.com target=_blank>Jimmy Cai</a><br></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>