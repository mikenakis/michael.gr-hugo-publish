<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="I have this answer on programmers.stackexchange.com which, at the time of writing these words, has 5 upvotes and 10 downvotes, and in all likelihood it will continue collecting downvotes, while I adamantly refuse to remove it, standing 100% by my ideas. I am dumbfounded, as such a thing has never happened before.\nHere is the programmers.stackexchange.com question:\nIs it okay to have objects that cast themselves, even if it pollutes the API of their subclasses? I have a base class, Base. It has two subclasses, Sub1 and Sub2. Each subclass has some additional methods. For example, Sub1 has Sandwich makeASandwich(Ingredients... ingredients), and Sub2 has boolean contactAliens(Frequency onFrequency).\nSince these methods take different parameters and do entirely different things, they're completely incompatible, and I can't just use polymorphism to solve this problem.\nBase provides most of the functionality, and I have a large collection of Base objects. However, all Base objects are either a Sub1 or a Sub2, and sometimes I need to know which they are.\nIt seems like a bad idea to do the following:\nfor (Base base : bases) { if (base instanceof Sub1) { ((Sub1) base).makeASandwich(getRandomIngredients()); // ... etc. } else { // must be Sub2 ((Sub2) base).contactAliens(getFrequency()); // ... etc. } } So I came up with a strategy to avoid this without casting. Base now has these methods:\nboolean isSub1(); Sub1 asSub1(); Sub2 asSub2(); And of course, Sub1 implements these methods as\nboolean isSub1() { return true; } Sub1 asSub1(); { return this; } Sub2 asSub2(); { throw new IllegalStateException(); } And Sub2 implements them in the opposite way.\nUnfortunately, now Sub1 and Sub2 have these methods in their own API. So I can do this, for example, on Sub1.\n/** no need to use this if object is known to be Sub1 */ @Deprecated boolean isSub1() { return true; } /** no need to use this if object is known to be Sub1 */ @Deprecated Sub1 asSub1(); { return this; } /** no need to use this if object is known to be Sub1 */ @Deprecated Sub2 asSub2(); { throw new IllegalStateException(); } This way, if the object is known to be only a Base, these methods are un-deprecated, and can be used to &#34;cast&#34; itself to a different type so I can invoke the subclass's methods on it. This seems elegant to me in a way, but on the other hand, I'm kind of abusing Deprecated annotations as a way to &#34;remove&#34; methods from a class.\nSince a Sub1 instance really is a Base, it does make sense to use inheritance rather than encapsulation. Is what I'm doing good? Is there a better way to solve this problem?\nTags: java, inheritance, type-casting\nasked by codebreaker\n"><title>Wow, 5 upvotes, 10 downvotes and counting</title><link rel=canonical href=https://blog.michael.gr/post/2015-04-wow-2-upvotes-6-downvotes-and-counting/><link rel=stylesheet href=/scss/style.min.c8bc6f29d8ac77f9cc695841b030648188c81c127c10562de5f0fb3e6549d2a4.css><meta property='og:title' content="Wow, 5 upvotes, 10 downvotes and counting"><meta property='og:description' content="I have this answer on programmers.stackexchange.com which, at the time of writing these words, has 5 upvotes and 10 downvotes, and in all likelihood it will continue collecting downvotes, while I adamantly refuse to remove it, standing 100% by my ideas. I am dumbfounded, as such a thing has never happened before.\nHere is the programmers.stackexchange.com question:\nIs it okay to have objects that cast themselves, even if it pollutes the API of their subclasses? I have a base class, Base. It has two subclasses, Sub1 and Sub2. Each subclass has some additional methods. For example, Sub1 has Sandwich makeASandwich(Ingredients... ingredients), and Sub2 has boolean contactAliens(Frequency onFrequency).\nSince these methods take different parameters and do entirely different things, they're completely incompatible, and I can't just use polymorphism to solve this problem.\nBase provides most of the functionality, and I have a large collection of Base objects. However, all Base objects are either a Sub1 or a Sub2, and sometimes I need to know which they are.\nIt seems like a bad idea to do the following:\nfor (Base base : bases) { if (base instanceof Sub1) { ((Sub1) base).makeASandwich(getRandomIngredients()); // ... etc. } else { // must be Sub2 ((Sub2) base).contactAliens(getFrequency()); // ... etc. } } So I came up with a strategy to avoid this without casting. Base now has these methods:\nboolean isSub1(); Sub1 asSub1(); Sub2 asSub2(); And of course, Sub1 implements these methods as\nboolean isSub1() { return true; } Sub1 asSub1(); { return this; } Sub2 asSub2(); { throw new IllegalStateException(); } And Sub2 implements them in the opposite way.\nUnfortunately, now Sub1 and Sub2 have these methods in their own API. So I can do this, for example, on Sub1.\n/** no need to use this if object is known to be Sub1 */ @Deprecated boolean isSub1() { return true; } /** no need to use this if object is known to be Sub1 */ @Deprecated Sub1 asSub1(); { return this; } /** no need to use this if object is known to be Sub1 */ @Deprecated Sub2 asSub2(); { throw new IllegalStateException(); } This way, if the object is known to be only a Base, these methods are un-deprecated, and can be used to &#34;cast&#34; itself to a different type so I can invoke the subclass's methods on it. This seems elegant to me in a way, but on the other hand, I'm kind of abusing Deprecated annotations as a way to &#34;remove&#34; methods from a class.\nSince a Sub1 instance really is a Base, it does make sense to use inheritance rather than encapsulation. Is what I'm doing good? Is there a better way to solve this problem?\nTags: java, inheritance, type-casting\nasked by codebreaker\n"><meta property='og:url' content='https://blog.michael.gr/post/2015-04-wow-2-upvotes-6-downvotes-and-counting/'><meta property='og:site_name' content="Michael's Blog"><meta property='og:type' content='article'><meta property='article:section' content='post'><meta property='article:tag' content='software-engineering'><meta property='article:published_time' content='2015-04-30T08:47:49+00:00'><meta property='article:modified_time' content='2026-01-21T11:16:39+01:00'><meta name=twitter:title content="Wow, 5 upvotes, 10 downvotes and counting"><meta name=twitter:description content="I have this answer on programmers.stackexchange.com which, at the time of writing these words, has 5 upvotes and 10 downvotes, and in all likelihood it will continue collecting downvotes, while I adamantly refuse to remove it, standing 100% by my ideas. I am dumbfounded, as such a thing has never happened before.\nHere is the programmers.stackexchange.com question:\nIs it okay to have objects that cast themselves, even if it pollutes the API of their subclasses? I have a base class, Base. It has two subclasses, Sub1 and Sub2. Each subclass has some additional methods. For example, Sub1 has Sandwich makeASandwich(Ingredients... ingredients), and Sub2 has boolean contactAliens(Frequency onFrequency).\nSince these methods take different parameters and do entirely different things, they're completely incompatible, and I can't just use polymorphism to solve this problem.\nBase provides most of the functionality, and I have a large collection of Base objects. However, all Base objects are either a Sub1 or a Sub2, and sometimes I need to know which they are.\nIt seems like a bad idea to do the following:\nfor (Base base : bases) { if (base instanceof Sub1) { ((Sub1) base).makeASandwich(getRandomIngredients()); // ... etc. } else { // must be Sub2 ((Sub2) base).contactAliens(getFrequency()); // ... etc. } } So I came up with a strategy to avoid this without casting. Base now has these methods:\nboolean isSub1(); Sub1 asSub1(); Sub2 asSub2(); And of course, Sub1 implements these methods as\nboolean isSub1() { return true; } Sub1 asSub1(); { return this; } Sub2 asSub2(); { throw new IllegalStateException(); } And Sub2 implements them in the opposite way.\nUnfortunately, now Sub1 and Sub2 have these methods in their own API. So I can do this, for example, on Sub1.\n/** no need to use this if object is known to be Sub1 */ @Deprecated boolean isSub1() { return true; } /** no need to use this if object is known to be Sub1 */ @Deprecated Sub1 asSub1(); { return this; } /** no need to use this if object is known to be Sub1 */ @Deprecated Sub2 asSub2(); { throw new IllegalStateException(); } This way, if the object is known to be only a Base, these methods are un-deprecated, and can be used to &#34;cast&#34; itself to a different type so I can invoke the subclass's methods on it. This seems elegant to me in a way, but on the other hand, I'm kind of abusing Deprecated annotations as a way to &#34;remove&#34; methods from a class.\nSince a Sub1 instance really is a Base, it does make sense to use inheritance rather than encapsulation. Is what I'm doing good? Is there a better way to solve this problem?\nTags: java, inheritance, type-casting\nasked by codebreaker\n"><link rel="shortcut icon" href=/favicon.svg><script async src="https://www.googletagmanager.com/gtag/js?id=TODO"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","TODO")}</script></head><body class="article-page
article-page"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><ol class=menu id=main-menu><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol><a href=/><img src=/logo.svg width=210 loading=lazy alt=Logo></a><figure class=site-avatar><a href=/><img src="https://gravatar.com/avatar/8d1c5b5578843f958430afe30e0cbb2fb5092b1712d1933ea37d7bf5cb4305ed?size=400" width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure></header><ul class=menu-social><li><a href=/contact-via-e-mail/ title=e-Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z"/><path d="M3 7l9 6 9-6"/></svg></a></li><li><a href=/contact-via-whatsapp/ title=WhatsApp rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 21l1.65-3.8a9 9 0 113.4 2.9L3 21"/><path d="M9 10a.5.5.0 001 0V9A.5.5.0 009 9v1a5 5 0 005 5h1a.5.5.0 000-1h-1a.5.5.0 000 1"/></svg></a></li><li><a href=https://github.com/mikenakis target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/mikenakis target=_blank title=LinkedIn rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 11v5"/><path d="M8 8v.01"/><path d="M12 16v-5"/><path d="M16 16v-3a2 2 0 10-4 0"/><path d="M3 7a4 4 0 014-4h10a4 4 0 014 4v10a4 4 0 01-4 4H7a4 4 0 01-4-4z"/></svg></a></li><li><a href=https://stackoverflow.com/users/773113/mike-nakis target=_blank title="Stack Overflow" rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 17v1a2 2 0 002 2h12a2 2 0 002-2v-1"/><path d="M8 16h8"/><path d="M8.322 12.582l7.956.836"/><path d="M8.787 9.168l7.826 1.664"/><path d="M10.096 5.764l7.608 2.472"/></svg></a></li><li><a href=https://twitter.com/mikenakis target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ul><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#is-it-okay-to-have-objects-that-cast-themselves-even-if-it-pollutes-the-api-of-their-subclasses>Is it okay to have objects that cast themselves, even if it pollutes the API of their subclasses?</a></li><li><a href=#gee-thanks-for-the-downvotes>Gee, thanks for the downvotes!</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/post/2015-04-wow-2-upvotes-6-downvotes-and-counting/>Wow, 5 upvotes, 10 downvotes and counting</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2015-04-30 Thu 08:47:49 UTC</time></div><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
<time class=article-time--reading>8 minute read</time></div></footer></div></header><section class=article-content><p>I have this answer on programmers.stackexchange.com which, at the time of writing these words, has 5 upvotes and 10 downvotes, and in all likelihood it will continue collecting downvotes, while I adamantly refuse to remove it, standing 100% by my ideas. I am dumbfounded, as such a thing has never happened before.</p><p>Here is <a class=external href=https://programmers.stackexchange.com/a/280522/41811 target=_blank>the programmers.stackexchange.com question</a>:</p><blockquote><h3 id=is-it-okay-to-have-objects-that-cast-themselves-even-if-it-pollutes-the-api-of-their-subclasses>Is it okay to have objects that cast themselves, even if it pollutes the API of their subclasses?</h3><p>I have a base class, <code>Base</code>. It has two subclasses, <code>Sub1</code> and <code>Sub2</code>. Each subclass has some additional methods. For example, <code>Sub1</code> has <code>Sandwich makeASandwich(Ingredients... ingredients)</code>, and <code>Sub2</code> has <code>boolean contactAliens(Frequency onFrequency)</code>.</p><p>Since these methods take different parameters and do entirely different things, they're completely incompatible, and I can't just use polymorphism to solve this problem.</p><p><code>Base</code> provides most of the functionality, and I have a large collection of <code>Base</code> objects. However, all <code>Base</code> objects are either a <code>Sub1</code> or a <code>Sub2</code>, and sometimes I need to know which they are.</p><p>It seems like a bad idea to do the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Base</span><span class=w> </span><span class=n>base</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>bases</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>base</span><span class=w> </span><span class=k>instanceof</span><span class=w> </span><span class=n>Sub1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>((</span><span class=n>Sub1</span><span class=p>)</span><span class=w> </span><span class=n>base</span><span class=p>).</span><span class=na>makeASandwich</span><span class=p>(</span><span class=n>getRandomIngredients</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ... etc.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// must be Sub2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>((</span><span class=n>Sub2</span><span class=p>)</span><span class=w> </span><span class=n>base</span><span class=p>).</span><span class=na>contactAliens</span><span class=p>(</span><span class=n>getFrequency</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ... etc.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>So I came up with a strategy to avoid this without casting. <code>Base</code> now has these methods:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kt>boolean</span><span class=w> </span><span class=nf>isSub1</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Sub1</span><span class=w> </span><span class=nf>asSub1</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Sub2</span><span class=w> </span><span class=nf>asSub2</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>And of course, <code>Sub1</code> implements these methods as</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kt>boolean</span><span class=w> </span><span class=nf>isSub1</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Sub1</span><span class=w> </span><span class=nf>asSub1</span><span class=p>();</span><span class=w>   </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Sub2</span><span class=w> </span><span class=nf>asSub2</span><span class=p>();</span><span class=w>   </span><span class=p>{</span><span class=w> </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>IllegalStateException</span><span class=p>();</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>And <code>Sub2</code> implements them in the opposite way.</p><p>Unfortunately, now <code>Sub1</code> and <code>Sub2</code> have these methods in their own API. So I can do this, for example, on <code>Sub1</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=cm>/** no need to use this if object is known to be Sub1 */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Deprecated</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>boolean</span><span class=w> </span><span class=nf>isSub1</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/** no need to use this if object is known to be Sub1 */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Deprecated</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Sub1</span><span class=w> </span><span class=nf>asSub1</span><span class=p>();</span><span class=w>   </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/** no need to use this if object is known to be Sub1 */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Deprecated</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Sub2</span><span class=w> </span><span class=nf>asSub2</span><span class=p>();</span><span class=w>   </span><span class=p>{</span><span class=w> </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>IllegalStateException</span><span class=p>();</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This way, if the object is known to be only a <code>Base</code>, these methods are un-deprecated, and can be used to "cast" itself to a different type so I can invoke the subclass's methods on it. This seems elegant to me in a way, but on the other hand, I'm kind of abusing Deprecated annotations as a way to "remove" methods from a class.</p><p>Since a <code>Sub1</code> instance really <em>is</em> a Base, it does make sense to use inheritance rather than encapsulation. Is what I'm doing good? Is there a better way to solve this problem?</p><p>Tags: java, inheritance, type-casting</p><p>asked by codebreaker</p></blockquote><p>The highest scoring answer so far has collected 21 upvotes and 3 downvotes, and it dismisses the OPs question stating that his design is wrong. Basically, it draws a straw man of the OP's description and proceeds to attack it. The strawman is terrible, so he is mighty successful at destroying it. Needless to say, one of the 3 downvotes is mine.</p><p>Then, here is my answer, which turned out to be highly unpopular:</p><blockquote><p>What you are doing is perfectly legitimate. Do not pay attention to the naysayers who merely reiterate dogma because they read it in some books. Dogma has no place in engineering.</p><p>I have employed the same mechanism a couple of times, and I can say with confidence that the java runtime could have also done the same thing in at least one place that I can think of, thus improving performance, usability, and readability of code that uses it.</p><p>Take for example <code>java.lang.reflect.Member</code>, which is the base of <code>java.lang.reflect.Field</code> and <code>java.lang.reflect.Method</code>. (The actual hierarchy is a bit more complicated than that, but that's irrelevant.) Fields and methods are vastly different animals: one has a value that you can get or set, while the other has no such thing, but it can be invoked with a number of parameters and it may return a value. So, fields and methods are both members, but the things you can do with them are about as different from each other as making sandwiches vs. contacting aliens.</p><p>Now, when writing code that uses reflection we very often have a <code>Member</code> in our hands, and we know that it is either a <code>Method</code> or a <code>Field</code>, (or, rarely, something else,) and yet we have to do all the tedious <code>instanceof</code> to figure out precisely what it is and then we have to cast it to get a proper reference to it. (And this is not only tedious, but it also does not perform very well.) The <code>Method</code> class could have very easily implemented the pattern that you are describing, thus making the life of thousands of programmers easier.</p><p>Of course, this technique is only viable in small, well-defined hierarchies of closely coupled classes that you have (and will always have) source-level control of: you don't want to be doing such a thing if your class hierarchy is liable to be extended by people who are not at liberty to refactor the base class.</p><p>Here is how what I have done differs from what you have done:</p><ul><li>The base class provides a default implementation for the entire <code>asDerivedClass()</code> family of methods, having each one of them return <code>null</code>.</li><li>Each derived class only overrides one of the <code>asDerivedClass()</code> methods, returning <code>this</code> instead of <code>null</code>. It does not override any of the rest, nor does it want to to know anything about them. So, no <code>IllegalStateException</code>s are thrown.</li><li>The base class also provides <code>final</code> implementations for the entire <code>isDerivedClass()</code> family of methods, coded as follows: <code>return asDerivedClass() != null;</code> This way, the number of methods that need to be overridden by derived classes is minimized.</li><li>I have not been using <code>@Deprecated</code> in this mechanism because I did not think of it. Now that you gave me the idea, I will put it to use, thanks!</li></ul><p>C# has a related mechanism built-in via the use of the <code>as</code> keyword. In C# you can say <code>DerivedClass derivedInstance = baseInstance as DerivedClass</code> and you will get a reference to a <code>DerivedClass</code> if your <code>baseInstance</code> was of that class, or <code>null</code> if it was not. This (theoretically) performs better than <code>is</code> followed by cast, (<code>is</code> is the admittedly better named C# keyword for <code>instanceof</code>,) but the custom mechanism that we have been hand-crafting performs even better: the pair of <code>instanceof</code>-and-cast operations of Java, as well as the <code>as</code> operator of C# do not perform as fast as the single virtual method call of our custom approach.</p><p>I hereby put forth the proposition that this technique should be declared to be <strong>a pattern</strong> and that a nice name should be found for it.</p><h3 id=gee-thanks-for-the-downvotes>Gee, thanks for the downvotes!</h3><p>A summary of the controversy, to save you from the trouble of reading the comments:</p><p>People's objection appears to be that the original design was wrong, meaning that you should never have vastly different classes deriving from a common base class, or that even if you do, the code which uses such a hierarchy should never be in the position of having a base reference and needing to figure out the derived class. Therefore, they say, the self-casting mechanism proposed by this question and by my answer, which improves the use of the original design, should never have been necessary in the first place. (They don't really say anything about the self-casting mechanism itself, they only complain about the nature of designs that the mechanism is meant to be applied to.)</p><p>However, in the example above I have <strong>already</strong> shown that the creators of the java runtime did in fact choose precisely such a design for the <code>java.lang.reflect.Member</code>, <code>Field</code>, <code>Method</code> hierarchy, and in the comments below I <strong>also</strong> show that the creators of the C# runtime independently arrived at an <strong>equivalent</strong> design for the <code>System.Reflection.MemberInfo</code>, <code>FieldInfo</code>, <code>MethodInfo</code> hierarchy. So, these are two different real world scenarios which are sitting right under everyone's nose and which have demonstrably workable solutions using precisely such designs.</p><p>That's what all the following comments boil down to. The self-casting mechanism is hardly mentioned.</p></blockquote><p>So, I have copied all this here for posterity, because I really do stand by my convictions and I will continue to do so no matter how many people disagree with me, for as long as I don't see any valid arguments against my convictions.</p><p>Acceptance of some strategy and dismissal of some other strategy without objective reasons for doing so is just plain good ol' dogma.</p><p><strong>Old comments</strong></p><ul><li><p>Anonymous 2015-07-05 13:06:52 UTC</p><p>See your note on "Clean Code", Page 291 - “G7: Base Classes Depending on Their Derivatives” here: <a href=/post/2013-03-20-my-notes-on-clean-code/>My Notes On 'Clean Code' By Robert C. Martin</a>. Seems you changed your tune by admitting there are exceptions. How... unpopular!</p></li><li><p><a class=external href=http://michael.gr target=_blank>michael.gr</a> 2015-07-05 13:11:58 UTC</p><p>Yes, I changed my mind. There are some exceptions. I do have the right to change my mind, right? Have you never changed your mind about anything? How do you like it when people make snide remarks about changes of tune? Anyhow, thanks for pointing that out to me, I will now go fix it.</p><ul><li><p><a class=external href=http://michael.gr target=_blank>michael.gr</a> 2015-07-05 13:20:14 UTC</p><p>So, I fixed it. The comment that I removed about Page 291 "G7" was: "A class should not know anything about its derivatives, period. I do not believe that there should ever be exceptions to this rule." Well, it turns out, there are some cases where this rule can have some useful exceptions.</p></li></ul></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/software-engineering/>Software Engineering</a></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on 2026-01-21 Wed 11:16:39 CET</span></section></footer></article><script>var idcomments_post_id,idcomments_post_url,idcomments_acct="131c02e0ef20d1a4606aa4e3490711ba"</script><span id=IDCommentsPostTitle style=display:none></span>
<script type=text/javascript src=https://www.intensedebate.com/js/genericCommentWrapperV2.js></script><footer class=site-footer><section class=copyright>&copy; 2001 - 2026 Michael Belivanakis (a.k.a. Mike Nakis)</section><section class=powerby>Made using <b><a href=https://obsidian.md target=_blank>Obsidian</a></b> and <b><a href=https://gohugo.io/ target=_blank>Hugo</a></b><br>Theme based on <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank data-version=%s>hugo-theme-stack</a></b> by <a href=https://jimmycai.com target=_blank>Jimmy Cai</a><br></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>