<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="\rI will try to make a list of items here, but I could probably write a book on this.\n"><title>On Code Craftsmanship</title><link rel=canonical href=https://blog2.michael.gr/post/2018-02-code-craftsmanship/><link rel=stylesheet href=/scss/style.min.b390e410854a1900b4186a664a0397a2b4ee1b587bc335c2e9befc929a849158.css><meta property='og:title' content="On Code Craftsmanship"><meta property='og:description' content="\rI will try to make a list of items here, but I could probably write a book on this.\n"><meta property='og:url' content='https://blog2.michael.gr/post/2018-02-code-craftsmanship/'><meta property='og:site_name' content="Michael's Blog"><meta property='og:type' content='article'><meta property='article:section' content='post'><meta property='article:tag' content='software-architecture'><meta property='article:tag' content='software-engineering'><meta property='article:tag' content='papers'><meta property='article:tag' content='wisdom'><meta property='article:published_time' content='2018-02-05T15:55:42+00:00'><meta property='article:modified_time' content='2025-10-23T19:23:41+02:00'><meta name=twitter:title content="On Code Craftsmanship"><meta name=twitter:description content="\rI will try to make a list of items here, but I could probably write a book on this.\n"><link rel="shortcut icon" href=/favicon.svg><script async src="https://www.googletagmanager.com/gtag/js?id=TODO"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","TODO")}</script></head><body class="article-page
article-page"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><ol class=menu id=main-menu><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol><a href=/><img src=/logo.svg width=210 loading=lazy alt=Logo></a><figure class=site-avatar><a href=/><img src="https://gravatar.com/avatar/8d1c5b5578843f958430afe30e0cbb2fb5092b1712d1933ea37d7bf5cb4305ed?size=400" width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure></header><ul class=menu-social><li><a href=/contact-via-e-mail/ title=e-Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z"/><path d="M3 7l9 6 9-6"/></svg></a></li><li><a href=/contact-via-whatsapp/ title=WhatsApp rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 21l1.65-3.8a9 9 0 113.4 2.9L3 21"/><path d="M9 10a.5.5.0 001 0V9A.5.5.0 009 9v1a5 5 0 005 5h1a.5.5.0 000-1h-1a.5.5.0 000 1"/></svg></a></li><li><a href=https://github.com/mikenakis target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/mikenakis target=_blank title=LinkedIn rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 11v5"/><path d="M8 8v.01"/><path d="M12 16v-5"/><path d="M16 16v-3a2 2 0 10-4 0"/><path d="M3 7a4 4 0 014-4h10a4 4 0 014 4v10a4 4 0 01-4 4H7a4 4 0 01-4-4z"/></svg></a></li><li><a href=https://stackoverflow.com/users/773113/mike-nakis target=_blank title="Stack Overflow" rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 17v1a2 2 0 002 2h12a2 2 0 002-2v-1"/><path d="M8 16h8"/><path d="M8.322 12.582l7.956.836"/><path d="M8.787 9.168l7.826 1.664"/><path d="M10.096 5.764l7.608 2.472"/></svg></a></li><li><a href=https://twitter.com/mikenakis target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ul><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#assert-everything>Assert everything</a></li><li><a href=#do-black-box-testing-avoid-white-box-testing>Do black-box testing, avoid white-box testing</a></li><li><a href=#avoid-non-determinism-in-tests>Avoid non-determinism in tests</a></li><li><a href=#minimize-state-maximize-immutability>Minimize state, maximize immutability</a></li><li><a href=#do-overwrite-function-parameters>Do overwrite function parameters</a></li><li><a href=#avoid-hail-mary-initializations>Avoid <em>Hail-Mary Initializations</em></a></li><li><a href=#avoid-b-to-a-style-conversions-use-a-from-b-style-instead>Avoid "b-to-a" style conversions, use "a-from-b" style instead</a></li><li><a href=#avoid-yoda-conditionals>Avoid <em>Yoda conditionals</em></a></li><li><a href=#avoid-unnecessary-braces>Avoid unnecessary braces</a></li><li><a href=#avoid-egyptian-style-curly-braces>Avoid Egyptian-style curly braces</a></li><li><a href=#minimize-flow-control-statements>Minimize flow control statements</a></li><li><a href=#favor-one-and-only-one-way-of-doing-any-given-thing>Favor one and only one way of doing any given thing</a></li><li><a href=#put-the-complexity-in-the-design-not-in-the-code>Put the complexity in the design, not in the code</a></li><li><a href=#adhere-to-the-single-responsibility-principle-like-your-life-depends-on-it>Adhere to the Single Responsibility Principle like your life depends on it</a></li><li><a href=#refactor-at-the-slightest-indication-that-refactoring-is-due>Refactor at the slightest indication that refactoring is due</a></li><li><a href=#strive-for-abstraction-and-generalization>Strive for abstraction and generalization</a></li><li><a href=#use-abstraction-even-in-the-spoken-language>Use abstraction even in the spoken language</a></li><li><a href=#avoid-false-abstractions>Avoid false abstractions</a></li><li><a href=#use-domain-specific-interfaces>Use domain-specific interfaces</a></li><li><a href=#favor-libraries-over-frameworks>Favor libraries over frameworks</a></li><li><a href=#strive-for-what-is-simple-not-for-what-looks-easy>Strive for what is simple, not for what looks easy</a></li><li><a href=#avoid-binding-by-name-like-the-plague>Avoid binding by name like the plague</a></li><li><a href=#always-use-strong-typing>Always use strong typing</a></li><li><a href=#strive-for-debuggability>Strive for debuggability</a></li><li><a href=#resist-the-idiomatic-craze>Resist the idiomatic craze</a></li><li><a href=#strive-for-testability>Strive for testability</a></li><li><a href=#enable-all-warnings-that-can-be-enabled>Enable all warnings that can be enabled</a></li><li><a href=#thou-shalt-not-suffer-a-warning-to-live>Thou shalt not suffer a warning to live</a></li><li><a href=#treat-warnings-as-errors>Treat Warnings as Errors</a></li><li><a href=#strive-for-readability>Strive for readability</a></li><li><a href=#avoid-using-elements-of-prose-in-code>Avoid using elements of prose in code</a></li><li><a href=#use-an-ide-with-a-spell-checker>Use an IDE with a spell checker</a></li><li><a href=#avoid-acronyms-and-abbreviations>Avoid acronyms and abbreviations</a></li><li><a href=#pay-attention-to-naming>Pay attention to naming</a></li><li><a href=#avoid-conventions-that-make-code-look-unnecessarily-technical>Avoid conventions that make code look unnecessarily technical</a></li><li><a href=#avoid-hungarian-notation>Avoid Hungarian Notation.</a></li><li><a href=#use-the-type-system-to-the-fullest>Use the type system to the fullest</a></li><li><a href=#avoid-defensive-programming-engage-in-offensive-programming-instead>Avoid defensive programming; engage in <em>offensive</em> programming instead</a></li><li><a href=#use-inheritance-when-it-is-clearly-the-right-choice>Use inheritance when it is clearly the right choice</a></li><li><a href=#favor-early-exits-over-deep-nesting>Favor early exits over deep nesting</a></li><li><a href=#avoid-static-mutable-state-like-anthrax>Avoid static mutable state like anthrax</a></li><li><a href=#optimize-performance-bottlenecks-not-performance-penalties>Optimize performance bottlenecks, not performance penalties</a></li><li><a href=#put-the-tools-of-the-trade-into-use>Put the tools of the trade into use</a></li><li><a href=#design-with-reliability-as-a-foundation-not-as-an-afterthought>Design with reliability as a foundation, not as an afterthought</a></li><li><a href=#design-with-security-as-a-foundation-not-as-an-afterthought>Design with security as a foundation, not as an afterthought</a></li><li><a href=#keep-the-log-clean>Keep the log clean</a></li><li><a href=#make-the-best-out-of-the-log>Make the best out of the log</a></li><li><a href=#take-maxims-with-a-grain-of-salt>Take maxims with a grain of salt</a></li><li><a href=#private-static-methods-are-fine-really>Private static methods are fine. Really</a></li><li><a href=#do-not-fix-it-unless-there-is-a-test-for-it>Do not fix it unless there is a test for it</a></li><li><a href=#avoid-death-by-ten-thousand-little-methods>Avoid death by ten thousand little methods</a></li><li><a href=#make-the-best-out-of-break-on-exception>Make the best out of break-on-exception</a></li><li><a href=#write-code-as-if-it-will-be-reviewed-by-someone-even-if-it-never-will>Write code as if it will be reviewed by someone, even if it never will</a></li><li><a href=#avoid-writing-code-comments>Avoid writing code comments</a></li><li><a href=#if-you-must-write-doc-comments-make-them-good>If you must write doc-comments, make them good</a></li><li><a href=#always-maintain-provenance>Always maintain provenance</a></li><li><a href=#stick-with-utc-everywhere>Stick with UTC everywhere</a></li><li><a href=#keep-technical-implementation-concerns-separate-from-application-concerns>Keep technical implementation concerns separate from application concerns</a></li><li><a href=#maximize-the-consistency-of-code-formatting>Maximize the consistency of code formatting</a></li><li><a href=#use-tight-abstractions>Use tight abstractions</a></li><li><a href=#thoroughly-emulate-any-and-all-hardware>Thoroughly emulate any and all hardware</a></li><li><a href=#only-use-absolute-file-system-paths>Only use absolute file-system paths</a></li><li><a href=#avoid-guids-also-known-as-uuids>Avoid GUIDs (also known as UUIDs)</a></li><li><a href=#do-it-right->Do It Right â„¢</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/post/2018-02-code-craftsmanship/>On Code Craftsmanship</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2018-02-05 Mon 15:55:42 UTC</time></div><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 20v-2a6 6 0 1112 0v2a1 1 0 01-1 1H7a1 1 0 01-1-1z"/><path d="M6 4v2a6 6 0 1012 0V4a1 1 0 00-1-1H7A1 1 0 006 4z"/></svg>
<time class=article-time--reading>70 minute read</time></div></footer></div></header><section class=article-content><p><img src=/post/2018-02-code-craftsmanship/media/craftsmanship-guitar.jpg width=2048 height=1365 loading=lazy class=gallery-image data-flex-grow=150 data-flex-basis=360px></p><p>I will try to make a list of items here, but I could probably write a book on this.</p><p>(Useful pre-reading: <a href=/post/2022-11-about-these-papers/>About these papers</a>)</p><h3 id=assert-everything>Assert everything</h3><p>Assertions take care of white-box testing your code, so that automated software testing can be confined to the realm of strictly black-box testing, as it should. Assertions do not execute on release builds / production runs, so they essentially cost nothing. This means that you can go wild with them:</p><ul><li>Go ahead and assert that your array is sorted before performing binary search on it.</li><li>Verify that your binary search worked correctly by comparing its result against the result of a linear search for the same item.</li></ul><p>Yes, the time complexity of these assertions is far greater than the time complexity of the operation that they guard, and this is perfectly fine, because:</p><ul><li>Remember, assertions do not execute on release runs, so they cost nothing.</li><li>On test runs, you are not supposed to be using large amounts of data anyway. When N is small, then O(N) and even O(N<sup>2</sup>) are not very different from O(log<sub>2</sub>(N)), which means that even when assertions do execute, they do not matter.</li><li>To the small extent that assertions might nonetheless slow you down during development, you can see it as one more reason why you, as a developer, should have a computer which is much more powerful than the computers of mere mortals --er, I mean, users.</li></ul><p>When I look at code, I don't ask myself "should I assert that?" Instead, I ask myself "is there anything that I forgot to assert?" The idea is to assert everything that could possibly be asserted, leave nothing assertable unasserted. I call this <em>The Maximalistic Approach to Error Checking</em>, in contrast to the predominant minimalistic approach, where programmers decide on a case by case basis whether to assert something or not, based on completely-oblivious-of-Murphy's-law assumptions about how likely it is to go wrong, inappropriately mixed with misguided performance considerations.</p><p>For more information, see <a href=/post/2014-09-assertions-and-testing/>Assertions and Testing</a>.</p><p>Also note that the attention horizon of code is the function, so if function <code>f1()</code> asserts some condition and then invokes function <code>f2()</code>, it is perfectly fine for <code>f2()</code> to also assert the same condition. In other words, whether something has already been asserted or not by some other function is irrelevant: each function must assert every condition that pertains to it.</p><h3 id=do-black-box-testing-avoid-white-box-testing>Do black-box testing, avoid white-box testing</h3><p>Heed the advice that says <em>test against the interface, not the implementation</em>. Unit Testing is testing against the implementation, so despite the entire software industry's addiction to it, it should be avoided. Incidentally, this means that mocking, despite being an admirably nifty trick, should never be used: if you are using mocks then you are doing white-box testing, so you are doing it wrong.</p><ul><li>For more on why Unit Testing is white-box testing, and why white-box testing is bad, read this: <a href=/post/2021-12-white-box-vs-black-box-testing/>White-Box vs. Black-Box Testing</a></li><li>For more on why mocks in particular are especially bad, read this: <a href=/post/2023-01-14-mocking/>If you are using mock objects you are doing it wrong</a>.</li><li>For what to use instead of mocks, read this: <a href=/post/2022-10-testing-with-fakes/>Testing with Fakes instead of Mocks</a></li><li>For what to do instead of unit testing, read this: <a href=/post/2022-10-incremental-integration-testing/>Incremental Integration Testing</a></li><li>If for some reason you <em>must</em> do white-box testing, then you can at least avoid having to do it in code; read this: <a href=/post/2024-04-audit-testing/>Audit Testing</a> and this: <a href=/post/2023-01-06-collaboration-monitoring/>Collaboration Monitoring</a></li></ul><h3 id=avoid-non-determinism-in-tests>Avoid non-determinism in tests</h3><p>Testing must be completely free from non-determinism under all circumstances. Since testing code exercises production code, this means that production code must also be free from non-determinism, or at the very least any source of non-determinism in production code must be replaceable during testing with a fake which is completely deterministic. For example:</p><ul><li>Never rely on the garbage-collector doing anything other than reclaiming memory; specifically, never rely on any cleanup operations being initiated by the garbage-collector. Perform all cleanup explicitly. For more information, see <a href=/post/2020-12-27-object-lifetime-awareness/>Object Lifetime Awareness</a>.</li><li>Never allow any external factors such as file creation times, IP addresses resolved from DNS, etc. to enter into the tests. Fake your file-system; fake The Internet if necessary.</li><li>Never use wall-clock time; always fake the clock, making it start from some arbitrary fixed origin and incrementing by a fixed amount each time it is queried.</li><li>Never use random numbers; if randomness is necessary in some scenario, then fake it using a pseudo-random number generator seeded with a known fixed value. This includes all constructs that utilize randomness, for example GUIDs/UUIDs.</li><li>Never allow any concurrency during testing; all components must be tested while running strictly single-threaded, or at the very least multi-threaded but in lock-step fashion.</li></ul><h3 id=minimize-state-maximize-immutability>Minimize state, maximize immutability</h3><p>Design so that as much code as possible is dealing with data that is immutable. Re-examine every single class which contains mutable members, and many chances are you will find that it could be replaced with an immutable class. Even if not, you might discover that many of its members could be immutable.</p><p>Eschew frameworks, technologies, and techniques that prevent or hinder immutability. For example, if you are using some dependency-injection (DI) facility that provides you with auto-wiring, use constructor injection <strong>only,</strong> so that you can always store in final/readonly members. If your DI facility does not support constructor injection, throw away everything and start from scratch with one that does.</p><p>Note, however, that immutability is not important in function-local variables. There is absolutely nothing wrong with function-local mutation if it serves the slightest purpose. Which brings us to the next point:</p><h3 id=do-overwrite-function-parameters>Do overwrite function parameters</h3><p>There exists a widespread cargo cult habit among programmers, of never overwriting the value of a parameter to a function within the function. This habit is so unquestioned that it enjoys "best practice" status, despite being completely misguided. Some languages (e.g. Scala) even prohibit it, which is deplorable. Go ahead and overwrite function parameters (if your language allows it) when the original parameter value should not be used in the remainder of the function. In doing so you are minimizing the number of variables that are in scope, and preventing accidental use of the original value.</p><p>The historical origins of the practice of never overwriting function parameters are actually quite funny: some early versions of Fortran (the first programming language) used to pass everything by reference, including constants. So, if you had function F(X) which was invoked with 3 for X, and within F(X) you assigned 5 to x, then from that moment on the constant 3 would actually have the value 5 in your entire program. As a result, early computer scientists decreed that function parameters should never be reassigned. Fortran was soon fixed to correct this problem, but the advise kept being passed from generation to generation of programmers, who have been accepting it without rethinking it. This is cargo cult programming at its finest.</p><h3 id=avoid-hail-mary-initializations>Avoid <em>Hail-Mary Initializations</em></h3><p>Contrary to what many people falsely think of as "common knowledge" and "best practice", you should never initialize a variable before you have a meaningful value to assign to it. For more information, see <a href=/post/2012-01-03-hail-mary-initialization/>Hail-Mary Initialization</a>.</p><h3 id=avoid-b-to-a-style-conversions-use-a-from-b-style-instead>Avoid "b-to-a" style conversions, use "a-from-b" style instead</h3><p>When I see <code>A = AfromB( B )</code> I can immediately tell that it looks correct, since A is on the side of A and B is on the side of B. However, when I see <code>B = AtoB( A )</code> I have to stare at it for a few milliseconds longer before I can tell whether it is correct or not. Of course, this is a trivial example: in real-world situations, the identifiers, as well as the call chain, could be much longer and much more complicated. This is related to Joel Spolsky's notion that <a class=external href=https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/ target=_blank>wrong code should look wrong</a>, and it is especially important since the entire industry has traditionally been doing it in precisely the wrong way with B-to-A style conversions.</p><h3 id=avoid-yoda-conditionals>Avoid <em>Yoda conditionals</em></h3><p>This is the practice of reversing the terms around the equality operator when one of the terms is a constant. You might have seen it the following forms:</p><ul><li><code>if( 5 == a )</code> instead of the normal <code>if ( a == 5 )</code>.</li><li><code>if( "x".equals( b ) )</code> instead of the normal <code>if( b.equals( "x" ) )</code>.</li></ul><p>Don't do this. The Principle of Least Surprise is not just violated by this construct, it is gang-raped. Plus, in doing this you are most probably engaging in the cardinal sin of <em><strong>silent failure</strong></em>. Here are the reasons often cited for using Yoda conditionals, and their rebuttals:</p><ul><li><p>Alleged reason #1</p><ul><li><p>Statement: It will catch accidental use of the assignment operator where the equality operator was intended.</p></li><li><p>Rebuttal: Such accidental use should be impossible because your compiler or your IDE should be issuing a warning if you try to do this. If you are not receiving a warning, then you have other, much bigger problems in need of solving, i.e. using the wrong programming language, using the wrong IDE, or trying to write code without first having figured out how to enable all warnings.</p></li></ul></li><li><p>Alleged reason #2</p><ul><li><p>Statement: It works even if the variable accidentally happens to be null.</p></li><li><p>Rebuttal: No, it does not work; it silently fails. If you follow <em>offensive programming</em>, the definition of "it works" is that <em><strong>it produces correct results when given valid input, and it decisively fails when given invalid input.</strong></em></p><p>So, there are two possibilities: either the variable may legitimately be null, or it may not.</p><ul><li>if the variable may legitimately be null, then make it evident by explicitly checking against null.</li><li>if the variable may not legitimately be null, then write the code so that it will <em><strong>not fail to fail</strong></em> if the variable ever turns out to be null.</li></ul></li></ul></li></ul><h3 id=avoid-unnecessary-braces>Avoid unnecessary braces</h3><p>Doing so keeps the code more compact, making more statements fit within the screen. The cargo-cult programming convention of enclosing even single-statement blocks within curly braces allegedly avoids bugs caused by trying to add a second statement to the block while forgetting to introduce curly braces.</p><p>This has actually happened to me once, and the programmer who introduced the bug in my code did not even apologize, because he considered it my fault for not having provided the curly braces for him to insert his second statement in.</p><p>The fact of the matter is that a decent IDE will point out such a mistake as a formatting violation, so this is not a problem today. Of course, in order to enable the IDE to point out formatting violations you must be keeping a consistent indentation style everywhere, right? <em><strong>Right?</strong></em></p><h3 id=avoid-egyptian-style-curly-braces>Avoid Egyptian-style curly braces</h3><p>People who use Egyptian-style curly braces essentially treat them as noise. I would very much favor a programming language where nesting is based on indentation alone, thus requiring no curly braces; unfortunately, the only such language that I know of is Python, which is a scripting language, and therefore out of the question; so, for as long as we are using programming languages that require curly braces, we have to pay attention to them and we cannot just treat them as noise; therefore, absolutely all curly braces must absolutely always be perfectly aligned; period, end of story, discussion is locked and comments are closed.</p><h3 id=minimize-flow-control-statements>Minimize flow control statements</h3><p>Especially the <code>if</code> statement. If there is any opportunity to structure a piece of code so as to eliminate an <code>if</code> statement, the opportunity should be pursued <em>tenaciously</em>.</p><p>Of course, by this I do not mean replacing <code>if</code> statements with the conditional operator ( <code>a ? x : y</code> ); the conditional operator is nice, because it makes code more expressive and compact, but it is equivalent to an <code>if</code> statement, so it too should be eliminated when possible.</p><p>The <code>if</code> statement can be avoided in many cases with the use of calculations, with lookup tables, with the judicious application of inheritance and polymorphism, etc.</p><h3 id=favor-one-and-only-one-way-of-doing-any-given-thing>Favor one and only one way of doing any given thing</h3><p>If you ask a hundred programmers to write some code that accomplishes a certain simple task, you will get a hundred different solutions. These solutions will reflect different ways of thinking, which is inevitable, but they will also reflect different coding conventions, which is entirely unnecessary. Establish conventions that minimize unnecessary differences. One easy way to achieve this is to stipulate that any construct which is optional must be omitted. For example:</p><ol><li><p>Disallow extra parentheses in expressions.</p><p>Unfortunately, compilers by default allow superfluous parentheses without complaining. This has fostered the development of some truly bizarre habits among programmers, such as the construct <code>return (x);</code> which is so common that some folks are under the impression that this is the correct syntax, and that <code>return x;</code> would constitute a syntax error. Well, guess what: <code>return x;</code> is the correct syntax, whereas <code>return (x);</code> contains a pair of superfluous parentheses. Configure your compiler or your code analysis tool-set to disallow unnecessary parentheses, so that all code that accomplishes the same thing looks the same.</p><p>If you do this, then the tooling will also complain about parentheses that you might be using elsewhere to clarify the order in which calculations are to be performed when you are unsure about the operator precedence rules of the language. Here is what I have to say about that:</p><p>Your programming language has a very specific, very well documented, and rather small set of rules that govern operator precedence; these rules are fundamental, and this programming language is your bread and butter; so, learn them. Learn them all by heart, so that you are never unsure about operator precedence, so that you never need extra parentheses for clarification.</p></li><li><p>Disallow optional keywords.</p><p>In many languages, certain keywords are implied by default and can be omitted. Unfortunately, in virtually all example code out there, such keywords tend to always be included, which leads people to form the impression that they must be mandatory.</p><p>For example, did you know that in C# every class is <code>internal</code> by default? This means that you never have to say <code>internal class Foo { ... }</code>, you can simply say <code>class Foo { ... }</code>.</p><p>Furthermore, did you know that in C# every class member is <code>private</code> by default? This means that you never have to say <code>private int foo() { ... }</code>, you can simply say <code>int foo() { ... }</code>.</p><p>Again, it is fundamental rules of the language that govern these things, which means that every programmer should know them by heart, which in turn means that nobody should be surprised to see <code>int foo() { ... }</code>, and nobody should be wondering what the visibility of <code>foo()</code> is.</p></li><li><p>Disallow the <code>var</code> keyword.</p><p>If we were to mandate that two lines of code should look identical if they accomplish the same thing, we have two options: either always require the <code>var</code> keyword, or completely disallow it.</p><p>Always requiring the <code>var</code> keyword is not an option, because in many cases the type cannot be inferred from the right hand side, so it must be specified. Thus, we are only left with the option of completely disallowing it, and that is the way to go.</p><p>Furthermore, as I explain elsewhere, "absolutely any choice that makes code easier to read is absolutely always preferable over absolutely any choice that makes code easier to write", and the <code>var</code> keyword is a prime example of a choice which is easy to write but makes code harder to read, so we should not even be debating this.</p><p>If you are not sure about the exact type of the right-hand side of an assignment, or if you do not want to be bothered with having to type it, is perfectly okay to begin with <code>var x = ...</code>, and once you have written your entire statement you go back to the <code>var</code> keyword, and ask your IDE to refactor it and replace it with the actual type.</p><p>The <code>var</code> keyword is only useful in type casts; I would rather say <code>var x = (int)y;</code> than <code>int x = (int)y;</code> however, the benefits of being able to disallow <code>var</code> with a rule outweigh the convenience of being able to use it in type casts.</p></li></ol><h3 id=put-the-complexity-in-the-design-not-in-the-code>Put the complexity in the design, not in the code</h3><p>If the code does not look so simple that even an idiot can understand it, then the code is too complex. When this happens, it usually means that shortcuts were taken in the design, which had to be compensated for with overly complex code. Make the design as elaborate as necessary so that the code can be as simple as possible. Overly complex code is usually the result of violations of the <em>Single Responsibility Principle.</em> Which brings us to the next point:</p><h3 id=adhere-to-the-single-responsibility-principle-like-your-life-depends-on-it>Adhere to the Single Responsibility Principle like your life depends on it</h3><p>Often, what you <em>think</em> of as a single responsibility can in fact be further sub-divided into a number of more fundamental responsibilities. Almost all of the code that we write performs, or can be thought of as performing, some kind of transformation, involving a certain number of participants. For example:</p><ul><li>At the lowest level, an assignment operation transforms each bit of the destination variable into the corresponding bit of the source variable. Obviously it involves two participants: the source and the destination.</li><li>At the highest level, a shopping web site transforms relational data and user input into pixels on the user's browser window and purchase orders in the logistics department. In this simplified view we have four participants, realistically we have many more.<ul><li>Most transformations are of the simplest kind, involving only two participants, transforming one into the other. That's great, that's a single responsibility: convert A to B.</li><li>Many transformations involve three participants, A, B and C, and they tend to be appreciably complex.<ul><li>In some cases they can be simplified into successive operations, one to go from A to B and another to go from B to C, meaning that there were in fact two different responsibilities which were identified and realized as separate steps.</li><li>However, quite often they cannot be simplified, as for example when we are converting A to C by consulting B. That's a single responsibility which cannot be further broken down.</li></ul></li><li>All to often, people manage to involve four or more participants in a single transformation. These tend to be grotesquely complex, and they invariably constitute violations of the single responsibility principle. It goes without saying that they must be avoided at all costs.</li></ul></li></ul><p>Luckily, operations that involve more than 3 participants can always be refactored into multiple successive transformations of no more than 3 participants each, by introducing intermediate participant types if necessary. (I have never heard of this being suggested by anyone before, so this could perhaps be <em>The Mike Nakis Postulate for Simplification</em>.)</p><h3 id=refactor-at-the-slightest-indication-that-refactoring-is-due>Refactor at the slightest indication that refactoring is due</h3><p>Do not allow technical debt to accumulate. Avoid the situation of being <em>too busy mopping the floor to turn off the faucet.</em> Allow a percentage of sprints to explicitly handle nothing but technical debt elimination. Do not try to spread the task of refactoring over feature development sprints, because:</p><ul><li>The refactoring effort will not magically disappear.</li><li>Focus will be diluted.</li><li>Time estimations will suffer.</li></ul><p>Managers who feel that every sprint must involve some feature development or else it does not look good on their report should be removed from their positions and be given jobs milking goats.</p><h3 id=strive-for-abstraction-and-generalization>Strive for abstraction and generalization</h3><p>The urge to abstract and generalize is often mistaken as having reusability as its sole aim, so it is often met with the YAGNI objection: "You Ain't Gonna Need It". The objection is useful to keep in mind so as to avoid over-engineering, but it should not be followed blindly, because abstraction and generalization have important inherent benefits, regardless of the promise of reusability.</p><p>Every problem of a certain complexity and above, no matter how application-specific it might seem to be, can benefit from being divided into a specialized, application-specific part, and an abstract, general-purpose part. Strive to look for such divisions and realize them in the design.</p><ul><li>The application-specific part will be simpler to write and to understand, because it will be free from the <em>incidental complexity</em> represented by the general-purpose part.</li><li>The general-purpose part will be simpler to write and to understand, because it will be implementing a self-contained abstraction that can be independently reasoned about.</li><li>Also, the general-purpose part will be fully testable on its own, so you will have assurances that it works, regardless of how the application-specific part uses it, and regardless of how the application-specific part evolves over time.</li></ul><p>Note that the above benefits come in addition to the potential benefit of reusability.</p><p>In other words, if you can choose between the following two:</p><ul><li>adding 5 lines of application code, vs.</li><li>adding only 2 lines of application code but a whole 10 lines of infrastructure code</li></ul><p>then opt for the latter, even if these 10 lines of infrastructure code are unlikely to ever be reused. Saving 3 lines of application code is worth writing an extra 10 lines of infrastructure code.</p><h3 id=use-abstraction-even-in-the-spoken-language>Use abstraction even in the spoken language</h3><p>People have the unfortunate tendency of using the most specific term for any given thing, rather than the most abstract term. I am not sure why people do this, perhaps it is addiction to technicality, perhaps it is trying to sound smart, but it often ends up causing miscommunication. For example:</p><ul><li>if your application has a settings file, and this file happens to be a json file, people are likely to form a habit of calling it "the json file" instead of "the settings file".</li><li>if your application stores session state information in a key-value store, and that store happens to be a Redis instance, people are likely to say "send it to Redis" instead of "send it to the session state store".</li></ul><p>Identify such unwarranted technicalisms and encourage people to switch to using the abstract terms instead. Tell them that the json file was replaced with a yaml file today, and when they all start calling it the yaml file, tell them that it is now an xml file. When they start complaining, tell them that the particular file format of the settings file is none of their business, and they should be calling it by its proper name, which is "the settings file".</p><h3 id=avoid-false-abstractions>Avoid false abstractions</h3><p>Sometimes programmers give abstract names to things that are not really abstract. For example:</p><ul><li>so-called serialization frameworks which expose details of the underlying file format, meaning that they are only capable of serializing to and from that specific file format. A serialization framework which exposes XML-specific details should not be called a "Serialization Framework"; it should be called an "XML Serialization Framework".</li><li>in NuGet (the predominant package manager in DotNet) a version is said to consist of a version prefix and a version suffix, however the toolset interprets the two in a very specific way: the version prefix is not really a prefix, it is the actual version, and the version suffix is not really a suffix, it is a pre-release version identifier.</li></ul><p>These are examples of pretending that things are more abstract than they really are, which causes misinformation and suffering.</p><h3 id=use-domain-specific-interfaces>Use domain-specific interfaces</h3><p>Encapsulate third party libraries behind interfaces of your own devise, tailored to your specific application domain. Strive to make it so that any third-party library can be swapped with another product without you having to rewrite application logic.</p><p>Conventional wisdom says the opposite: we have all heard arguments like:</p><ul><li>"The best code is the code you don't write" (makes me want to invest in the business of <em>not writing software</em>)</li><li>"A third-party library will be better documented than your stuff" (presumably because documentation is a skill your developers have not mastered)</li><li>"If you run into trouble with a library, you can ask for help on Stack Overflow, whereas with something you have developed in-house, you are stuck" (presumably because your developers know nothing of it, despite working with it every day.)</li></ul><p>The truth with application development is that the more you isolate the application logic from peripheral technologies, the more resilient your application logic becomes to the ever changing technological landscape, a considerable part of which is nothing but ephemeral fashions, the use of which is dictated not by actual technological merit, but by <em>C.V. Driven Development</em><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> instead.</p><p>Incidentally, this also means one more thing:</p><h3 id=favor-libraries-over-frameworks>Favor libraries over frameworks</h3><p>The difference between a framework and a library is, simply speaking, that a library is something that your code invokes, whereas a framework is something that invokes your code. The problem with frameworks is that it is impossible to abstract them away behind custom interfaces; therefore, any code you write using a particular framework will forever be a prisoner of that framework: it will be extremely difficult to replace that framework with a different one without rewriting all your code.</p><h3 id=strive-for-what-is-simple-not-for-what-looks-easy>Strive for what is simple, not for what looks easy</h3><p>The simple often coincides with the easy, but sometimes the two are at odds with each other. Eschew languages and frameworks that provide the illusion of easiness at the expense of simplicity. The fact that a particular toolset makes "hello, world!" an easy one-liner probably means that the hundred-thousand liner that you are actually aiming for will be unnecessarily complicated and hard to write.</p><p>Watch this: <a class=external href=https://www.infoq.com/presentations/Simple-Made-Easy target=_blank>https://www.infoq.com/presentations/Simple-Made-Easy</a></p><h3 id=avoid-binding-by-name-like-the-plague>Avoid binding by name like the plague</h3><p>Avoid as much as possible mechanisms whose modus operandi is binding by name: use them only for interfacing with external entities, never for communication between your own modules. REST enthusiasts can cry me a river.</p><p>Note that binding by name must be avoided even in comments. If you need to refer to an identifier from within a comment, use whatever special notation is offered by the language at hand (<code>{@link ...}</code> in java, <code>&lt;see cref="..."></code> in C#) so that when you later refactor the name of that identifier, the IDE will also update any comments that mention that identifier.</p><h3 id=always-use-strong-typing>Always use strong typing</h3><p>Avoid any kind of weak typing (euphemistically called <em>dynamic</em> typing) and avoid languages and frameworks that require it or even just sympathize with it. Yes, this includes all scripting languages. Scripting language enthusiasts can cry me a river. (And yes, this includes Typescript too, because it <em>sympathizes</em> with JavaScript.)</p><p>Read this: <a href=/post/2017-05-on-scripting-languages/>On Scripting Languages</a>.</p><h3 id=strive-for-debuggability>Strive for debuggability</h3><p>For example, do not overdo it with the so-called "fluent" style of invocations, because they are not particularly debuggable. Do not hurry to adopt this or that cool new programming language before you have made sure that debugger support for it is complete and working properly.</p><h3 id=resist-the-idiomatic-craze>Resist the idiomatic craze</h3><p>Contrary to popular belief, doing things in whatever way is considered idiomatic for the programming language at hand is never an end in and of itself; Avoid the use of idiomatic ways of doing things unless you are convinced they are superior. Many of them are, but some of them are not.</p><h3 id=strive-for-testability>Strive for testability</h3><p>Design interfaces that expose all functionality that makes sense to expose, not only functionality that is known to be needed by the code that will invoke them. For example, the application may only need an interface to expose a <code>register()</code> and <code>unregister()</code> pair of methods, but <code>isRegistered()</code> also makes sense to expose, and it will incidentally facilitate black-box testing.</p><h3 id=enable-all-warnings-that-can-be-enabled>Enable all warnings that can be enabled</h3><p>The fact that a certain warning may on occasion be issued on legitimate code is no reason to disable the warning: the warning must be enabled, and each occurrence of the warning must be dealt with on a case-by-case basis.</p><ul><li>The best way to deal with a warning is to resolve it. For example:<ul><li>If your compiler is warning you that a certain cast is redundant, remove that redundant cast. (Duh!)</li><li>If the compiler is warning you that you are dereferencing a pointer which might be null at that point, then add a null check before dereferencing it. (Duh!)</li><li>If your compiler is warning you that you are invoking an overridable method from within the constructor of a base class, then do whatever restructuring is needed, throw it all away and rewrite it from scratch if necessary, so that no such thing is happening.</li></ul></li><li>Another way of dealing with warnings is by suppressing them. Of course, this approach should only be used on perfectly legitimate code that would become less perfect if it was to be restructured so as to resolve the warning. Suppression should always be as localized as possible, meaning that it should be done on the individual statement where the warning is issued, instead of the entire function or the entire class. Note, however, that there are certain warnings that should always be properly resolved and never suppressed; take the invocation of an overridable method from within the constructor of a base class for example.<ul><li>Some warnings, like "unused identifier", occur on legitimate code too often for selective suppression to be practical. For those warnings, consider using an IDE that supports a "weak warning" or "suggestion" level, which is highlighted inconspicuously, so it can be easily filtered out by your eyes, but the visual clue is still there in case it points to something unexpected. Also consider using a better programming language, which supports a construct known as a "discard variable", allowing the programmer to explicitly state their intention to let a variable go unused, so that the warning can remain a warning.</li></ul></li></ul><p>Of course some silly warnings occur on legitimate code all the time, so it goes without saying that they need to be disabled, but in my experience they are far fewer than the average programmer thinks they are.</p><h3 id=thou-shalt-not-suffer-a-warning-to-live>Thou shalt not suffer a warning to live</h3><p>Every single warning must always be resolved immediately upon being introduced. Nobody should ever commit code that contains warnings, and therefore nobody should ever check out code that already contains warnings.</p><p>This is because a warning always is (or ought to always be) a cause of alarm; however, long-standing warnings constitute long-standing false alarms, so their continued existence causes two things:</p><ol><li>All programmers in the house start becoming insensitive to the alarms, so the alarms start going unnoticed. (The "cry wolf" effect.)</li><li>Those programmers who are perfectionists (and those are the best kind of programmers) start becoming mighty annoyed.</li></ol><p>Which brings us to the next point:</p><h3 id=treat-warnings-as-errors>Treat Warnings as Errors</h3><p>Always use the "treat warnings as errors" option of your compiler. If your compiler does not have such an option, throw away everything and start from scratch with a compiler that has it.</p><p>The conventional understanding of what the difference is between warnings and errors is that with an error, you have to fix it before you can proceed, whereas with a warning, you can just ignore it and proceed.</p><p>This understanding is technically correct, in the sense that this is in fact how compilers tend to behave by default, and this is in turn what most programmers expect, since dumb defaults seem to always suit mindless majorities. However, this conventional understanding, and therefore this default behavior of compilers, is wrong. It has been wrong since the dawn of our discipline, and it continues to be wrong today. The magnitude of the wrongness, multiplied by the pervasiveness of the wrongness, is truly staggering.</p><p>The difference between warnings and errors <em><strong>should be</strong></em> that you can suppress a warning if you must, whereas you cannot suppress an error; however, you should absolutely have to address and eliminate both, meaning that you should have to either explicitly suppress or otherwise resolve every single warning before being allowed to proceed.</p><p>The "treat warnings as errors" option corrects the wrong behavior of compilers, and exists precisely for the benefit of those (apparently very few) people in our discipline who happen to have their reasoning right on this issue.</p><p>Be one of those people. Use that option.</p><h3 id=strive-for-readability>Strive for readability</h3><p>Readability is one of the most important qualities of code, second only to correctness. Code is generally read far more often that it is written. We tend to read code several times as we write it, at least once more as we review it, and then many more times throughout its lifetime as we extend it, refactor it, or tweak it; as we write nearby code; as we browse through code to understand how things work; as we perform troubleshooting; etc. In other words, over time, the reads-to-writes ratio of any piece of code approaches infinity. Therefore:</p><blockquote><p><em><strong>Absolutely any</strong></em> choice that makes code easier to read is <em><strong>absolutely always</strong></em> preferable over <em><strong>absolutely any</strong></em> choice that makes code easier to write.</p></blockquote><p>This means that languages that achieve great terseness of code are not really delivering anything of value by this alone, (I am looking at you, Scala,) because verbosity of code is not one of the major problems that our profession is faced with; unreadable code is. This also means that certain languages whose grotesquely arcane syntax has earned them the "write-only language" designation are not to be touched with a 10 ft. pole. Perl enthusiasts can cry me a river.</p><h3 id=avoid-using-elements-of-prose-in-code>Avoid using elements of prose in code</h3><p>Identifiers should be pedantic, not creative, and unless they pertain to the problem domain, they should come from the realm of engineering, not from the realm of literature. Think twice before using a term like "drop" instead of "delete", "payload" instead of "content", etc. because "drop" and "payload" are metaphors. Metaphor should be avoided unless it helps to express something that would otherwise require an entire sentence to express, for example "Factory" instead of "Object-that-creates-other-objects".</p><h3 id=use-an-ide-with-a-spell-checker>Use an IDE with a spell checker</h3><p>Avoid anything that fails to pass the spell check.</p><p>Add the spell-checking dictionary of the IDE to source control and review any commits to it just as you review any other code.</p><p>This specifically means abandoning certain old habits; all of the following are wrong:</p><blockquote><p>nrPoints; pointsNr; nPoints; pointsN; noPoints; pointsNo; lenPoints; pointsLen</p></blockquote><p>Only the following are right:</p><blockquote><p>numberOfPoints; pointCount; pointsLength</p></blockquote><h3 id=avoid-acronyms-and-abbreviations>Avoid acronyms and abbreviations</h3><p>Use fully spelled-out words of the English language instead.</p><p>Acronyms and abbreviations are cryptic for the uninitiated, and even if they are not, they make the code look unnecessarily technical. Modern IDEs have formidable auto-completion features, so fully spelling out every word does not necessarily mean that you will have to type more, but even if it did, typing is not one of the major problems that our profession is faced with; unreadable code is.</p><p>This means that a huge number of abbreviations which have traditionally been staple terms in programming, should never be used, or their use should be seriously reconsidered. This includes all of the following: abs, addr, alloc, alt, app, arg, async, attr, auth, avg, bg, bat, bin, bool, buf, buff, btn, calc, cert, char, cls, clr, col, coll, cmd, com, cmp, comp, cfg, conf, config, const, ctx, ctrl, conv, coord, cos, cnt, cur, curr, db, dbg, dec, decl, def, deg, del, desc, dest, dev, diff, dim, dir, disp, div, doc, drv, dyn, env, eq, err, exe, exp, expr, ext, fac, fig, fg, fmt, frac, freq, fn, fun, func, gen, geom, hdr, hex, img, imp, impl, inc, idx, info, init, ins, inst, int, iter, lang, len, lib, lnk, max, mem, msg, mid, min, misc, mod, mul, mut, nav, net, num, obj, org, pkg, param, perf, pic, ptr, pos, pow, pwr, pred, pref, prev, priv, proc, prof, pub, rand, rnd, recv, rec, rect, ref, regex, rel, rem, rm, repo, req, res, ret, rev, sel, seq, svc, sess, sin, sln, src, spec, sqrt, std, stmt, stat, str, sub, sync, tan, tmp, temp, txt, usr, util, var, val, vec, ver, win, wiz.</p><p>If a particular acronym is understood by every programmer, then it might be okay to use it in code, but if it is only understood by domain experts, then it is <em>not okay</em>. This is because programmers often work on software for domains on which they are not experts, and even if they do eventually become domain experts, in the beginning they are not, but the beginning is when everything is difficult, so that is precisely the time that you do not want to be adding any extra difficulty to them. This means that very few acronyms are actually okay.</p><p>Let me stress this to make sure it is understood: Domain Experts may protest that it is awkward to see a particular term fully spelled out in the code, because the term is so well known, that it appears as an acronym in the entirety of the literature in their field; let them find it awkward, and let them protest. Your code is not part of the literature in their field.</p><p>If the choice is made to keep a certain acronym in the code, then the acronym must be turned into a word, meaning that only the first letter may be written in upper-case, while all subsequent letters must always be written in lower-case. For example, if you have decided that you are not going to replace <code>GUID</code> with <code>GloballyUniqueIdentifier</code>, I am totally with you, but then you must replace it with <code>Guid</code>, so that the spell-checker can recognize it as a word and spell-check it. Otherwise, the spell-checker will consider each capital letter individually, and each individual letter passes spell-checking, so anything written in all-capitals essentially circumvents the spell-checker. If "Guid" as a word violates your English-language sensitivities, then please remember that you are writing code, not prose. There is a reason it is called code: it is specifically <em>not</em> prose.</p><p>Also beware of abbreviations that do not look like abbreviations. For example:</p><ul><li><p>The word "out" can be a word on its own, but more often than not, it is used as an abbreviation of "output". Spell out the full word.</p></li><li><p>In the methods <code>ToUpper()</code> and <code>ToLower()</code>, the terms "Upper" and "Lower" have no inherent meaning of their own; the proper terms that these abbreviations stand for are "UpperCase" and "LowerCase". Use the proper terms.</p></li></ul><h3 id=pay-attention-to-naming>Pay attention to naming</h3><p>Every single concept must have the best name that it could possibly have. Not just a good name, but an excellent name. Unfortunately, finding the right name for things is hard. It is not a coincidence that naming things is <em>One of the Two Hard Problems in Computer Science.</em> (<a class=external href=https://martinfowler.com/bliki/TwoHardThings.html target=_blank>https://martinfowler.com/bliki/TwoHardThings.html</a>)</p><p>Strive for a variety of names that uniquely and accurately reflect each concept that you are dealing with. A Thesaurus is an indispensable programming tool.</p><p>(I once worked in a metrology environment where both the main entity of interest was called a "Measurement", and the main thing that you could do with it was to perform a "Measurement"; that's deplorable.)</p><p>If a certain domain-specific term is problematic in code, then do not use that term in code. Completely ignore the domain experts who will protest that the original term is the established term in the field and it is awkward to see it replaced with something else.</p><p>(In that same metrology environment, the goal of the software was to measure and report how something differs from its ideal form; the term used in that field for this kind of difference was "error", so the software was full of identifiers called "error" that did not stand for error as we know it in software; that's deplorable.)</p><p>Avoid zero-information names; invest the necessary amount of thinking so that each name gives at least some hint as to what it is about to someone who sees it for the first time. A good rule of thumb for deciding whether a name is good is to ask yourself the following question:</p><blockquote><p>Could the same name conceivably also stand for some unrelated entity in my code base?</p></blockquote><p>(A co-worker of mine once created a namespace called "DataInfo"; that's deplorable.)</p><p>In special cases, dare to use names that you may have never heard anyone using before. For example, if you need a Factory of Factories, why not call it <em>Industry</em>?</p><p>Read Chapter 2: <em>Meaningful Names</em> of the book <em>Clean Code</em> by Robert C. Martin.</p><p>Also read this: <a href=/post/2018-05-confucius-on-naming/>Confucius On Naming Things</a></p><p>Any code written by a programmer whose English language skills are poor should be reviewed by a programmer whose English language skills are good.</p><p>When words need to be combined to form an identifier, the combination must follow general English grammar rules, except for English grammar special cases.</p><p>Read this: <a class=external href=https://softwareengineering.stackexchange.com/q/409455/41811 target=_blank>Software Engineering Stack Exchange: Clean Code: long names instead of comments</a></p><p>In the following discussion when we speak of a noun or an adjective or a verb we actually mean a sequence of various parts of speech that effectively constitute a noun or an adjective or a verb. For example, <code>reticulated_spline</code> is a noun (spline), <code>reticulated_before_dive</code> is an adjective (reticulated), and <code>dive_for_moog</code> is a verb (dive).</p><ul><li><strong>Types:</strong><ul><li><strong>Classes:</strong> The name of a class must always be a noun; it must never be an adjective or a verb; no exceptions. Also, the name of a class must always be in singular form; no exceptions. If you need to signify plurality, do not use plural! Instead, append a plurality-signifying term which is in turn a singular noun. For example, if you have a class that stands for a group of entities, do not call it 'Entities', call it 'EntityGroup' instead. (Duh!)</li><li><strong>Interfaces:</strong> The name of an interface must be either an adjective, (e.g. Comparable,) or a noun, (e.g. Serializer,) no exceptions. Singular form goes without saying.</li><li><strong>Enums:</strong> The name of an enum type must always be a noun in singular form, no exceptions. (E.g. WeekDay.Monday instead of WeekDays.Monday.)</li></ul></li><li><strong>Variables:</strong><ul><li><strong>Single-value:</strong> The name of a single-value variable must always be a noun in singular form, unless it is of boolean type, in which case it may signify a condition, such as isEmpty.</li><li><strong>Collection:</strong> The name of a collection variable must always be a noun in plural form, no exceptions.</li></ul></li><li><strong>Functions:</strong><ul><li><strong>Pure:</strong> The name of a function that returns a result without mutating anything must always be a noun unless it returns boolean, in which case it may signify a condition, such as hasChildren(). The name must be in singular form, unless a collection is returned, in which case the name must be in plural form.</li><li><strong>Impure:</strong> The name of a function that performs an operation (has side effects) must be a verb, no exceptions. If the impure function returns a result indicating success or failure, the name must begin with 'try' followed by the actual verb, for example 'tryAdd()'. If the name does not begin with <code>try</code> then the rule is that the function will signal failure by throwing an exception.</li></ul></li></ul><p>When multiple words are combined to form an identifier, they must still make sense. As an example of what to avoid, take the <code>INotifyPropertyChanged</code> interface of WPF. This name is deplorable because notify is a verb, not a noun or an adjective, and because an object implementing this interface is not a property-changed notification, it is an object which may issue property-changed notifications. Admittedly, it is difficult to come up with a good name to describe such objects; a decent choice might be <code>PropertyChangedNotificationIssuer</code>, but this might be a bit too long for some people's taste. An alternative is to use a familiar term of broader scope if there is no possibility of confusion. So, another decent choice here might simply be <code>Mutable</code>. It is true that all kinds of different classes are mutable without issuing property-changed notifications, but then again the only thing that different mutable classes could have in common simply by virtue of being mutable, so as to warrant a common interface for all of them, is issuing notifications about their mutations. The point to take home from all this is that although it is difficult to come up with good names, the application of some actual thinking should produce a name which is at least a bit better than nonsense.</p><p>As mentioned earlier, special cases of the English grammar can, and should, be ignored. An example of this is the simplification of plurals: choose "indexes" instead of "indices", "schemas" instead of "schemata", and, even though I know this is a tough proposition for some, "companys" instead of "companies". See <a class=external href=https://softwareengineering.stackexchange.com/q/290951/41811 target=_blank>Software Engineering Stack Exchange: Does it make sense to use "ys" instead of "ies" in identifiers to ease find-and-replace functionality?</a></p><p>Never begin a function name with the prefix 'check'. Doing so is a typical example of a developer choosing names according to fleeting notions in their head, without the slightest concern as to how these names will be understood by others. The word <code>check</code> means nothing; a function that only checks something and then does nothing about it would serve absolutely no purpose; presumably, whatever checking the function does culminates in taking some kind of action, or returning some kind of result; this is an extremely important piece of information that the name of the function should not fail to convey; therefore, the name of the function should indicate what kind of action is performed, or what kind of result is returned.</p><h3 id=avoid-conventions-that-make-code-look-unnecessarily-technical>Avoid conventions that make code look unnecessarily technical</h3><p>Code is, by definition, already quite technical; we do not need to be making it look even more technical than it already is. Abandon the abhorrent practice of prefixing static variables with "s_", prefixing member variables with "m_", and prefixing private member variables with "_". Modern IDEs can be configured to provide sufficient visual clues about these things via syntax highlighting. If your IDE does not support this, throw it away and find one that does. If you are not using an IDE, then please switch to the arts and humanities.</p><h3 id=avoid-hungarian-notation>Avoid Hungarian Notation.</h3><p>(<a class=external href=https://en.wikipedia.org/wiki/Hungarian_notation target=_blank>https://en.wikipedia.org/wiki/Hungarian_notation</a>.) For example, no matter how popular it is in the DotNet world, the practice of prefixing interface names with <code>I</code> is ill-conceived. What also helps in order to avoid Hungarian Notation is <em>The Maximalistic Approach to Typing</em>, where the nature of a variable is fully determined from its data type without the need for name adornments.</p><p>Which brings us to the next item:</p><h3 id=use-the-type-system-to-the-fullest>Use the type system to the fullest</h3><p>Avoid using general purpose data types; try as much as possible to use data types that are specific for the job. A classic example of this is the use of a <code>Duration</code> data type instead of an <code>int</code> number of milliseconds, but it goes a lot further than that.</p><p>So, no, your height is not of type <code>double</code>, it is of type <code>Length</code>; your married status is not a boolean, it is an instance of <code>MarriedStatus</code>; a customer id and a product id are not both of type <code>int</code>; one is of type <code>CustomerId</code>, while the other is of type <code>ProductId</code>; and so on. I call this <em><strong>The Maximalistic Approach To Typing</strong></em>. Untyped programming language aficionados can cry me a river.</p><h3 id=avoid-defensive-programming-engage-in-offensive-programming-instead>Avoid defensive programming; engage in <em>offensive</em> programming instead</h3><p>Defensive programming is summarized by <em>Postel's law</em>, otherwise known as the <em>Robustness Principle</em>, which says:</p><blockquote><p>Be conservative in what you do, be liberal in what you accept from others.</p></blockquote><p>(See <a class=external href=https://en.wikipedia.org/wiki/Robustness_principle target=_blank>https://en.wikipedia.org/wiki/Robustness_principle</a>.)</p><p>This principle suggests that besides producing output which adheres to the spec, our software should, as much as possible, be capable of coping with input that is off-spec. In other words, it should be tolerant to error. People imagine that when software behaves like that, it is more robust.</p><p>If there is one thing that I have learned in several decades of programming, both from my own code and from code written by others, it is that tolerance towards error leads to anything but bug-free software; it invariably results in chaos; and guess what chaotic software tends to be: <em><strong>buggy.</strong></em></p><p>Read this: <a class=external href=https://trevorjim.com/postels-law-is-not-for-you target=_blank>http://trevorjim.com/postels-law-is-not-for-you</a></p><p>So, instead of defensive programming, I advocate <em>offensive</em> programming, which means:</p><ul><li>Never allow any slack or leeway, require everything to be exactly as expected.</li><li>Require strict adherence to the spec even if you have no use for the full precision mandated by the spec.</li><li>Keep tolerances not just down to a minimum, but at <em>absolute zero</em>.</li><li>Never fail silently; fail <em>loudly</em> instead. Fail fast; fail hard; fail eagerly, and enthusiastically.</li></ul><p>Examples of offensive programming:</p><ul><li>Avoid conversion functions that return <code>null</code> if given <code>null</code>; always assert that the parameter is non-null. Better yet, avoid nullability altogether, or use a type system with explicit nullability, so as to restrict it via strong typing to only those places where it is meaningful. The same applies to empty strings: if an empty string is not meaningful somewhere, do not simply cope with it; explicitly and categorically disallow it.</li><li>Avoid things like a <code>Map.put()</code> method which either adds or replaces, and instead design for an <code>add()</code> method which asserts that the item being added does not already exist, and a <code>replace()</code> method which asserts that the item being replaced does in fact already exist.</li><li>In scenarios where an add-or-replace operation seems useful to have, (and in my experience, such scenarios are exceedingly rare,) add such a function but give it a name that clearly indicates the weirdness in what it does: call it <code>addOrReplace()</code>. (Duh!)</li><li>Avoid things like a <code>close()</code> method which is allowed to be invoked more than once with no penalty: assert that your <code>close()</code> methods are invoked exactly once.</li><li>Never use the garbage collector for cleanup; always perform explicit and deterministic clean-up at the exact moment when it is supposed to happen; the cleanup function invoked by the garbage collector should only be used for producing diagnostic messages in case we forgot to do explicit cleanup. Read this: <a href=/post/2020-12-27-object-lifetime-awareness/>Object Lifetime Awareness</a></li></ul><h3 id=use-inheritance-when-it-is-clearly-the-right-choice>Use inheritance when it is clearly the right choice</h3><p>The advice that <em>composition should be favored over inheritance</em> was very good advice back in the mid-1990s, because back then people were overdoing it with inheritance: the general practice was to not even consider composition unless all attempts to get things to work with inheritance failed. That practice was bad, and the fact that the predominant language at that time (C++) supported not just inheritance but actually <em>multiple inheritance</em> made things even worse. So the advice against that practice was very much needed back then.</p><p>However, the advice is still being religiously followed to this day, as if inheritance had always been a bad thing. This is leading to unnecessarily convoluted designs and much weeping, and wailing, and gnashing of teeth. Even the original advice suggested favoring one over the other, it did not prescribe the complete abolition of the other. So, today it is about time we reword the advice as follows:</p><blockquote><p>Know when to use inheritance and when to use composition.</p></blockquote><p>For a variety of opinions and a lengthy discussion about this, see <a class=external href=https://stackoverflow.com/q/49002/773113 target=_blank>https://stackoverflow.com/q/49002/773113</a></p><p>Also heed the advice by Josh Bloch to <em>design and document for inheritance or else prohibit it</em>. (See <a class=external href=https://blogs.oracle.com/javamagazine/post/java-inheritance-design-document target=_blank>https://blogs.oracle.com/javamagazine/post/java-inheritance-design-document</a>)</p><h3 id=favor-early-exits-over-deep-nesting>Favor early exits over deep nesting</h3><p>This means liberal use of the <code>break</code> and <code>continue</code> keywords, as well as <code>return</code> statements in the middle of a method whenever possible. The code ends up being a lot simpler this way. Yes, this directly contradicts the ancient "one return statement per function" dogma. I love contradicting ancient dogma.</p><h3 id=avoid-static-mutable-state-like-anthrax>Avoid static mutable state like anthrax</h3><p>Yes, this also includes stateful singletons. The fact that it only makes logical sense to have a single instance of a certain object in your world is no reason to design that object, and your world, so that only one instance of them can ever be.</p><p>You see, I guarantee to you that the need will arise in the future, unbeknownst to you today, <em>to multiply instantiate your world</em>, along with that object in it, which you thought was one-of-a-kind.</p><p>As a matter of fact, it is quite likely that you will have to do that anyway, for the purpose of testing.</p><h3 id=optimize-performance-bottlenecks-not-performance-penalties>Optimize performance bottlenecks, not performance penalties</h3><p>The ages-old advice to <em>avoid premature optimization</em> is considered common knowledge, but it is a bit vague, so it does not actually register with many folks, who will not hesitate to optimize any code construct that they consider as representing a performance penalty, under the reasoning that if it represents a performance penalty then its optimization is not premature.</p><p>For this reason, I like to rephrase the advice as "<strong>Optimize performance bottlenecks, not performance penalties</strong>" to stress the point that just because something represents a performance penalty, it does not mean that it should be optimized.</p><p>You see, all code takes clock cycles to run, so every little piece of code that we write represents a performance penalty; if that was sufficient reason to optimize it, then premature optimization would be the order of the day, every day. For something to be considered worthy of optimization, it should not merely represent a performance penalty; it should be proven to represent a performance bottleneck.</p><p>You do not know whether something is a bottleneck unless you run the completed software system, discover that its performance is unacceptable, and use the profiler to determine exactly where the bottlenecks are. Also, what usually happens in these cases is that you tend to find some nice and formal algorithmic optimizations to apply in just a few places, and make your software meet its performance requirements, without having to go all over the entire source code base and tweak and hack things to squeeze clock cycles here and there.</p><h3 id=put-the-tools-of-the-trade-into-use>Put the tools of the trade into use</h3><p>Armies of very good developers have worked hard to build these tools, don't you dare make their efforts go in vain.</p><ul><li><p>Use an IDE.</p><p>Programmers who think that they are better off with their favorite text editor should be admitted to rehabilitation.</p></li><li><p>Use the <em>build</em> feature of your IDE, which only compiles modified files.</p><p>Programmers who habitually perform a full <em>rebuild</em> instead of a plain build should be fired.</p></li><li><p>Use your IDE for running tests.</p><p>Programmers who habitually run tests via separate tools outside of the IDE should be shot.</p></li><li><p>The continuous build pipeline is your second line of defense, not your primary means of building and testing. Your IDE will always be a lot faster, and it has a built-in debugger.</p></li><li><p>Use the debugger of your IDE as your first choice for troubleshooting anything, not as the last resort after all other options have been exhausted. This means that you should be using the debugger not only when there is trouble, but always, by default, so that it is ready when trouble occurs. This in turn means that when you want to fire up your creation, or to run the tests, you should never hit the "Run" key on your IDE; you should hit the "Debug" key instead. Always the "Debug" key. Only the "Debug" key. You are a programmer; act like it.</p></li><li><p>Having said all that, I should also add that people who are so attached to their IDE that they program by dragging and dropping code snippets around should perhaps consider that some desktop publishing job might suit them better.</p></li><li><p>Do not even think that you are done with testing unless the code coverage tool gives you sufficient reason to believe so.</p></li><li><p>Have your IDE perform code analysis, and incorporate even more code analysis in the continuous build.</p></li></ul><h3 id=design-with-reliability-as-a-foundation-not-as-an-afterthought>Design with reliability as a foundation, not as an afterthought</h3><p>For example, sharing data in a multi-threaded environment by means of traditional locking techniques ("synchronization") is both error-prone and untestable, because you cannot test for race conditions. Note that "error prone" and "untestable" is a deadly combination; therefore, this way of sharing data should be abandoned. Instead, design for a lock-free, share-nothing approach that works by passing immutable messages, thus eliminating the very possibility of race conditions.</p><h3 id=design-with-security-as-a-foundation-not-as-an-afterthought>Design with security as a foundation, not as an afterthought</h3><p>Security is not something that you can add on top of an insecure foundation, because there exist no automated tests that can detect security hazards and no amount of carefulness on behalf of programmers that is careful enough. So, what is necessary is architectural choices that eliminate entire classes of security hazards. (Do not worry, there will always be other classes of security hazards to have to worry about.)</p><p>So, if a certain architectural choice is prone to security vulnerabilities, do not make that choice. An example of a vulnerability-prone architectural choice is putting application code on the web browser, otherwise known as full-stack development. Full-stack developers can cry me a river.</p><p>For more on this, read: <a href=/post/2021-12-full-stack-development/>What is wrong with Full Stack Development</a></p><h3 id=keep-the-log-clean>Keep the log clean</h3><p>Do not vex your colleagues, and do not make your own life harder, with torrential info-level or debug-level spam in the log. Keep the info-level messages down to an absolute minimum, and once debugging is done, completely remove all the debug-level log statements. Utilize commit hooks that deliberately fail a commit if it contains debug-level logging statements. Regularly use the "blame" feature of the version control system to remind developers of info-level logging statements that they should remove. Never use the log for capturing metrics or any other kind of structured information; use some separate, specialized instrumentation facility for that.</p><h3 id=make-the-best-out-of-the-log>Make the best out of the log</h3><p>You should at all times be able to click on a log line in the output window of the IDE and be taken to the source line that generated that log entry, and you should also at all times be able to click on any line of a logged exception stack trace and be taken to the corresponding line of source code. I am appalled by how many programming environments do not offer this as the default mode of operation under all circumstances.</p><ul><li>In the Microsoft Visual Studio world, for a line to be clickable in the output window it must start with a source pathname, followed by an opening parenthesis, a line number, a closing parenthesis, and a colon. It can optionally be prefixed with whitespace.<ul><li>Fortunately, both C++ and C# support efficient means of obtaining source file name and line number information: In C++ it is the <code>__FILE__</code> and <code>__LINE__</code> built-in pre-processor macros, while in C# it is the <code>CallerFilePath</code> and <code>CallerLineNumber</code> attributes.</li><li>Unfortunately, the pathnames generated by these mechanisms are absolute, meaning that they start from the drive letter and include the kitchen sink, so you might want to programmatically convert them to pathnames relative to the solution folder before logging them. Visual studio also recognizes those, though this is undocumented.</li></ul></li><li>In the Jetbrains IntellijIdea world, for a line to be clickable in the output window it needs to contain an identifier, followed by an opening parenthesis, a source filename-plus-extension, (but no path,) a colon, a line number, and a closing parenthesis.<ul><li>The identifier is meant to be a package name, but Idea does not interpret it in any way, so it can be anything.</li><li>Due to a long-standing bug (which JetBrains refuses to acknowledge or fix) if the word "at" appears in the log line, and if it is in any place other than immediately before the package name, then this mechanism breaks. (Note that this is all entirely undocumented.)</li><li>Note that this mechanism suffers from ambiguity in the case of multiple source files with the same filename. An alternative mechanism is to include a "file://" URI in the log entry, but in order to produce such a URL you would have to figure out the path from the package name, which is doable, but not easy.</li><li>Unfortunately, Java does not provide any efficient means of obtaining source file name and line number information, so one has to generate a stack trace in order to extract this information from it.</li><li>Fortunately, generating a stack trace in the java world is not anywhere near as expensive as in the Microsoft world.</li><li>Unfortunately, it is still unreasonably expensive. You can see this performance penalty as one more reason to keep logging to a minimum.</li></ul></li></ul><h3 id=take-maxims-with-a-grain-of-salt>Take maxims with a grain of salt</h3><p>(Especially quantitative maxims, which offer specific numerical limits for things.)</p><p>When someone says "no function should accept more than 4 parameters" or "no class should be longer than 250 lines" they are usually talking nonsense.</p><p>A class should be as long as necessary to do its job, and if that is 2000 lines, so be it. I would much rather keep some ugly code confined in a single class than split it into multiple classes and thus propagate the ugliness in the design.</p><p>A function should accept as many parameters as necessary to do its job, and if that is 15 parameters, so be it. I would much rather have a long constructor than a mutable object.</p><p>Breaking things down to smaller units should be done because there is some actual tangible merit in doing so, not because some prophecy said so.</p><h3 id=private-static-methods-are-fine-really>Private static methods are fine. Really</h3><p>An instance method has the entire object state at its disposal to read and manipulate, and this state may be altered by any other instance method, including instance methods that this method may invoke. The complexity of this is mind-boggling. A static method on the other hand is obviously not in a position to read nor alter any of the object's state, and it is unable to invoke any instance methods that would do that. By its nature, a static method has to rely exclusively on parameters, which are all clearly visible at each call site. Thus, a static method is an <em><strong>immensely less complex</strong></em> beast than an instance method. What this means is that private static methods are not the slightest bit evil as some folks believe they are, and we should have more of them.</p><p>Personally, when I have a class that has both complex logic and mutable state, I tend to move the complex logic into private static methods, reducing the instance methods to doing nothing but invoking private static methods, passing instance fields to them and storing results into instance fields as necessary.</p><h3 id=do-not-fix-it-unless-there-is-a-test-for-it>Do not fix it unless there is a test for it</h3><p>I do not yet have an opinion about test-driven development, but what I have found to be immensely useful, is <em>test-driven maintenance</em>. So, when a bug is discovered, which obviously passed whatever automated tests you already had in place, do not hurry to figure out what causes it and fix it. First, write a test that tests for the bug, being completely agnostic of any theory that you might already have as to what is causing the bug. This test should initially fail; if it does not fail, then the bug is not what you think it is, so you have more research to do. If the test fails as it should, then fix the bug according to your theory as to what is causing it. If the test now passes, then your theory was correct. If not, then not only you have not fixed the bug, but you have probably broken something else which used to be fine.</p><h3 id=avoid-death-by-ten-thousand-little-methods>Avoid death by ten thousand little methods</h3><p>Again and again I see code bases with multitudes of tiny methods having cryptic names, each containing just one or two lines of trivial code, aiming to ensure that not a single line of code is duplicated anywhere. The downside of this is that it increases the complexity of the call tree and therefore the amount of mental effort required to make sense out of it. A new function is worth introducing if it has a well-defined, meaningful role to play. Difficulty in coming up with a name for a function, or having many functions with names that differ only slightly and fail to readily convey the difference between them, are both good indicators that these functions have no role to play other than to avoid code duplication. Of course there is merit in reducing code duplication, but not when the code in question is trivial. And when you see the possibility to de-duplicate non-trivial code, then the well-defined, meaningful role of the function tends to be immediately obvious, as well as the appropriate name for it.</p><h3 id=make-the-best-out-of-break-on-exception>Make the best out of break-on-exception</h3><p>Set up your development tooling, and use whatever runtime mechanisms are necessary, so that the debugger always stops at any statement that throws an unexpected exception.</p><p>Many programmers have the bad habit of doing all their troubleshooting by examining logs and postmortem stack traces and theorizing as to what went wrong, instead of having the debugger break on exception and actually seeing what went wrong. This is extremely counter-productive.</p><p>Unfortunately, exceptions are a somewhat complex topic, programming languages and their run-times behave in complex ways when exceptions are thrown, and debuggers have complex mechanisms for dealing with them, none of which helps. As if that was not enough, it is not always easy to tell when a certain exception should be expected and when it should not be expected.</p><p>Thus, there exist several obstacles to accomplishing proper, usable, break-on-exception:</p><ul><li>Our code throws and catches expected exceptions all the time, or uses external libraries that do so, internally, all the time; clearly, we do not want the debugger to stop on any of those.</li><li>One might think that the solution to this problem would be to configure the debugger to ignore caught exceptions and only stop on uncaught exceptions; unfortunately, that will not work either, because quite often we have exceptions that we consider as uncaught, but technically they are caught; for example:<ul><li>An external library invokes our code, and our code throws an exception, which is uncaught as far as our code is concerned, but it is caught by the external library. A typical example of this is event-driven frameworks, i.e. virtually all GUI frameworks, which invoke our code to handle events, and almost always do so from within a try-catch block. Thus, any exception thrown by our event handlers is actually a caught exception, and the debugger will not stop on it.</li><li>In many languages, the <code>try-finally</code> clause internally catches exceptions and re-throws them at the end of <code>finally</code>, meaning that any exception thrown within the <code>try</code> block is technically a caught exception. Thus, a debugger configured to stop on uncaught exceptions will break at the end of the <code>finally</code> block, which is completely useless and counter-productive. The same problem is encountered with other constructs which are internally implemented using <code>try-finally</code>, such as the synchronization clause, the automatic disposal clause, etc.</li><li>To complicate matters even further, an exception which is unexpected and unhandled under normal circumstances may temporarily become expected and handled during testing. This happens when a test deliberately causes malfunction to ensure that the component-under-test detects it and responds by throwing an exception, which is then caught by the test and examined to ensure that it is the correct exception and it has been correctly filled-in; when this happens, we do not want the debugger to stop, because we do not want our tests to be interrupted by the debugger while everything is proceeding according to plan.</li></ul></li></ul><p>Here is a StackOverflow question and answer which simplifies things a lot: <a class=external href=https://stackoverflow.com/q/71115356/773113 target=_blank>https://stackoverflow.com/q/71115356/773113</a></p><h3 id=write-code-as-if-it-will-be-reviewed-by-someone-even-if-it-never-will>Write code as if it will be reviewed by someone, even if it never will</h3><p>Always try to take one more look at the code from a completely agnostic point of view, supposing that you know nothing about what it does, why it does it, how it does it. Does the code still make sense? Is everything obvious? If not, refactor it until it is as plain as daylight. If comments are necessary to explain what is going on, can the code be refactored so that the comments become unnecessary?</p><p>Which brings us to the next point.</p><h3 id=avoid-writing-code-comments>Avoid writing code comments</h3><p>Never add a comment in the code unless absolutely necessary. (Note that this applies to code comments, not to
public interface comments, which can be nice to have.)</p><ul><li>The purpose of a code comment should be to alert the reader that something special is happening here, which is not obvious, and cannot be explained by any means other than written prose. This should only be necessary in exceptional situations, while the norm should be that the code is always so simple, and so self-explanatory, that no comments are necessary.</li><li>An example of an exceptional situation is provenance comments, see related section.</li><li>Code comments that simply state what the code does are unwarranted causes of alert, and if you repeat them enough they will force the reader to start treating your comments as noise, and may thus cause the reader to miss that rare comment which was actually important to note.
- Comments tend to be necessary when a piece of code does something unexpected, which is usually code that takes special measures to circumvent some anomalous behavior of some other code. In these cases, explaining what the code does is not even the goal; the goal is to explain <em>why</em> it does it, and in order to explain that you have to describe the anomalous behavior, which may even necessitate listing various usage scenarios that have been tried and results that have been observed. This in turn means that comments worth writing tend to be entire multi-paragraph-long essays explaining strange and complicated situations. In my experience, one-liners are usually of no value.
- Note that when documenting code that circumvents anomalous behavior it is a good idea to assert, if possible, that the anomalous behavior is in fact still present, so that if it gets fixed in the future, you will take notice so you can remove the code that circumvents it.
- If you find yourself adding a code comment, first ask yourself whether there is anything you can do to avoid that.<ul><li>Instead of adding a comment to some piece of code explaining what it does, extract that code into a separate function that has a self-explanatory name.<ul><li>However, it is even better to restructure the code, if possible, so that even the explanatory name becomes unnecessary. For example, in old C code you might come across a pointer-returning function whose documentation says that the caller is responsible for freeing the pointer. This is deplorable. Do whatever it takes to avoid this; use a callback, use an allocator parameter, have the caller supply the memory, throw it all away and rewrite it in Java, anything but requiring people to read comments or else they get punished with memory leaks.</li></ul></li><li>Instead of adding a comment to a hard-coded value, extract that value into a constant that has a self-explanatory name.<ul><li>When performing a calculation which involves a certain fixed value, it goes without saying that you will <em><strong>not</strong></em> hard-code some magic number in the calculation; instead, you will declare a constant with a nice descriptive name for that value, and use the constant in the calculation. Note that this must be done even
in fairly trivial cases, for example <code>const int BitsPerByte = 8;</code> and can only be skipped in an exceedingly small number of special cases, for example when directly multiplying something by 2 in order to double it, or by -1 in order to negate it.
- If a comment can be coded as an assertion statement, that's all the better. Comments saying "x must be greater than y here" are retarded. Assert the darn thing, and spare us from the comment, or perhaps use a comment to explain the <em>why</em>, but not the <em>what</em>. The assertion takes care of the <em>what</em>, and it does so unambiguously and definitively, because it compiles and passes the tests, which is something that no comment will ever do.
- If you modify some code, and there is a comment attached to that code, do not forget to do something about the comment: Ideally, your modifications should make the comment redundant, so you should remove it. If not, then at least make sure that the comment is still valid after the modifications. Unfortunately, programmers often leave comments unchanged while changing the code around them, thus making every single comment in the entire code base liable to devolving into being inaccurate, or even misleading, and thus constituting an instance of sabotage. This is happening because:</li></ul></li><li>Programmers treat comments as noise, and therefore do not even notice their presence. (This is why comments should be used very rarely, in exceptional situations only.)</li><li>Comments are poorly written, so programmers do not understand them. When a programmer does not understand a comment, they obviously cannot modify it, but it gets even worse: they do not dare to remove it either, because they assume that it must have some special meaning to some other programmer. Thus, poorly written comments are very similar to <a class=external href=https://en.wikipedia.org/wiki/Persistent_organic_pollutant target=_blank>Persistent Organic Pollutants (POPs) a.k.a. <em><strong>forever chemicals</strong></em></a>: once created, they stay in the environment, causing harm for all eternity.</li></ul></li></ul><p>If a comment does not make sense to you, then find the author, ask them what it means, and update it accordingly. If the author is not around anymore, then ask any other experienced programmer in the shop. If they cannot tell what it means either, then trust me, this comment will never make sense to anyone, so go ahead and remove it.</p><h3 id=if-you-must-write-doc-comments-make-them-good>If you must write doc-comments, make them good</h3><p>Ideally, an entity (class or method) should have a well-chosen name and a very simple and straightforward interface or prototype, so that everything is clear at a glance, and therefore no doc-comment is needed. If things are not so simple, then it may be necessary to clarify them with a doc-comment.</p><ul><li><p>A doc-comment must be as simple and as brief as possible.</p><ul><li>Do not try to follow templates, or if you do, then treat all template fields as optional: skip any information that is not strictly speaking necessary.</li><li>Some bureaucratic documentation guidelines require the doc-comment of a function to follow a specific template which begins with a summary line, is followed by one line for each parameter, and includes one line for the return value. If your function really needs all this information to be explained in a doc comment, then your function must be doing something extremely bizarre. If your function is not doing anything bizarre, then a single summary line might suffice to explain what it does; if so, then skip the extra lines explaining each parameter, as well as the extra line explaining the return value.</li><li>As an example of what to avoid, see the <code>IEnumerable&lt;T>.GetEnumerator()</code> method of C#/dotnet. The doc comment says:
Description: Returns an enumerator that iterates through the collection.
Returns: An enumerator that can be used to iterate through the collection.
As you can see, the documentation is repeating itself. This is wasting the time of anyone attempting to read this documentation. This is annoying. Do not do this.</li></ul></li><li><p>A doc-comment is a public interface comment, not an implementation comment. As such, a doc-comment on an entity should explain, in the most brief and abstract terms possible, the following:</p><ul><li>What task it accomplishes.</li><li>What input it accepts.</li><li>What output it produces.
Note that it does not need to address each one of those items separately; a doc-comment on a method which simply says that it "sorts a file in-place" explains all three items in one go.</li></ul></li><li><p>A documentation comment should not make the slightest attempt to explain any of the following:</p><ul><li><em>How</em> the task is accomplished.</li><li>Which entities are expected to invoke the entity.</li><li>Which entities are invoked by the entity.</li></ul><p>The above points are important to state because many misguided practices from the infancy of our discipline have it all wrong by stipulating that documentation comments should include preposterous things such as who invokes whom, completely missing the whole point behind the notion of <em>general-purpose, reusable software</em> and even the fundamental notion of <em>abstraction</em>.</p><p>If you are asking "but shouldn't documentation describe the how?" the answer is no, that's what we write code for. By definition, the only authoritative source of information as to how something is done is the code that does it. As I have already explained, the code must be so simple and so easy to read that English-language prose on top of it should be bringing no added value. As a matter of fact, the presence of prose is dangerous, because quite often people modify the code without bothering to also modify the documentation, which leads to situations where the documentation is misleading.</p><ul><li>If, after looking at the code, something is still unclear, then place a breakpoint and launch the tests; the debugger will make things pretty clear to you.</li><li>If you are wondering how the code works under a case which is not covered by the tests, then fix this by adding a test for that case! (Duh!) Also note that even if there was a "how" section in the doc-comment, it probably would not have covered that special case anyway.</li></ul></li></ul><h3 id=always-maintain-provenance>Always maintain provenance</h3><p>When you copy some code from the interwebz, always add a comment containing a link to the original source. Of course this is not necessary if the code that you copied is something fairly standard, like reversing a string; but if the code is anything but standard, (do you have any idea what it takes in Microsoft Windows to have a progress dialog shown while copying files?) then citing your sources is an absolute must.</p><p>Sources can include:</p><ul><li>Examples from the official documentation (provide a link to the example page)</li><li>Stack Overflow (provide a link to the answer)</li><li>GitHub (provide a link to the source file(s))</li><li>ChatGPT (give the exact prompt which yielded the code)</li><li>etc.</li></ul><p>This applies not only to code, but also to any piece of information, including individual values. Why did you choose this particular value and not some other value? Unless the value in question is a <a class=external href=https://en.wikipedia.org/wiki/Fundamental_constant target=_blank>Fundamental Constant</a> (e.g. <code>static readonly Velocity SpeedOfLight = 299792458.0</code>) you should add a comment to it explaining exactly why this particular value was chosen, or where it came from. For example, if you need to use the population of Mexico City in code, then <code>const int MexicoCityPopulation = 9209944;</code> is not enough; it must be followed by a comment saying <code>//2020 data from https://en.wikipedia.org/wiki/Mexico_City</code>.</p><h3 id=stick-with-utc-everywhere>Stick with UTC everywhere</h3><p>Use UTC and only UTC for any purpose that involves storing, retrieving, communicating, converting, calculating, and doing really anything whatsoever with time, except for the following two cases, and only the following two cases:</p><ul><li>Parsing a string that was entered by the user into a UTC time variable.</li><li>Converting a UTC time variable to a string to be shown to the user.</li></ul><p><strong>However:</strong> When dealing with events that happen in the future, make sure to also store the targeted time-zone along with the UTC coordinate, because every few years various countries around the world decide to change their daylight savings policy, which means that the mapping from UTC to local time may change in the future, and you have no way of knowing that in advance.</p><h3 id=keep-technical-implementation-concerns-separate-from-application-concerns>Keep technical implementation concerns separate from application concerns</h3><p>Application code should not be making assumptions about the technical details of the system, so that the technical details are free to change with minimal changes to application code, and vice versa.</p><p>For example, the multi-threading regime under which a system operates (whether the system utilizes a single thread, or multiple discrete threads, or a thread-pool,) is a technical implementation concern. As such, all knowledge of how multi-threading is done should be isolated in the relatively small body of code which wires up (realizes) the system, and all application code should be capable of operating regardless of the multi-threading regime. Incidentally, this facilitates running tests under a strictly single-threaded regime, to ease debugging. Async/await aficionados can cry me a river.</p><h3 id=maximize-the-consistency-of-code-formatting>Maximize the consistency of code formatting</h3><p>I would be tempted to say "format code with absolute consistency", but I cannot, because we usually lack the tools to achieve this, so the goal is to strive to get as close as possible to achieving absolute formatting consistency.</p><p>In the preface of the highly acclaimed book "Clean Code" by Robert C. Martin, the author mentions some experimental findings indicating that "consistent indentation style was one of the most statistically significant indicators of low bug density." The author also states that "style distinguishes excellence from mere competence", which I think is a very good observation; however, the conclusion at which the author arrives is unwarranted, because correlation does not imply causation: it is probably not the consistent indentation style that causes fewer bugs, it is the kind of mindset of programmers who strive for a consistent indentation style which also happens to be the kind of mindset that produces fewer bugs. Be the programmer who has that mindset.</p><p>If you are one of those programmers who do not particularly care for consistent formatting, I know what you are thinking right now: you are thinking that you are the rare exception to the rule, and that your code is of course awesome and bug-free despite looking sloppy; well, you have every right to think in any way you like about yourself, but I hope you understand that nobody else will be particularly willing to give you the benefit of the doubt.</p><p>Note that this does not mean that every programmer must be forced to follow a specific set of formatting guidelines; on the contrary, by using tools to do the formatting for us, we do not have to worry about formatting. The corollary to this is that as an employer, the only kind of code formatting that you have the right to require from programmers is that which can be achieved by means of automatic code reformatting tools that you already have in place.</p><p>The point to take home from all this is that the formatting style must be specified in the highest detail possible, the tools must be painstakingly configured to reformat code according to that style, and the guidelines of how to work around limitations of the tools must be laid down and agreed upon before any work is done on a software project, no matter how much effort all of this represents.</p><h3 id=use-tight-abstractions>Use tight abstractions</h3><p>In other words, avoid leaky abstractions.</p><p>Joel Spolsky's <a class=external href=https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/ target=_blank>original 2002 article formulating the <em>Law of Leaky Abstractions</em></a> stated that "All non-trivial abstractions, to some degree, are leaky". The article focused on examples where implementation details of the underlying layer are exposed not by the interface itself, but by observing the performance characteristics of the underlying layer. For example, the interface of two-dimensional arrays is generic enough to allow us to iterate over them either row-first or column-first without having to know their internal memory layout; however, which way we choose can have drastic performance implications, due to memory cache utilization. This means that we do of course have to keep in mind the technicalities of the layer which implements the abstraction; it does not, however, mean that the interface should be compromised in any way.</p><p>More often than not, in our daily jobs we have the misfortune of dealing with abstractions that are leaky at the interface level. A glaring example of this, in languages like C# and Java, is <code>class Object</code>, whose public interface contains a hash-code function, which is entirely out-of-place and unwarranted, because it has to do with an implementation detail of hash-maps.</p><p>This mishap could have been avoided in a number of different ways, for example:</p><ul><li>Require the programmer to supply, upon hash-map construction, the hashing function to use.</li><li>Require objects intended to be used as keys in a hash-map to implement a <code>Hashable</code> interface which defines a hash-function.</li></ul><p>Unfortunately, neither of these approaches was chosen, either by Java or by C#, due to some misguided notion of convenience. Instead, the implementation detail of hash-maps that they need a hash function to work with has leaked into <code>Object</code>, requiring every single class to have a hash-code method, even if the class will never be used as a key in a hash-map, and even if the class is mutable, and should therefore <strong>never</strong> be used as a key in a hash-map.</p><p>Another example is serialization frameworks that leak details about the underlying file format that they work with: every single XML or JSON serialization framework that I have come across exposes XML-specific functionality or JSON-specific functionality; therefore, it is an XML serialization framework, or a JSON serialization framework, but not a general-purpose serialization framework.</p><p>A proper general-purpose serialization framework would expose no file format details in its interface, thus being replaceable with a different implementation which serializes to and from some other file format, without any changes necessary to the code that uses the framework. I have written such a framework, and I assure you it was not easy, but here is the thing: <em>Doing it right</em> â„¢ is never easy.</p><p>Leaky abstractions are the source of untold suffering in software development, and they must be avoided at all costs. Creating air-tight abstractions is often omitted in the interest of saving time, and people make do with leaky abstractions instead, but this invariably results in orders of magnitude more time wasted over the long run in dealing with the disastrous consequences of the leaky abstractions.</p><p>I would dare to propose that the term abstraction has (or ought to have) an inherent notion of absoluteness; just as one can be either pregnant or non-pregnant but not slightly pregnant or almost pregnant, so can an interface either be an abstraction or not an abstraction; it cannot be somewhere in-between. Thus, an incomplete or leaky abstraction should, for all practical purposes, be regarded as not an abstraction. (Because that's what the <em>almost absolute</em> is: <em>non-absolute</em>.)</p><h3 id=thoroughly-emulate-any-and-all-hardware>Thoroughly emulate any and all hardware</h3><p>Hardware emulation is a special case of abstraction, where instead of abstracting software we are abstracting hardware. Incomplete hardware emulations are a curse for the same reasons that leaky abstractions are a curse. Hardware emulations must be 100% complete so that any software performing high level operations with the hardware can make use of all of the functionality of the hardware while remaining completely agnostic of whether it is connected to the real hardware or to an emulation thereof.</p><h3 id=only-use-absolute-file-system-paths>Only use absolute file-system paths</h3><p>All file-system paths must be absolute. It is fine to provide the user with the convenience of entering a relative path, but the relative path must be converted to absolute immediately upon entering the system. Relative paths are based on the notion of a "current directory", which is one of the most ill-conceived, misused, and treacherous notions in the history of programming, because it is a global mutable variable. (I hope I do not need to explain why a global mutable variable is evil, right?) Note that the "current directory" is global not only across all classes of your application, but also across all threads of your application, and, in DotNet, even global across all AppDomains of your application, which were supposed to be completely isolated. Duh!? What were they thinking?</p><h3 id=avoid-guids-also-known-as-uuids>Avoid GUIDs (also known as UUIDs)</h3><p>Never use GUIDs if you can avoid them. If you must use them, then make sure they are an implementation detail and that they constitute a side-note of your design, not a predominant feature of your design. Read this: <a href=/post/2017-06-on-uuids-and-guids/>What is wrong with UUIDs and GUIDs</a>.</p><h3 id=do-it-right->Do It Right â„¢</h3><p>Avoid taking shortcuts in the name of immediate savings now but at the expense of headaches later, because the later headaches invariably end-up costing orders of magnitude more than the immediate savings. When some colleague, manager, or decision-maker suggests to "make it simple now, and worry about making it right later" they are imagining that they are being smart and they are helping optimize things, while in fact they are being a smart-ass, and they are suggesting that a technical crime be committed.</p><p>An example of this, which has already been mentioned, is finding proper names for identifiers. If you want to introduce a new identifier, finding a proper name for it may require opening up the thesaurus, spending a considerable amount of time creating a list of candidate words, opening up the dictionary, looking up the exact meaning of each candidate word, applying the process of elimination, etc. So, you can save lots of time right now by skipping all this and simply calling it something meaningless, or worse yet, something inaccurate and therefore misleading. It is a fact that you will indeed experience immediate time savings right now if you do this. However, it is also a fact that the time you save now by performing this act of sabotage against yourself will invariably be paid a hundredfold later, when you and your coworkers will be wondering what on earth was meant by this meaningless name, or struggling with the realization that it is being used in the code in ways that are in conflict with its meaning.</p><p>Of course, <em>Do It Right</em> â„¢ does not apply only to naming, it applies to everything. And when I say everything, I mean <strong>E V E R Y T H I N G</strong>. The practice of <em>Do It Right</em> â„¢ must be a conditioned reflex; it must be the default, reliable, fail-safe, look-no-further choice that we always make, without spending time calculating the costs vs. savings of <em>Do it Right</em> â„¢, debating whether we should <em>Do It Right</em> â„¢ or not <em>Do It Right</em> â„¢, etc. The term <em>Do It Right</em> â„¢ contains in it the reason why we should <em>Do It Right</em> â„¢.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><em><strong>C.V. Driven Development</strong></em>: See <a class=external href=https://martinjeeblog.com/2015/03/11/cv-driven-development-cdd/ target=_blank>Martin Jee's blog - CV Driven Development (CDD)</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><footer class=article-footer><section class=article-tags><a href=/tags/software-architecture/>Software Architecture</a>
<a href=/tags/software-engineering/>Software Engineering</a>
<a href=/tags/papers/>Papers</a>
<a href=/tags/wisdom/>Wisdom</a></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on 2025-10-23 Thu 19:23:41 CEST</span></section></footer></article><script>var idcomments_post_id,idcomments_post_url,idcomments_acct="131c02e0ef20d1a4606aa4e3490711ba"</script><span id=IDCommentsPostTitle style=display:none></span>
<script type=text/javascript src=https://www.intensedebate.com/js/genericCommentWrapperV2.js></script><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/2024-03-codecoverage/><div class=article-details><h2 class=article-title>Artificial Code Coverage</h2></div></a></article><article><a href=/post/2024-01-types-of-dependencies/><div class=article-details><h2 class=article-title>Types of dependencies</h2></div></a></article><article><a href=/post/2023-12-27-call-graph-acyclicity/><div class=article-details><h2 class=article-title>Call Graph Acyclicity</h2></div></a></article><article><a href=/post/2023-12-09-authoritative-technical-design/><div class=article-details><h2 class=article-title>Towards Authoritative Software Design</h2></div></a></article><article><a href=/post/2023-01-14-mocking/><div class=article-details><h2 class=article-title>If you are using mock objects you are doing it wrong</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy; 2001 - 2026 Michael Belivanakis (a.k.a. Mike Nakis)</section><section class=powerby>Made using <b><a href=https://obsidian.md target=_blank>Obsidian</a></b> and <b><a href=https://gohugo.io/ target=_blank>Hugo</a></b><br>Theme based on <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank data-version=%s>hugo-theme-stack</a></b> by <a href=https://jimmycai.com target=_blank>Jimmy Cai</a><br></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>